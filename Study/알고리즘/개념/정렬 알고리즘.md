#알고리즘 #정렬 #코테

## 버블 정렬

버블 정렬은 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식이다.

### 시간 복잡도

> 시간 복잡도는 O(n^2) 으로 다른 정렬 알고리즘보다 느린 편이다. 루프를 돌면서 인접 데이터 간의 swap 연산으로 정렬한다.

### 버블 정렬 과정

![[Pasted image 20230819210849.png]]

1. 비교 연산이 필요한 루프 범위 설정
2. 인접한 데이터 값을 비교한다.
3. swap 조건에 부합하면 swap 연산을 수행한다.
4. 루프 범위가 끝날 때 까지 2~3을 반복한다.
5. 정렬 영역을 설정한다. 다음 루프 시 이 영역을 제외한다.
6. 비교 대상이 없을 때 까지 1~5를 반복한다.
만약 특정 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면 영역 뒤에 있는 데이터가 모두 정렬되었다는 뜻으로 프로세스를 종료해도 된다.

---

## 선택 정렬

선택 정렬은 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법이다.

최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 가장 앞에 데이터와 swap 하는 것이 선택 정렬의 핵심이다.

### 시간 복잡도

> 시간 복잡도는 O(n^2)으로 효율적이지 않아 코딩테스트에서 많이 사용하지 않는다.

### 선택 정렬 과정

1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
2. 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
3. 가장 앞 데이터 위치를 한 칸 이동
4. 전체 데이터 크기만큼 index가 커질 때까지 반복한다.

![[Pasted image 20230819211635.png]]

### 시간 복잡도가 O(N^2) 인 이유

loop 1 일 때, N번 반복하고, loop를 반복할 수 록 N-i 번 반복한다.

1/2 N번 정도 반복을 해야하고, 총 N번 loop가 돌아야 하므로 

`1/2N * N` 이 된다.

하지만 시간 복잡도에서 상수는 제외 하므로 시간 복잡도는 O(n^2) 이 된다.


---

## 삽입 정렬

삽입 정렬은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식이다.

선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것이 삽입 정렬의 핵심이다.

### 시간 복잡도

> O(n^2)


![[Pasted image 20230819213549.png]]

### 삽입 정렬 과정

1. 현재 index에 있는 데이터를 선택한다.
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
3. 삽입 위치부터 index에 있는 위치까지 shift연산을 수행한다.
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index를 증가 시킨다.
5. 선택할 데이터가 없을 때까지 반복한다.

적절한 삽입 위치를 탐색하는 부분에서 (정렬된 범위 내에서) 이진 탐색 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있다.

---

## 퀵 정렬

퀵 정렬은 기준 값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘이다.

기준 값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미친다.

### 시간 복잡도

> 평균 시간 복잡도는 O(nlogn)(병합 정렬)이고, 최악의 경우 O(n^2)(버블, 선택, 삽입 정렬) 이 된다.



pivot을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬하는 것이 퀵 정렬의 핵심이다.

![[Pasted image 20230820143918.png]]
### 퀵 정렬 과정

1. 데이터를 분할하는 pivot을 설정한다.
2. pivot을 기준으로 2.1~2.5 과정을 거쳐 데이터를 2개의 집합으로 분리한다.
	1. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 한 칸 이동한다.
	2. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 한 칸 이동한다.
	3. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 한 칸씩 이동한다.
	4. start와 end가 만날 때까지 2.1~2.3을 반복한다.
	5. start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
3. 분리 집합에서 각각 다시 pivot을 선정한다.
4. 분리 집합이 1개 이하가 될 때까지 1~3을 반복한다.


퀵 정렬의 시간 복잡도는 비교적 준수하므로 코딩 테스트에서 종종 사용한다.


---
## 병합 정렬

병합 정렬은 분할 정복 방식을 사용해 데이터를 분할하고, 분할한 집합을 정렬하며 합치는 알고리즘이다.

### 시간 복잡도

> 병합 정렬의 시간 복잡도는 O(nlogn) 이다.
> 
> 매번 n번 데이터 Access가 일어나고 총 logn번 수행 하기 때문에 O(nlogn) 시간복잡도가 나온다.

![[Pasted image 20230820144934.png]]

위 그림에서 최초 8개 그룹으로 나누고, 2개씩 그룹을 합치며 오름차순 정렬한다.
매번 2개의 그룹씩 병합 정렬 과정을 마치면 전체 오름차순 정렬을 할 수 있다.


### 2개의 그룹을 병합하는 과정

투 포인터 개념을 사용하여 왼쪽, 오른쪽 그룹을 병합한다. 왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 작은 값을 결과 배열에 추가하고 포인터를 오른쪽으로 1칸 이동시킨다.

