#알고리즘 #탐색 #코테 

완전 탐색은 **모든 경우의 수를 다 체크해서 정답을 찾는 방법**이다.

## 완전 탐색 기법 활용 방법

1. 문제의 가능한 경우의 수를 대략적으로 계산한다.
2. 가능한 모든 방법을 고려한다.
3. 실제 답을 구할 수 있는지 적용한다.

고려할 수 있는 방법은 다음과 같다.

### 1. Bruth Force

반복 / 조건문을 활용해 모두 테스트하는 방법

### 2. 순열(Permutation)

n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법

순열은 임의의 수열이 있을 때, 그것을 **다른 순서로 연산하는 방법**을 의미한다.

만약 N개의 데이터가 있고 이를 순열로 나타내면 순열의 가지 수는 **N!** 이 된다. (N, N-1, N-2...1)

### 3. 재귀 호출

재귀 호출은 자기 자신을 호출하여 탐색하는 방법이다.

만약 숫자 N 중 M개를 고르는 경우라고 할 때, N과 M이 큰 수라면 2중 반복문을 사용하여 풀면 굉장히 많은 비용이 든다.

이를 재귀 함수를 활용하면 자기 자신을 호출하여 다음 숫자를 선택할 수 있도록 이동시켜 코드를 줄일 수 있다.

#### 재귀 함수 조건

1. 재귀를 탈출하기 위한 탈출 조건이 필요하다.
2. 현재 함수의 상태를 저장하는 Parameter가 필요하다.
3. return문을 신경 써야한다.

이는 다이나믹 프로그래밍과 유사하다.

#### 완전 탐색의 재귀와 DP의 차이점

DP는 작은 문제가 큰 문제와 동일한 구조를 가져 큰 문제의 답을 구할 시 작은 문제의 결과를 기억한 후 그대로 사용하여 수행 속도를 빠르게 한다는 것이다.

완전 탐색은 크고 작은 문제의 구조가 다를 수 있고, 이전 결과를 반드시 기억하는 것이 아니라 해결 가능한 방법을 모두 탐색한다는 차이가 있다.

### 4. 비트 마스크

2진수 표현 기법 활용 방법으로 정수의 이진수 표현을 자료구조로 쓰는 기법이다.

**장점**
1. 수행 시간이 빠르다.
	- bit 연산이기 때문에 O(1)에 구현되는 것이 많다. 따라서 다른 자료구조를 사용하는 것보다 훨씬 빠르게 동작한다.

2. 코드가 짧다.
	- 다양한 집합 연산들을 비트연산자 한 줄로 작성할 수 있기 때문에 반복문, 조건문을 이용한 코드보다 훨씬 간결하다.

3. 메모리 사용량이 적다.
	- 비트마스크를 이용하는 가장 큰 이유이다.
	- 예를 들어 bit가 10개인 경우 2^10 가지 경우를 10bit 이진수 하나로 표현 가능하다.
	- 하나의 정수로 매우 많은 경우의 수를 표현할 수 있기 때문에 메모리 측면에서 효율적이다.
	- 많은 데이터를 미리 계산해서 저장해 둘 수 있는 장점이 있다. (DP에 매우 유용)

비트마스크를 이용하기 위해서, 정수 변수를 비트 별로 조작할 수 있는 비트연산자를 사용한다. 두 정수 변수 또는 하나의 정수 변수를 이용하여 새로운 값을 만들어 내는 것이 목적이다. 

#### AND 연산

두 정수 변수 a와 b를 통해서 c를 생성한다고 가정하면, a와 b를 한 bit씩 비교하면서 해당 비트가 **둘 다 켜져 있는 경우**에만 c의 해당 비트를 켠다.

C에서 제공하는 연산자 기호는 ' & '이다.

(ex. c = a & b)

#### OR 연산

AND 연산과 같은 방식으로, 해당 비트가 **둘 중 하나라도 켜져 있는 경우**에 c의 해당 비트를 켠다.

C에서 제공하는 연산자 기호는 ' |  (shift + \) ' 이다.

(ex. c = a | b)

#### XOR 연산

마찬가지로 같은 방식이며, 해당 비트가 **둘 중 하나만 켜져 있는 경우**에 c의 해당 비트를 켠다.

C에서 제공하는 연산자 기호는 ' ^ ' 이다.

(ex. c = a ^ b)

#### NOT 연산

정수 하나를 입력받아서 **켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과**를 반환한다.

C에서 제공하는 연산자 기호는 ' ~ ' 이다.

(ex. c = ~a)

#### 시프트(shift) 연산

시프트 연산자는 정수 a의 **비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다**. 움직이고 나서 빈자리는 0으로 채워지게 된다. 예를 들어 13 (1101)을 오른쪽으로 1bit 움직인다고 하면, 6 (0110)이 되는 것이다. 

C에서 제공하는 연산자 기호는 ' << ' 또는 ' >> ' 이다.

(ex. c = (a << 1) )

### 5. BFS, DFS 


## 깊이 우선 탐색 (DFS Depth First Search)

깊이 우선 탐색은 그래프 완전 탐색 기법 중 하나이다. 그래프의 시작 노드에서 출발하여 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘이다.

- 기능 : 그래프 완전 탐색
- 특징 : 재귀 함수로 구현, 스택 자료구조 이용
- 시간 복잡도 : O(V + E) (V : 노드 수, E : 엣지 수)

### DFS 핵심 이론

DFS는 한 번 방문한 노드를 다시 방문하면 안되므로 노드 방문 여부를 체크할 배열이 필요하다.

그래프는 인접 리스트로 표현한다.

DFS의 탐색 방식은 후입선출 특성을 가지므로 스택, 재귀 함수를 사용한다.

DFS 구현은 스택보다는 스택 성질을 갖는 재귀 함수로 많이 구현한다.


#### 1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기

DFS를 위해 필요한 초기 작업은 인접 리스트로 그래프 표현하기, 방문 배열 초기화, 시작 노드 스택에 삽입하기다.

스택에 시작 노드를 1로 삽입할 때, 해당 위치의 방문 배열을 체크하면 `T, F, F, F, F, F`

![[Pasted image 20230822223733.png]]
#### 2. 스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기

pop을 수행하여 노드를 꺼낸다. 꺼낸 노드를 탐색 순서에 기입하고, 인접 리스트의 인접 노드를 스택에 삽입하며 방문 배열을 체크한다.

![[Pasted image 20230822224306.png]]

#### 3. 스택 자료구조에 값이 없을 때까지 반복

위 과정을 스택 자료구조에 값이 없을 때까지 반복한다. 이때, 이미 다녀간 노드는 방문 배열을 바탕으로 재삽입하지 않는 것이 핵심이다.

![[Pasted image 20230822224610.png]]


> 스택에 노드를 삽입할 때 방문 배열을 체크하고, 스택에서 노드를 뺄 때 탐색 순선에 기록하며 인접 노드를 방문 배열과 대조한다.

---

## 너비 우선 탐색 (BFS Breadth First Search)

너비 우선 탐색도 그래프를 완전 탐색하는 방법 중 하나로, 시작 노드에서 출발하여 시작 노드를 기준으로 `가장 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘`이다.

- 기능  
	- 그래프 완전 탐색
- 특징
	- FIFO 탐색
	- Queue 자료구조 이용
- 시간 복잡도 (노드 수 : V, 엣지 수 : E)
	- O(V + E)


너비 우선 탐색은 선입선출 방식으로 탐색하므로 큐를 이용해 구현한다. 또한, 너비 우선 탐색은 탐색 시작 노드와 가까운 노드를 우선으로 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때, 최단 경로를 보장한다. 


### BFS 핵심 이론

#### 1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화

BFS도 DFS와 마찬가지로 방문했던 노드는 다시 방문하지 않으므로 방문한 노드를 체크하기 위한 배열이 필요하다. 그래프를 인접 리스트로 표현하는 것도 DFS와 동일하다. 하지만 BFS는 탐색을 위해 스택이 아닌 큐를 사용한다.

![[Pasted image 20230826161348.png]]

#### 2. 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입

큐에서 노드를 꺼내면서 인접 노드를 큐에 삽입한다. 이때 방문 배열을 체크하여 방문한 노드는 큐에 삽입하지 않는다. 또한 큐에서 꺼낸 노드는 탐색 순서에 기록한다.

![[Pasted image 20230826161552.png]]


#### 3. 큐 자료구조에 값이 없을 때까지 반복

큐에 노드가 없을 때까지 앞선 과정을 반복한다.

![[Pasted image 20230826161746.png]]

