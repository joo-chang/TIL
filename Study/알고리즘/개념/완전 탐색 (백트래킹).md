## 백트래킹

> 백트래킹 (Backtracking) : 해를 찾는 도중 지금 경로가 해가 될 것 같지 않으면 그 경로를 더 이상 탐색하지 않고 되돌아가서 다시 해를 찾는 기법을 말한다.

일반적으로 불필요한 경로를 조기에 차단할 수 있게되어 경우의 수가 줄어들지만, N! 경우의 수를 가진 문제에서 최악의 경우 여전히 지수함수 시간을 필요로 하기 때문에 처리가 불가능할 수도 있다.

백트래킹은 가지치기를 얼마나 잘하느냐에 따라 효율성이 결정된다.

주로 문제 풀이에서는 DFS 등으로 모든 경우의 수를 탐색하는 과정에서 조건문 등을 걸어 답이 절대로 될 수 없는 상황을 정의하고, 그러한 상황일 경우 탐색을 중지하고 이전으로 돌아가 다시 다른 경우를 탐색하게 구현한다.

## 예시

자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

### 설명

백트래킹 알고리즘을 구현하기 위해 다음과 같은 데이터 구조와 변수가 필요하다.

sequence : 선택한 수열을 저장하는 배열
visited : 방문 여부를 저장하는 배열
N, M : 문제에서 주어지는 자연수 범위

백트래킹 알고리즘 핵심 아이디어는 다음과 같다.

1. 수열의 길이가 M에 도달하면 선택한 수열을 출력한다.
2. 현재 선택한 숫자보다 큰 숫자들 중, 방문하지 않은 숫자를 선택하여 수열에 추가한다.
3. 재귀적으로 다음 숫자를 선택하고, 선택한 숫자를 방문했음을 표시한다.
4. 재귀 호출이 끝나면 선택한 숫자를 방문하지 않은 상태로 변경하고 수열에서 제거한다.

```java
public void backtracking(int[] sequence, boolean[] visited, int N, int M, int depth){
	// 종료 조건 : 수열의 길이가 M에 도달하면 출력
	if(depth == M){
		for(int num : sequence){
			System.out.print(num + " ");
		}
		System.out.println();
		return;
	}
	for(int i = 1; i <= N; i++){
		// 선택한 숫자보다 큰 숫자 중에서 방문하지 않은 숫자 선택
		if(!visited[i] && (depth == 0 || sequence[depth - 1] < i)){
			sequence[depth] = i; // 수열에 추가
			visitied[i] = true;
			backtracking(sequence, visited, N, M, depth + 1); // 다음 숫자 선택
			visited[i] = false; // 방문 상태 초기화
		}
	}
}
```