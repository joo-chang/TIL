## *"데이터베이스란 무엇인가요?"*

> 데이터베이스는 데이터의 집합을 의미합니다. 데이터를 효율적으로 저장하고 관리하며 쉽게 검색하고 사용할 수 있도록 하는 시스템입니다.
---

## *"DBMS란 무엇인가요?"*

> DBMS는 데이터베이스를 생성, 관리, 조작할 수 있는 소프트웨어입니다. DBMS는 데이터의 저장, 검색, 업데이트, 삭제 등을 효율적으로 수행할 수 있게하며, 데이터의 모결성, 일관성, 보안성을 보장합니다. 주요 기능으로는 데이터 정의, 조작, 제어 등이 있습니다.

---

## *"DBMS 기능 (DDL, DML, DCL)에 대해 설명해주세요."*

> DBMS 기능은 데이터 정의어, 조작어, 제어어로 나뉩니다. 정의어는 데이터베이스가 어떤 용도로 사용될 것인지에 대해 정의하는 기능입니다. CREATE, ALTER, DROP 과 같은 명령어가 있습니다. 조작어는 DB에 저장된 데이터를 삽입, 삭제, 갱신, 검색 등을 하기 위한 기능입니다. INSERT, DELETE, UPDATE, SELECT 가 있습니다. 제어어는 DB에 접근하고 사용할 수 있도록 권한을 부여하고 해제하는 기능입니다. GRANT, REVOKE 가 있습니다.

---

## *"DB 스키마에 대해 설명해주세요."*

> 스키마는 **DB의 구조적인 틀과 제약 조건에 대해 정의한 것**입니다. DB 스키마는 데이터베이스 설계의 중요한 부분으로, **데이터의 무결성, 일관성, 보안성을 유지하는 데 중요한 역할**을 합니다. 스키마를 통해 **데이터의 구조를 미리 정의함으로써** 데이터베이스 운영 중 발생할 수 있는 **오류를 줄이고, 효율적인 데이터 관리**를 가능하게 합니다.
> 
> 스키마는 보통 세가지 수준으로 나누는데 **외부 스키마**는 사용자나 응용 프로그램의 관점에서의 데이터 구조를 나타내고, **개념 스키마**는 데이터베이스의 전체적인 구조를 정의하며, **내부 스키마**는 데이터가 실제로 저장되는 방식을 정의합니다.

---

## *"DELETE, TRUNCATE, DROP 차이를 설명해주세요."*

> DELETE, TRUNCATE, DROP 모두 삭제 관련된 명령어입니다.
> DELETE는 행 일부 또는 전체 데이터를 지울 수 있는데, 지워진 데이터 저장 공간은 남아있고 재사용합니다.
> TRUNCATE는 전체 데이터를 지우고 저장 공간과 인덱스 모두 삭제됩니다. 쉽게 말해 테이블 생성 초기 단계로 돌아 갑니다.
> DROP은 테이블 전체를 삭제하는 명령어입니다.

---

## *"PL/SQL이 무엇인가요?"*

> PL/SQL은 SQL을 확장한 프로시저 언어로 절차형 언어입니다. 종류는 Procedure, Funciton, Trigger가 있습니다.

---

## *"Function, Procedure, Trigger 에 대해 설명해 주세요."*

> - Function : 사용자가 정의한 함수로, DBMS에 저장하여 사용하는 함수입니다. SQL 내부에서 사용 가능합니다.
> - Procedure : DB에 정의된 일련의 SQL들을 묶어 놓은 저장 프로그램입니다. 쿼리문을 하나의 메서드 형식으로 만들고 어떠한 동작을 일괄적으로 처리하기 위해 사용합니다.
>   Procedure의 장점은 네트워크 트래픽을 줄여 응답 속도를 향상시킬 수 있고, 여러 서비스에서 재사용이 가능합니다. 단점은 트래픽이 증가할 경우 DB서버에 부하가 발생 할 수 있고, DB 내부에서 실행되기 때문에 디버깅이 어렵습니다.
> - Trigger : DB에서 특정 이벤트가 발생했을 때 자동으로 실행되도록 구현된 프로그램입니다. 특정 테이블에 대한 변경을 시작으로 관련된 작업을 자동적으로 수행하기 위해 트리거를 사용합니다. 트리거는 DB단에서 자동으로 실행되기 때문에 동작을 인지하기가 어렵고, 트리거의 흐름을 파악하기가 어렵다는 단점이 있습니다.

---

## *"트랜잭션에 대해 설명해주세요."*

> 트랜잭션은 단일한 논리적인 작업 단위를 말합니다. 여러 SQL문들을 단일 작업으로 묶어서 나눠질 수 없게 만든 것입니다.
> 트랜잭션은 4가지 특성이 있습니다. 원자성, 일관성, 격리성, 영속성
> - 원자성은 All or Noting 모두 성공하거나 되돌아가거나 둘 중 하나를 만족해야 합니다.
> - 일관성은 정의된 제약조건을 위반해서는 안됩니다.
> - 격리성은 작업 수행 중 다른 트랜잭션이 끼어들지 못하도록 보장합니다.
> - 영속성은 성공적으로 수행된 트랜잭션은 영구적으로 반영돼야 합니다.

---

## *"동시성 제어에 대해 설명해주세요."*

> 동시성 제어란 트랜잭션이 동시에 수행될 때 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 말합니다.
> 동시성 제어의 목적은 데이터베이스의 일관성 유지, 사용자 응답 시간 최소화, 단위 시간당 트랜잭션 처리 건수 최대화하는 것입니다.
> 동시성 제어 기법은 Locking, Two-Phase Locking(2PL), 타임스탬프 순서, 다중 버전 동시성 제어(MVCC) 가 있습니다.
> - Locking : 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 lock하는 동시성 제어 기법입니다. 필드, 레코드, 테이블, DB 모두 로킹 단위가 될 수 있습니다. 로킹 단위가 클수록 동시성 제어가 단순해지고 관리가 편하지만 병행 수준이 낮아집니다. 작을 수록 동시성 제어가 복잡해지고 오버헤드가 증가하지만, 병행 수준이 높아집니다.
> - Two-Phase Locking(2PL) : 각 트랜잭션의 lock과 unlock 요청을 2단계로 실시하는 방식입니다. 각 트랜잭션이 확장 단계와 축소 단계로 나뉘는데 확장 단계에서는 lock 연산만 할 수 있고, 축소 단계에서는 unlock만 수행할 수 있습니다. 하나의 트랜잭션에서 데이터에 대한 연산을 완전히 끝낸 후 unlock하므로 직렬성이 보장됩니다.
> - 타임스탬프 순서 기법 : 타임스탬프 순서에 따라 직렬화 시키는 방법입니다.
> - 다중 버전 동시성 제어 : 한 데이터에 대해 여러 버전의 값을 유지하며 관리하는 방식입니다. 트랜잭션이 데이터를 읽거나 쓸 때 발생하는 로킹을 최소화하여 동시성을 향상시키는 데 사용됩니다.
>   DB에서 데이터를 수정할 때 새로운 버전을 생성하고, 수정 전의 버전은 유지됩니다. 이렇게 하면 동시에 여러 트랜잭션이 데이터를 읽고 쓸 수 있으며, 각 트랜잭션은 일관된 데이터 상태를 볼 수 있습니다.

---

## *"Isolation Level에 대해 설명해주세요."*

> 격리 수준은 데이터베이스 트랜잭션에서 일관성을 유지하기 위해 트랜잭션 간의 상호작용을 제어하는 방법입니다. 트랜잭션이 서로에게 미치는 영향을 최소화하여 데이터 무결성을 유지합니다.
> 
> 주요 Isolation Level은 Read Uncommitted, Read Committed, Repeatable Read, Serializable 이 있습니다.
> 
> - Read Uncommitted는 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있습니다.
> - Read Committed는 트랜잭션이 커밋된 데이터만 읽을 수 있습니다.
> - Repeatable Read는 트랜잭션이 시작된 이후부터 다른 트랜잭션이 수정한 데이터를 읽을 수 없습니다. 그래서 트랜잭션 동안 읽은 데이터가 일관성을 유지합니다.
> - Serializable은 가장 높은 수준의 격리입니다. 트랜잭션이 겹치지 않도록 완전히 직렬화하여 실행됩니다. 데이터 일관성이 가장 높지만 성능은 가장 낮습니다.
> 
> isolation level 마다 발생할 수 있는 문제가 있습니다. Dirty Read, Non-Repeatable Read, Phanthom Read
> - Dirty Read는 트랜잭션 A가 아직 커밋되지 않은 데이터를 트랜잭션 B가 읽는 경우 생기는 문제입니다. Read Committed 이상 격리 수준을 사용하여 해결한다.
> - Non-Repeatable Read는 트랜잭션 A가 동일한 쿼리를 두번 실행할 때, 트랜잭션 B가 데이터를 수정하여 두 쿼리 결과가 다른 경우입니다. Repeatable Read 이상 격리 수준을 사용합니다.
> - Phantom Read는 트랜잭션 A가 범위 쿼리를 실행항 후, 트랜잭션 B가 새로운 행을 추가하여 트랜잭션 A가 동일한 범위 쿼리를 다시 실행했을 때 결과가 다른 경우입니다. Serializable 걱리 수준으로 해결 가능합니다.


---

## *"무결성과 무결성 제약 조건에 대해 설명해주세요."*

> 무결성이란 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말합니다. 즉, 데이터에 결점이 없도록 유지하는 성질입니다.

1. 기본 키 제약조건 (Primary Key Constraint)
- **설명**: 테이블에서 각 행을 고유하게 식별하는 컬럼.
- **특징**: 기본 키 컬럼은 중복 값을 가질 수 없으며, NULL 값을 허용하지 않습니다.

2. 외래 키 제약조건 (Foreign Key Constraint)
- **설명**: 한 테이블의 컬럼이 다른 테이블의 기본 키를 참조.
- **특징**: 외래 키는 참조 무결성을 유지하며, 외래 키 컬럼의 값은 참조되는 테이블의 기본 키에 존재해야 합니다.

3. 고유 제약조건 (Unique Constraint)
- **설명**: 특정 컬럼이나 컬럼 조합의 값이 테이블 내에서 중복되지 않도록 보장.
- **특징**: 고유 제약조건이 적용된 컬럼은 중복 값을 가질 수 없지만, NULL 값은 허용됩니다.

4. 체크 제약조건 (Check Constraint)
- **설명**: 컬럼의 값이 특정 조건을 만족하는지 검증.
- **특징**: 데이터 삽입 또는 업데이트 시 조건을 확인하여 유효하지 않은 데이터가 입력되는 것을 방지합니다.
- **예시**: `CHECK (salary > 0)` - 급여가 0보다 큰 값을 가져야 합니다.

5. 널 제약조건 (Not Null Constraint)
- **설명**: 컬럼에 NULL 값을 허용하지 않도록 설정.
- **특징**: 특정 컬럼에 항상 유효한 값이 입력되도록 보장합니다.

6. 기본값 제약조건 (Default Constraint)
- **설명**: 컬럼에 값이 명시되지 않았을 때 기본값을 설정.
- **특징**: 특정 컬럼에 기본값을 지정하여 데이터 입력의 편의성을 제공합니다.

---
## *"이상 현상에 대해 설명해주세요."*

> 이상현상은 삽입, 삭제, 갱신 이상이 있습니다.
> 삽입 이상은 삽입할 때 불필요한 데이터지 삽입해야 테이블에 추가가 가능한 현상입니다.
> 갱신 이상은 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상입니다.
> 삭제 이상은 어떤 정보를 삭제하면 다른 정보까지 삭제되버리는 현상입니다.

---

## *"데이터베이스의 '정규화(Normalization)'에 대해 설명해 주세요. 정규화를 수행하는 주된 목적과, 정규화 과정에서 일반적으로 따르는 단계들에 대해서도 간단히 설명해 주세요."*

> 데이터베이스 정규화는 데이터의 중복을 줄이고, 데이터 무결성을 향상시키기 위한 과정입니다. 정규화의 주된 목적은 데이터베이스 설계를 개선하여, 업데이트, 삽입, 삭제 등의 연산 시 발생할 수 있는 여러 문제점들을 예방하는 것입니다. 이 과정은 데이터의 일관성과 정확성을 유지하며, 저장 공간을 효율적으로 사용하도록 돕습니다.

1. **제1정규형(1NF):** 각 컬럼의 값이 원자값(더 이상 분해할 수 없는 값)을 가지도록 테이블을 구성합니다. 즉, 각 필드는 반복되는 그룹이나 배열을 포함할 수 없습니다.    
2. **제2정규형(2NF):** 1NF를 만족하며, 모든 비주요 속성이 기본 키에 완전 함수적으로 종속되어야 합니다. 이는 부분적 종속성을 제거하여, 테이블을 분해함으로써 달성할 수 있습니다.
3. **제3정규형(3NF):** 2NF를 만족하고, 모든 비주요 속성이 기본 키에만 종속되어야 합니다. 즉, 이행적 종속성을 제거해야 합니다.
4. **보이스-코드 정규형(BCNF):** 3NF를 만족하며, 모든 결정자가 후보 키가 되어야 합니다. 이는 더 엄격한 요구 사항을 적용하여, 어떤 종류의 논리적 오류도 제거합니다.

> 이후에도 제4정규형(4NF)과 제5정규형(5NF) 등이 있으며, 이는 더 복잡한 함수적 종속성과 다중 값 종속성을 다룹니다. 그러나 실제 응용에서는 대부분 3NF나 BCNF까지의 정규화를 수행합니다. 정규화는 데이터베이스의 성능과 유지보수성을 개선하는 데 중요한 역할을 하지만, 때로는 성능 향상을 위해 의도적으로 비정규화를 수행하기도 합니다.

---
## *"역 정규화에 대해 설명해주세요."*

> 정규화를 마친 논리적 테이블을 개발적 측면에서 성능이나 편의성을 위해 되돌아하는 작업을 말합니다. 역정규화의 목적은 DB성능 향상을 위해 조인 연산 수를 줄이고, 조회 시간을 단축하는 것입니다.
> 역정규화 방법은 정규화된 여러 테이블을 통합한다거나, 중복 데이터를 추가하여 원하는 데이터에 빠르게 접근할 수 있도록 하거나, 자주 요구되는 집계 데이터를 미리 계산해 저장하는 방법이 있습니다.

