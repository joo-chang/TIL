## MSA와 모놀리식 아키텍처 차이점

> 모놀리식 아키텍처는 모든 기능을 하나의 단일 애플리케이션으로 통합하여 초기 개발과 배포가 간단하지만, 애플리케이션이 커질수록 **유지보수와 확장**이 어려워진다.
> 반면, MSA는 애플리케이션을 독립적인 여러 서비스로 분할하여 개발, 배포, 확장이 용이하여 유연성을 높인다. MSA는 대규모 시스템에 적합하지만, 서비스 간 통신과 관리의 복잡성이 증가할 수 있다.

## 대기열 기능을 구현할 때 가장 중요하게 생각해야 하는 부분

> 대기열 기능을 구현할 때 가장 중요한 요소는 **동시성 및 스레드 안전성**을 확보하여 다수의 사용자나 프로세스가 동시에 접근하더라도 데이터의 일관성과 무결성이 유지되도록 하는 것이다. 또한, **확장성과 성능**을 고려하여 대기열의 처리 속도와 용량을 효과적으로 관리해야 하며, **데이터의 지속성**을 보장하여 시스템 장애 발생 시에도 대기열 데이터가 손실되지 않도록 해야 한다. 마지막으로, **FIFO(First-In-First-Out) 원칙**을 철저히 준수하여 데이터의 순서가 올바르게 유지되도록 하는 것이 중요하다.

## 경쟁 상태와 교착 상태 

> 경쟁 상태와 교착 상태 모두 동시성 환경에서 발생할 수 있는 심각한 문제로, 시스템의 안정성과 효율성에 큰 영향을 미친다. 경쟁 상태는 자원 접근의 타이밍 문제로 인한 불일치 결과를 초래하며, 교착 상태는 시스템이 무한 대기 상태에 빠져 전체적인 동작을 멈추게 한다.
> 이를 방지하기 위해 적절한 동기화 매커니즘을 도입하고, 자원 관리 전략을 신중히 설계하는 것이 필수적이다.

## 인덱스란? 복합 인덱스와 커버링 인덱스

> 인덱스란 테이블 내의 데이터를 효율적으로 검색하기 위해 사용하는 자료구조이다. 
> 기본적으로 인덱스는 데이터의 정렬된 복사본을 유지함으로써, 검색 속도를 대폭 향상시킨다. 주로 B-Tree나 Hash 구조를 사용하여 구현되며, DBMS에서 자동으로 관리된다.
> 
> 복합 인덱스는 두 개 이상의 열을 조합하여 하나의 인덱스를 생성한 것이다. 단일 열의 대한 인덱스 보다 다중 조건 검색 시 더욱 효율적인 성능을 제공한다. 주로 WHERE 절에 여러 열이 사용되는 쿼리에서 유용하다.
> 
> 커버링 인덱스는 특정 쿼리에 필요한 **모든** 열을 포함하는 인덱스를 말한다. 이 경우, DBMS는 인덱스 자체에서 모든 데이터를 조회할 수 있으므로, 실제 테이블에 접근하지 않고도 쿼리를 완료할 수 있어 성능이 크게 향상된다. 주로 SELECT 절에 포함된 열들이 WHERE 절이나 JOIN 절에 사용되는 열들과 일치할 때 유용하다.
> 
> 인덱스는 저장 공간과 쓰기 성능에 영향을 미치므로, 적절한 인덱스 전략을 수립하는 것이 중요하다.

## N+1 문제가 발생하는 이유

> N+1 문제는 연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 개수(N)만큼 연관 관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 되는 문제이다. 부적절한 로딩 전략 사용, 쿼리 최적화 부족, 캐싱 전략 미흡 등이 주요 원인이다. 이러한 요인들은 DB 접근 횟수를 과도하게 증가시켜 시스템 성능을 저하시킨다. 따라서, 적절한 페치 전략 선택과 쿼리 최적화를 통해 방지하는 것이 중요하다.

## MSA 트랜잭션 전략

> MSA는 독립적인 서비스들로 시스템을 분할함으로써 확장성과 유연성을 제공하지만, 이로 인해 트랜잭션 관리가 복잡해지는 문제가 발생한다. 모놀리식 아키텍처에서는 단일 DB내에서 ACID 트랜잭션을 쉽게 구현할 수 있으나, MSA에서는 각 서비스가 독립적인 DB를 사용하기 때문에 분산 트랜잭션을 효과적으로 관리하기 위한 전략이 필요하다.
> 
> 사가 패턴 도입 : 분산 트랜잭션을 관리하기 위한 대표적인 방법으로, 여러 서비스에 걸친 일련의 로컬 트랜잭션을 순차적으로 실핼하고, 트랜잭션이 실패할 경우 보상 트랜잭션을 수행하는 방식이다. 이를 통해 트랜잭션의 일관성을 유지할 수 있다.
> 
> 이벤트 기반 아키텍처 활용 : 서비스간 통신을 이벤트를 통해 비동기적으로 처리함으로써 트랜잭션 관리를 단순화한다.
> 
> 최종 일관성 구현 : MSA에서는 강력한 일관성보다는 최종 일관성을 목표로 하는 경우가 많다. 일시적으로 데이터 불일치를 허용하더라도, 시간이 지남에 따라 일관된 상태로 수렴하도록 설계하는 것이다. 이벤트 소싱과 CQRS 방법이 있다.
> 
> 분산 트랜잭션 관리 도구 활용 : MSA 에서 분산 트랜잭션을 관리하기 위한 도구와 프레임워크를 활용할 수 있다.
> Apache Kafka : 이벤트 스트리밍 플랫폼으로 이벤트 기반 트랜잭션 관리.
> Axon Framework : 사가 패턴과 이벤트 소싱을 지원하는 프레임워크
> 
> 모니터링 및 장애 복구 전략 수립 : 모니터링과 장애 복구 전략을 통해 트랜잭션의 상태를 실시간으로 파악하고, 대응할 수 있다. 트랜잭션 실패 시 자동으로 보상 트랜잭션을 실행하거나, 재시도를 통해 시스템의 일관성을 유지하는 방안을 마련한다.
> 
> MSA 에서의 트랜잭션 관리는 분산된 서비스 간의 일관성을 유지하는 데 중요한 역할을 한다. 사가 패턴, 이벤트 기반 아키텍처, 최종 일관성 구현, 분산 트랜잭션 관리 도구의 활용, 그리고 철저한 모니터링 및 장애 복구 전략을 통해 효과적인 트랜잭션 관리를 수립할 수 있다. 이러한 전략들을 종합적으로 적용함으로써, MSA 환경에서도 안정적이고 일관성 있는 데이터 관리를 실현할 수 있다.

## Config Server 사용 이유

> MSA에서 Config Server를 사용하면 설정 정보를 중앙 집중식으로 관리하고, 서비스별 재배포 없이도 설정 변경을 유연하게 적용할 수 있으며, 환경별 설정 관리와 민감 정보 보안 측면에서도 뛰어난 이점을 제공한다.

## MSA에서 Message Bus 서비스가 다운되는 경우 조치 방법

> Kafka 다운 상황에서의 대응은 사전적 대비(멀티 브로커, 레플리카, 모니터링, Chaos Engineering), 실시간 복구 방안(자동 Failover, Fallback 큐), 메시지 정합성을 유지하는 전략(Idempotent Producer, Exactly Once Delivery), 그리고 장애 전파를 방지하기 위한 Circuit Breaker나 Backpressure 등의 패턴 활용이 필수적이다.

[[MSA에서 Message Bus가 Down 될 경우 조치 사항]]

## Bean과 IoC, DI

> Spring에서 Bean은 스프링 프레임워크에서 관리되는 객체를 의미한다. 스프링 컨테이너에 의해 생성되고, 생명주기를 관리받는 모든 객체는 Bean으로 간주된다.
> 
> Inversion of Control(IoC)는 제어의 역전으로 객체의 생성과 의존성 관리를 개발자가 아닌 외부 컨테이너가 담당하도록 하는 개념이다. 이를 통해 객체 간의 결합도를 낮추고, 코드의 재사용성과 유연성을 향상 시킬 수 있다.
> 
> DI는 의존성 주입을 의미한다. 객체간의 의존 관계를 미리 선언해 두면 스프링 컨테이너가 의존 관계를 자동으로 연결해준다.
> 이렇게 되면 직접 객체를 생성하거나 검색해서 가져올 필요가 없어서 결합도가 낮아지는 장점이 있다.

## DispatcherServlet

> DispatcherServlet은 스프링 MVC의 핵심 구성 요소로, 모든 HTTP 요청을 가로채 적절한 컨트롤러로 전달하고, 최종적으로 응답을 반환하는 역할을 한다. 애플리케이션의 요청 처리를 중앙 집중화하여 일관된 요청 흐름을 유지할 수 있게한다.
> 

## Filter, Interceptor, AOP

> 웹 애플리케이션 개발 시, 공통적인 기능을 효율적으로 구현하고, 코드의 중복을 최소화하기 위해 Filter, Interceptor, AOP가 자주 사용된다. 각각의 목적과 사용 방식이 다르지만, 공통적으로 애플리케이션의 특정 지점을 가로채 추가적인 로직을 수행하는 역할을 한다.
> 
> Filter는 서블릿 스펙의 일부로, 클라이언트의 요청과 서블릿의 응답을 가로채 전처리 및 후처리를 수행하는 컴포넌트이다. 주로 인증, 로깅, 캐싱 등의 공통 기능을 구현하는데 사용된다.
> 서블릿 컨테이너에 의해 관리되며, 서블릿 요청과 응답을 직접 다룬다. Fileter Chain을 통해 여러 Filter를 순차적으로 적용할 수 있다. 특정 프레임워크에 종속되지 않고, 자바 EE 환경에서 독립적으로 동작한다.
> 
> Interceptor는 주로 스프링 프레임워크에서 사용되는 개념으로, 요청이 컨트롤러에 도달하기 전후에 특정 로직을 수행할 수 있게 해주는 컴포넌트이다. Filter와 유사하지만, 스프링 MVC의 핸들러 매핑 및 모델과 더 밀접하게 통합되어 있다.
> 특징은 스프링 MVC의 요청 처리 과정에 통합되어 동작한다. 컨트롤러 핸들러 메서드 실행 전후에 로직을 삽입할 수 있다. 스프링 컨테이너에 의해 관리되며, 의존성 주입이 가능하다.
> 
> AOP(Aspect-Oriented Programming)는 관점 지향 프로그래밍이라고 불린다. 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것이다. 다양한 애플리케이션 로직에 적용 가능하고, 공통 관심사를 모듈화하여 재사용 가능하다.



Spring Boot의 DispatcherServlet에 대해서 설명해주세요. 

트랜잭션이란 무엇이고 ACID 특징에 대해서 설명해주세요. 
JWT란 무엇이고 어떻게 동작하는가? 
VM과 컨테이너의 차이점에 대해서 아는가? 
TCP/UDP에 대해서 설명해주세요. 
Redis란 무엇이고, Pub/Sub구조에 대해서 설명해주세요. 
ORM이란 무엇이고 왜 태어났는가? 
Blue/Green 배포란? 
JVM 메모리 부족 이슈가 발생했을 경우, 어떤 부분을 확인해야 하며, 해결방법은 어떤 방법들이 있는지 설명해주세요.