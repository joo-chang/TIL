## *"자바에 대해 설명해 주세요."*

> 자바는 객체 지향 언어로 개발된 프로그래밍 언어입니다.
> 자바는 JVM에서 동작하기 때문에 운영체제에 독립적이고, 캡슐화, 상속, 추상화, 다형성 등을 지원하여 객체지향 프로그래밍이 가능합니다. 또한 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 생성하는 동적 로딩을 지원합니다.

---
## *"객체 지향 프로그래밍(OOP)에 대해 설명해 주세요."*

> 객체지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 객체들 간의 상호작용을 통해 프로그램을 만드는 것 을 말합니다.
> 객체 지향 프로그래밍의 핵심은 객체를 기능 구현을 위한 공동체로 인지하고, 이에 참여하는 객체들에 적절한 역할과 책임을 부여하는 것입니다.

---
## *"객체 지향 프로그래밍의 장, 단점을 간단하게 설명해 주세요."*

> 객체 지향 프로그래밍의 장점은 1. 코드 재사용이 용이하고, 2. 코드 수정 시 각각 객체들이 독립적인 역할을 하기 때문에 수정할 부분이 내부에 존재하므로 유지보수가 쉽고 빠릅니다. 
> 반면에 단점은 1. 처리 속도가 상대적으로 느리고, 2. 객체가 많아지면 용량이 커질 수 있습니다. 3. 또한, 설계 시 많은 시간과 노력이 필요합니다.

---
## *"클래스와 인스턴스(객체)는 무엇인지 설명해 주세요."*

> 클래스는 객체를 생성하기 위한 일종의 설계도라고 할 수 있고, 속성과 행위를 변수와 메소드로 정의한 것입니다.
> 인스턴스는 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것을 말합니다.

---
## *"객체 지향 프로그래밍의 특징에 대해 각각 설명해 주세요."*

> 추상화, 캡슐화, 상속, 다형성이 있는데 우선 
> **추상화**는 사물들의 공통적인 특징을 파악해서 하나의 집합으로 다루는 것을 의미합니다. 쉽게 말해 필요한 부분만 표현하기 위한 개념입니다. 
> **캡슐화**는 캡슐화는 데이터와 메서드를 하나의 단위로 묶는 개념으로, 객체의 상태를 외부로부터 은닉하고 안전한 접근을 제공합니다. 
> **상속**은 상위 객체의 책임과 역할을 하위 객체에서 추가적으로 구현할 수 있도록 도와주는 개념입니다. 
> **다형성**은 같은 이름의 메서드나 연산자가 다른 클래스에서 다르게 동작할 수 있도록하는 것을 의미합니다.

---
## *"인터페이스와 추상 클래스의 차이점은 무엇이며, 각각 언제 사용하는 것이 적절한지 예시를 들어주세요."*

> 인터페이스는 모든 메서드가 기본적으로 추상 메서드이고, 다중 상속이 가능하며, 공통 기능을 제공해야 하는 경우 사용합니다. 예를 들어 'Drawable' 인터페이스로 '그리다' 메서드를 제공해야 하고, 상속 받아 '원', '사각형' 등의 클래스를 구현할 수 있습니다.
> 추상 클래스는 일부 메서드에 공통적인 기능을 제공하면서 나머지는 상속받는 서브 클래스에서 구현하도록 하는 경우에 사용됩니다. 예를 들어 '동물' 추상 클래스는 '먹다', '움직이다' 와 같은 공통 메서드를 제공하고, '울다' 메서드는 강아지, 고양이 같은 서브 클래스에서 구체적으로 구현할 수 있습니다.

---
## *"Java에서 예외 처리의 중요성에 대해 설명하고, try-catch와 finally 블록을 사용하는 예시를 들어주세요."*

> Java에서 예외 처리는 프로그램의 안정성을 보장하고, 예상치 못한 상황에서도 사용자에게 적절한 피드백을 제공하기 위해 중요합니다. 적절한 예외 처리 로직을 통해 사용자에게 이해하기 쉬운 응답을 제공하고, 필요한 복구 조치를 취할 수 있습니다.
> try-catch를 이용하면 예외가 발생했을 때 해당 catch 블록으로 이동하여 예외를 처리합니다.

```java
try {
    // 데이터베이스 로직 처리
} catch (SQLException e) {
    // SQL 예외 처리
} finally {
    // 데이터베이스 연결 종료 등의 공통 처리
}
```

---
## *"Java에서 멀티스레딩이 중요한 이유와, 실제로 멀티스레딩을 구현할 때 어떤 점을 주의해야 하는지 설명해 주세요."*

> 멀티 스레드는 동시에 여러 작업을 수행하도록 하는 컴퓨팅 개념입니다. 애플리케이션의 성능을 향상시키고, 자원을 효율적으로 사용하기 위해 중요합니다. 멀티스레딩을 통해 여러 작업을 동시에 실행할 수 있어, 대기 시간을 줄이고 CPU 사용률을 최적화할 수 있습니다. 
> 그러나 멀티스레딩을 구현할 때 여러 스레드가 동시에 하나의 자원에 접근하려고 할 때발생할 수 있는 데이터 일관성 문제, 데드락, 스레드 간 경쟁 조건 등을 주의해야 합니다.
> synchronized 키워드 사용하거나 DB 락과 같은 처리를 통해 공유 자원에 대한 동시 접근을 제어하고, 데이터의 안전성을 보장할 수 있습니다.

---
## *"Java에 추가된 기능 중 흥미롭게 생각한 것이 있으면 설명, 왜 유용하다고 생각하는지?*

> java 21 부터 가상 스레드가 정식으로 추가 되었습니다. 가상 스레드는 처리량이 많은 동시성 애플리케이션을 개발하고 유지 및 관리하는데 드는 비용을 획기적으로 줄여줄 경량 스레드입니다.
> 기존 스프링 MVC 같은 경우 멀티스레드 모델을 기본적인 동시성 처리 방법으로 사용해왔고, 이로 인해 I/O 요청이 들어오면 스레드가 블로킹되면서 자원이 낭비되곤 했습니다. 이를 위해 특정 키워드(async-await 또는 suspend 등과 같은)를 통해 논블로킹 구간을 지정해주어야 합니다.
> 하지만 자바는 이를 JVM 레벨에서 처리하도록 하였고, 따라서 개발자는 키워드를 명시해주지 않아도 JVM이 알아서 논블로킹 처리를 해주기 때문에 많은 이점을 가질 수 있습니다.

---
## *"객체지향 설계 원칙에 대해 설명해 주세요."*

> 객체 지향 설계 원칙에는 5가지가 있습니다.
> **단일 책임 원칙** : 하나의 클래스에는 하나의 책임만 가져야 합니다. (변경이 있을 때 파급 효과가 적어야 함)
> **개방-폐쇄 원칙** : 클래스는 확장에는 열려있으나 변경에는 닫혀있어야 합니다. (확장은 쉽게 구현, 수정은 최소화)
> **리스코프 치환 원칙** : 인터페이스 규약에 맞게 구현해야 합니다.
> **인터페이스 분리 원칙** : 인터페이스를 각각 사용에 맞게끔 구현해야 합니다. 
> **의존관계 역전 원칙** : 추상화(인터페이스)에 의존해야지 구체화(구현 클래스)에 의존하면 안됩니다.

---
## *"JVM에 대해 설명해 주세요."*

> JVM은 바이트 코드를 OS와 하드웨어에 특화된 코드로 변환하여 실행하는 프로그램입니다. 
> 크게 클래스 로더, 실행 엔진, 런타임 데이터 영역으로 구성되어 있습니다.
> 클래스 로더는 바이트 코드를 읽고 클래스의 정보를 런타임 데이터 영역에 배치합니다.
> 런타임 데이터 영역은 쉽게 말해 JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역입니다.
> 실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행합니다.

---
## *"자바 코드 실행 순서를 설명해 주세요."*

> 1. 자바 코드를 작성하고
> 2. javac 컴파일러를 통해 .class 바이트 코드로 변환합니다.
> 3. 컴파일된 바이트 코드를 JVM 클래스 로더에게 전달합니다.
> 4. 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩/링크하여 런타임 데이터 영역에 올립니다.
> 5. JVM 메모리에 올라온 바이트 코드를 실행 엔진에서 실행합니다.

---
## *"JVM에서 클래스 로더, 메모리, 실행 엔진에 대해 설명해 주세요."*

> 클래스 로더는 로딩 -> 링킹 -> 초기화 순서로 동작합니다.
> 로딩은 메모리의 메서드 영역에 클래스 정보를 저장하고, 링킹은 클래스 파일 검증 및 static 변수들에 해당하는 메모리를 준비하고, 초기화는 static 변수에 값을 할당하는 것을 말합니다.

> 메모리는 메서드(static), 힙, 스택 영역, PC Register, Native Method Stack 로 구성되어 있고,
> **메서드(static) 영역**은 클래스가 사용되면 해당 클래스 파일을 읽어들여 클래스에 대한 정보(바이트 코드)를 메서드 영역에 저장합니다. 클래스, 인터페이스, 메서드, 필드, static 변수, final 변수가 저장되는 영역입니다.
> **스택 영역**은 스레드마다 존재하여 스레드가 시작할 때마다 할당됩니다. 지역 변수, 매개 변수, 연산 중 발생하는 임시 데이터를 저장합니다.
> **힙 영역**은 런타임 시 동적으로 할당하여 사용하는 영역입니다. new 연산자로 생성된 객체와 배열을 저장합니다.
> **PC Register**는 JVM은 스택 기반의 가상 머신으로 CPU에 직접 접근하지 않고 Stack에서 주소를 뽑아서 PC Register에 저장됩니다.
> **Native Method Stack** 은 Java 이외의 언어에 제공되는 Method 정보가 저장되는 공간입니다.

> 실행 엔진은 바이트 코드를 한 줄씩 읽고 실행하는 인터프리터가 있고, 동적 메모리를 관리해주는 GC가 있습니다.

---
## *"GC에 대해 설명해 주세요."*

> 가비지 컬렉션은 JVM의 힙 영역의 메모리 관리 기법 중 하나로 동적으로 할당됐던 메모리 영역 중 필요 없게된 메모리 영역을 관리해주는 기법입니다.

## *"필요없어진 메모리인지 어떻게 판단하죠?"*

> 객체는 힙 영역에 저장되고, 스택 영역에 이를 가리키는 주소 값이 저장되는데, 참조 변수힙 영역에서 자신을 가리키는 주소 값이 없으면 참조되고 있지 않다고 판단합니다. 

