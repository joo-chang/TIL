## 디자인 패턴

디자인 패턴이란 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 규약 형태로 만들어 놓은 것을 의미한다.

디자인 패턴은 라이브러리나 프레임워크를 만드는 데 기초적인 원리가 된다.

### 디자인 패턴 종류

#### 생성 패턴

생성 패턴은 객체 생성 방법이 들어간 디자인 패턴이다.
- 싱글톤, 팩토리, 추상팩토리

#### 구조 패턴

구조 패턴은 객체, 클래스 등으로 큰 구조를 만들 때 유연하고 효율적으로 만드는 방법이 들어간 디자인 패턴이다.
- 프록시, 어댑터

#### 행동 패턴

객체나 클래스 간의 알고리즘, 책임 할당에 관한 디자인 패턴이다.
- 이터레이터, 옵저버, 전략

<br>

---
## 라이브러리와 프레임워크 차이

### 라이브러리

라이브러리는 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것이며 폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유롭다.

구현에 대한 선택권이나 통제권이 사용자에게 있다.

### 프레임워크

프레임워크는 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것이며 폴더명, 파일명 등에 대한 규칙이 있고, 라이브러리에 비해 엄격하다.

통제권이 사용자가 아닌 프레임워크에 있다.

<br>

---
## 싱글톤 패턴

싱글톤 패턴은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다.

인스턴스 생성에 많은 코스트가 드는 데이터베이스 연결 모듈에 많이 쓰인다.

**장점**
인스턴스가 하나이기 때문에 인스턴스를 생성 비용이 줄어든다. 그러므로 인스턴스 생성 비용이 많은 I/O 바운드 작업에 많이 사용한다.

> I/O 바운드 : 디스크 연결, 네트워크 통신, 데이터베이스 연결

**단점**
의존성이 높아지며 TDD 할 때 번거롭다.

TDD는 주로 단위 테스트를 하는데 단위 테스트는 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행할 수 있어야 한다.
하지만 싱글톤 패턴은 미리 생성된 인스턴스 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스를 만들기 어렵다.

<br>

---
## 팩토리 패턴

팩토리 패턴은 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다.

상위 클래스에서는 객체 생성 방식에 대해 알 필요가 없어져 유연성을 갖게되고 객체 생성 로직은 하위 클래스에서 관리되기 때문에 유지 보수성이 증가된다.

<br>

---
## 의존성 주입과 의존관계역전 원칙

의존성 주입 (Dependency Injection)은 메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주입해주는 것이 아닌 중간에 의존성 주입자가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식이다.

의존성 주입을 할 때 의존관계역전원칙이 적용된다.
- 상위 모듈은 하위 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안 된다. 세부 사항은 추상화에 따라 달라져야 한다.

### 의존성 주입 장점

1. 외부에서 모듈을 생성하여 집어넣는 구조이기 때문에 모듈들을 쉽게 교체할 수 있는 구조가 된다.
2. 단위 테스트와 마이그레이션이 쉬워진다.
3. 애플리케이션 의존성 방향이 좀 더 일관되어 코드를 추론하기 쉬워진다.

### 의존성 주입 단점

1. 결국 모듈이 더 생기므로 복잡도가 증가한다.
2. 종속성 주입 자체가 런타임에 일어나므로 종속성 주입 에러를 컴파일 단계에서 잡기 어렵다.

<br>

---
## 전략 패턴

전략 패턴(정착 패턴)은 전략이라고 부르는 **캡슐화한 알고리즘**을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 디자인 패턴이다.

예를 들면 로그인을 할 때 일반적인 로그인, 카카오, 구글 로그인 행위를 할 때 각각 전략들을 쉽게 교체 가능하게끔 하는 것을 전략패턴이라고 한다.

<br>

---
## 옵저버 패턴

옵저버 패턴은 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다.

Subject(변화!) -> 주체(옵저버에게 알려줌) -> 옵저버s

<br>

---
## 프록시 패턴

프록시 패턴은 객체가 어떤 대상 객체에 접근하기 전, 접근에 대한 **흐름을 가로채서** 해당 접근을 **필터링**하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴이다.

프록시 서버 자체가 프록시 패턴으로 부터 나온 것 (nginx 같은)

<br>

---
## MVC, MVP, MVVM 패턴

### MVC 패턴

MVC 패턴은 모델, 뷰, 컨트롤러로 이루어진 디자인 패턴이다.

#### Model

모델은 애플리케이션의 데이터베이스, 상수, 변수 등을 뜻한다.

뷰에서 데이터를 생성하거나 수정할 때 컨트롤러를 통해 모델이 생성 또는 업데이트 된다.

#### View

뷰는 사용자 인터페이스 요소를 나타내면 모델을 기반으로 사용자가 볼 수 있는 화면을 뜻한다.

#### Controller

컨트롤러는 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며, 메인 로직을 담당한다.
또한, 모델과 뷰의 생명 주기를 관리한다.


#### 장점

1. 애플리케이션 구성 요소를 세 가지로 구분하여 각 구성 요소에 집중하여 개발할 수 있다.
2. 재사용성과 확장성이 용이하다.

#### 단점

애플리케이션이 복잡해질 수록 모델과 뷰의 관계가 복잡해진다.

MVC 패턴의 대표적 프레임워크는 SpringWeb MVC 이다.

<br>

### MVP 패턴

MVC에서 P(프레젠터, Presenter) 로 교체된 패턴으로 뷰와 프레젠터가 1:1 관계로 MVC 보다 더 강한 결합을 가지는 패턴이다.

<br>

### MVVM 패턴

MVC에서 VM(View Model)로 바뀐 패턴으로, 뷰를 추상화한 계층이며 뷰 모델과 뷰는 1:N 관계

VM은 커멘드와 데이터바인딩을 가진다.
- 커멘드 : 여러 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 기법
- 데이터바인딩 : 화면에 보이는 데이터와 브라우저 상의 메모리 데이터를 일치시키는 방법

MVVM 패턴의 대표적 프레임워크는 Vue.js 이다.

![[Pasted image 20231127142429.png]]

<br>

---
## Flux 패턴

Flux는 사용자 입력을 기반으로 Action을 만들고 Dipatcher에 전당하여 Sotre(Model)의 데이터를 변경한 뒤 View에 반영하는 단방향의 흐름으로 애플리케이션을 만드는 패턴이다.

![[Pasted image 20231127144112.png]]

---

