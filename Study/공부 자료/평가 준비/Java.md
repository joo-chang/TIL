
## 2. 자바 프로그래밍 기초 및 환경 구성

### 2.1 자바의 아키텍처와 실행 메커니즘

자바 프로그래밍의 기초를 이해하기 위해서는 JVM의 동작 원리에 대한 이해가 선행되어야 한다. 자바 소스 코드(.java)는 컴파일러(javac)에 의해 바이트코드(.class)로 변환되며, 이 바이트코드는 JVM의 클래스 로더(Class Loader)에 의해 런타임 데이터 영역(Runtime Data Area)으로 적재된다.

자바 프로그램은 클래스 단위로 구성되며, 객체지향 원칙에 따라 모든 실행 코드는 클래스 내부에 정의되어야 한다. 프로그램의 진입점(Entry Point)은 `public static void main(String args)` 메서드이며, 이는 JVM이 애플리케이션을 구동할 때 가장 먼저 호출하는 특수한 메서드이다.

#### 코드 예시: 기본 구조와 주석의 활용

코드의 가독성과 유지보수성을 높이기 위해 자바는 세 가지 형태의 주석을 지원한다. 특히 Javadoc 주석은 협업 환경에서 API 문서를 자동화하는 데 필수적이다.

### 2.2 식별자(Identifiers) 및 명명 규칙(Naming Conventions)

식별자는 클래스, 메서드, 변수 등을 구분하는 이름이다. 자바는 유니코드를 지원하므로 식별자에 다양한 문자를 사용할 수 있으나, 실무에서는 영문자, 숫자, 언더스코어(`_`), 달러 기호(`$`)의 조합을 표준으로 한다. 단, 숫자로 시작할 수 없으며 예약어(Reserved Keywords)는 사용할 수 없다.

**표준 명명 규칙 분석:**

- **클래스(Class/Interface):** 파스칼 표기법(PascalCase)을 따른다. 명사는 대문자로 시작하며, 복합어의 각 단어 첫 글자도 대문자로 표기한다. (예: `UserAccount`, `TransactionManager`)
    
- **메서드(Method):** 카멜 표기법(camelCase)을 따른다. 동사로 시작하며, 첫 단어는 소문자, 이후 단어의 첫 글자는 대문자로 표기한다. (예: `calculateTotalAmount`, `fetchUserData`)
    
- **변수(Variable):** 카멜 표기법을 따르며, 의미를 명확히 전달하는 명사를 사용한다. (예: `customerName`, `isValidUser`)
    
- **상수(Constant):** 모든 글자를 대문자로 작성하고 단어 사이를 언더스코어로 구분하는 스네이크 표기법(SCREAMING_SNAKE_CASE)을 사용한다. (예: `MAX_RETRY_COUNT`, `DEFAULT_TIMEOUT`).
    

---

## 3. 변수(Variables)와 데이터 타입(Data Types) 심층 분석

### 3.1 변수의 생명주기와 스코프

변수는 데이터를 저장하기 위한 메모리 공간의 이름이다. 자바는 정적 타입(Statically Typed) 언어로, 변수 선언 시 자료형을 명확히 지정해야 한다. 변수는 선언된 위치에 따라 메모리 할당 시점과 소멸 시점이 결정된다.

### 3.2 자료형 (Data Types): Primitive vs Reference

자바의 자료형은 크게 기초 자료형(Primitive Type)과 참조 자료형(Reference Type)으로 나뉜다. 이 둘의 가장 큰 차이점은 데이터가 저장되는 방식이다. 기초 자료형은 **실제 값(Literal)**을 스택 메모리에 직접 저장하는 반면, 참조 자료형은 데이터가 저장된 **힙 메모리의 주소 값**을 스택에 저장한다.

#### 3.2.1 기초 자료형의 종류와 특성

자바는 8가지의 기초 자료형을 제공하며, 각 타입은 고정된 메모리 크기를 가진다. 이는 플랫폼에 상관없이 동일한 크기를 보장하여 자바의 이식성을 높이는 핵심 요소이다.

**심화 인사이트 (실수 연산의 정밀도):** `float`와 `double`은 부동 소수점 방식을 사용하므로 근사값을 표현한다. 따라서 금융 계산과 같이 정확한 소수점 연산이 필요한 경우에는 `BigDecimal` 클래스를 사용해야 한다.

### 3.3 형 변환 (Type Casting)의 메커니즘

형 변환은 변수의 타입을 다른 타입으로 변경하는 과정이다. 자바 컴파일러는 데이터 손실이 없는 경우 자동으로 변환을 수행하지만, 손실 가능성이 있는 경우 개발자의 명시적인 지시(Cast 연산자)를 요구한다.

1. **자동 형 변환 (Implicit/Widening):** 작은 메모리 크기에서 큰 메모리 크기로, 또는 정수형에서 실수형으로 변환될 때 발생한다. (예: `byte` → `int` → `double`)
    
2. **강제 형 변환 (Explicit/Narrowing):** 큰 타입에서 작은 타입으로 변환할 때 사용하며, 데이터의 일부(상위 비트)가 잘려나가거나 소수점이 절삭될 수 있다.
    

---

## 4. 연산자 (Operators)의 구조와 우선순위

자바의 연산자는 데이터를 가공하여 새로운 값을 산출하는 도구이다. 연산자는 피연산자의 수와 기능에 따라 분류되며, 복합적인 수식에서는 정해진 우선순위와 결합 법칙에 따라 연산 순서가 결정된다.

### 4.1 핵심 연산자 종류

- **산술 연산자:** `+`, `-`, `*`, `/`, `%` (나머지 연산은 해시 알고리즘이나 순환 로직에서 중요하게 사용된다).
    
- **비교 연산자:** `==`, `!=`, `>`, `<`, `>=`, `<=` (결과는 항상 `boolean`이다). 객체 비교 시 `==`는 주소값을 비교하므로 `equals()` 메서드와 구분해야 한다.
    
- **논리 연산자:** `&&` (AND), `||` (OR), `!` (NOT).
    
- **대입 연산자:** `=`, `+=`, `-=`, `*=`, `/=`, `%=`.
    

### 4.2 논리 연산의 단락 회로 평가 (Short-Circuit Evaluation)

자바의 논리 연산자는 효율성을 위해 단락 회로 평가를 수행한다. 이는 불필요한 연산을 방지하고 성능을 최적화하지만, 피연산자에 부수 효과(Side Effect)가 있는 코드가 포함될 경우 의도치 않은 버그를 유발할 수 있다.

- `A && B`: A가 `false`이면 B는 평가하지 않고 `false` 반환.
    
- `A |
    

| B`: A가` true`이면 B는 평가하지 않고` true` 반환.

---

## 5. 제어 흐름 (Control Flow)

### 5.1 조건문: 로직 분기의 핵심

프로그램의 상태나 입력값에 따라 실행 경로를 변경한다. `if-else` 구조는 일반적인 조건 분기에 사용되며, `switch` 문은 단일 변수의 값에 따른 다중 분기에 최적화되어 있다.

**Enhanced Switch (Java 14+):** 최신 자바 버전에서는 `switch` 문이 표현식(Expression)으로 확장되어 값을 반환할 수 있고, `yield` 키워드와 화살표 구문(`->`)을 통해 더 간결하고 안전한 코드를 작성할 수 있다.

### 5.2 반복문: 데이터 처리와 순회

반복문은 데이터 집합을 순회하거나 특정 작업을 반복 수행할 때 사용된다.

- **for 문:** 반복 횟수가 예측 가능할 때 사용. 인덱스 제어가 용이하다.
    
- **for-each 문:** `Iterable`을 구현한 컬렉션이나 배열을 순회할 때 사용. 가독성이 좋고 `ArrayIndexOutOfBoundsException`을 방지할 수 있으나, 인덱스에 직접 접근하거나 요소를 삭제하는 데에는 제약이 있다.
    
- **while / do-while 문:** 반복 횟수보다는 종료 조건이 중요할 때 사용한다. `do-while`은 최소 1회 실행을 보장한다.
    

---

## 6. 문자열(String)과 배열(Array)

### 6.1 String의 불변성(Immutability)과 메모리 효율

자바에서 `String`은 특별한 대우를 받는 참조 타입이다. `String` 객체는 한 번 생성되면 내부의 문자열 값을 변경할 수 없다(Immutable). 이는 멀티스레드 환경에서의 안전성을 보장하고, String Constant Pool을 통한 메모리 절약을 가능하게 한다.

문자열 결합 연산(`+`)이 반복되면 매번 새로운 객체가 생성되어 메모리 낭비와 GC 부하를 유발한다. 따라서 빈번한 수정이 필요한 경우 `StringBuilder` (비동기, 빠름) 또는 `StringBuffer` (동기, 스레드 안전)를 사용해야 한다.

### 6.2 배열(Arrays)과 다차원 데이터 처리

배열은 동일한 타입의 데이터를 연속된 메모리 공간에 저장하는 가장 기본적인 자료구조이다. 인덱스를 통한 조회 속도(O(1))가 매우 빠르지만, 생성 시 크기가 고정되어 변경할 수 없다는 단점이 있다.

---

## 7. 메서드(Methods)와 모듈화

메서드는 특정 기능을 수행하는 코드의 집합으로, 코드의 재사용성을 높이고 프로그램을 모듈화하는 기본 단위이다.

**메서드 시그니처와 오버로딩(Overloading):** 메서드 시그니처는 메서드의 이름과 매개변수 리스트로 구성된다. 자바는 리턴 타입은 다르더라도 시그니처가 같으면 동일한 메서드로 간주한다. 오버로딩은 이름은 같지만 매개변수의 개수나 타입이 다른 메서드를 여러 개 정의하는 기술로, 다형성의 한 형태이다.

---

## 8. 객체지향 프로그래밍(OOP) - 기초

객체지향 프로그래밍은 현실 세계의 사물을 객체(Object)로 모델링하고, 이들 간의 상호작용으로 소프트웨어를 설계하는 패러다임이다. 자바는 순수 객체지향 언어에 가까우며 캡슐화, 상속, 다형성, 추상화라는 4대 원칙을 기반으로 한다.

### 8.1 클래스와 인스턴스

클래스가 객체를 생성하기 위한 설계도(Blueprint)라면, 인스턴스는 그 설계도를 바탕으로 메모리에 실체화된 결과물이다. `new` 키워드를 통해 힙 메모리에 할당된다.

### 8.2 캡슐화(Encapsulation)와 정보 은닉

객체의 내부 상태(필드)를 외부로 직접 노출하지 않고, 메서드(Getter/Setter)를 통해서만 접근하도록 제한하는 것이다. 이를 통해 데이터의 무결성을 보장하고, 내부 구현 변경이 외부에 미치는 영향을 최소화한다.

**접근 제어자 (Access Modifiers):**

- `private`: 클래스 내부에서만 접근 가능 (가장 엄격).
    
- `default` (package-private): 같은 패키지 내에서 접근 가능.
    
- `protected`: 같은 패키지 + 상속받은 자식 클래스에서 접근 가능.
    
- `public`: 모든 곳에서 접근 가능.
    

### 8.3 Static의 이해

`static` 멤버는 객체에 종속되지 않고 클래스 레벨에 속한다. 프로그램 시작 시 메모리에 로드되어 모든 인스턴스가 공유한다. 유틸리티 메서드나 상수를 정의할 때 주로 사용된다. 과도한 `static` 사용은 메모리 누수나 테스트의 어려움을 유발할 수 있으므로 주의해야 한다.

---

## 9. 객체지향 프로그래밍(OOP) - 고급

### 9.1 상속(Inheritance)과 계층 구조

상속은 기존 클래스(부모)의 특성을 새로운 클래스(자식)가 물려받아 확장하는 기능이다. `extends` 키워드를 사용하며, 자바는 다중 상속의 모호성(Diamond Problem)을 피하기 위해 단일 상속만을 허용한다. 상속은 코드 재사용뿐만 아니라 다형성의 기반이 된다.

### 9.2 다형성(Polymorphism)

다형성은 하나의 객체가 여러 형태를 가질 수 있는 성질이다. 이는 부모 타입의 참조 변수로 자식 타입의 객체를 다루는 것을 가능하게 한다.

- **오버라이딩(Overriding):** 부모의 메서드를 자식 클래스에서 재정의하여 동작을 변경한다. 런타임에 실제 객체의 메서드가 호출된다(동적 바인딩).
    
- **참조 변수의 형 변환:** 업캐스팅(자식->부모)은 자동, 다운캐스팅(부모->자식)은 명시적 변환이 필요하며 `instanceof` 연산자로 타입을 확인해야 안전하다.
    

### 9.3 추상 클래스와 인터페이스

이 둘은 구현을 강제하고 표준을 정의하는 역할을 하지만, 사용 목적과 특성에 차이가 있다.

- **추상 클래스(Abstract Class):** `IS-A` 관계. 상태(필드)를 가질 수 있고, 일부 메서드만 추상화할 수 있다. 관련된 클래스들의 공통 로직을 묶을 때 사용한다.
    
- **인터페이스(Interface):** `HAS-A` 또는 동작(Behavior) 정의. 다중 구현(`implements`)이 가능하다. Java 8부터 `default` 메서드와 `static` 메서드를 지원하여 유연성이 대폭 강화되었다.
    

---

## 10. 자바 표준 라이브러리 및 확장 연산자

### 10.1 표준 라이브러리 (java.lang, java.util)

자바는 방대한 표준 API를 제공한다. `java.lang` 패키지(String, Math, System 등)는 별도 import 없이 사용 가능하며, `java.util` 패키지는 컬렉션, 날짜, 유틸리티 클래스를 포함한다.

- **Math 클래스:** 수학 연산을 위한 정적 메서드 제공 (`abs`, `max`, `sqrt`, `pow`, `random` 등).
    
- **Scanner 클래스:** 입력 스트림 파싱 유틸리티.
    

### 10.2 확장 연산자: 비트 및 3항 연산자

이들은 코드의 간결성과 성능 최적화를 위해 사용된다.

- **비트 연산자 (`&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`):** 정수 데이터를 비트 단위로 제어한다. 플래그 처리나 암호화 알고리즘 등 로우 레벨 제어에 유용하다.
    
- **3항 연산자:** `조건? 값1 : 값2`. 단순한 `if-else` 로직을 한 줄로 표현하여 가독성을 높일 수 있으나, 중첩 사용 시 가독성을 해칠 수 있다.
    

---

## 11. 제네릭(Generics)

제네릭은 클래스나 메서드에서 사용할 데이터 타입을 컴파일 시점에 미리 지정하지 않고, 인스턴스 생성 시점에 확정하는 기법이다. 이는 코드의 재사용성을 극대화하고 타입 안정성(Type Safety)을 컴파일 타임에 보장한다.

### 11.1 제네릭의 필요성과 장점

제네릭 도입 이전(Java 5 미만)에는 `Object` 타입을 사용하여 모든 객체를 처리했다. 이는 데이터를 꺼낼 때마다 명시적인 형 변환(Casting)이 필요했고, 런타임에 `ClassCastException`이 발생할 위험이 높았다. 제네릭은 이러한 형 변환 코드를 제거하고 잘못된 타입이 들어오는 것을 컴파일러가 차단한다.

### 11.2 제네릭 클래스와 메서드 정의

- **타입 파라미터 관례:** `T`(Type), `E`(Element), `K`(Key), `V`(Value) 등을 사용한다.
    
- **와일드카드 (`?`):** 타입을 확정할 수 없을 때 사용하며, `? extends T` (상한 경계)와 `? super T` (하한 경계)를 통해 유연성을 확보한다.
    

---

## 12. 열거형 (Enum)

자바의 `enum`은 단순한 상수 목록이 아니다. `java.lang.Enum`을 상속받는 특수한 클래스로, 필드, 메서드, 생성자를 가질 수 있어 상태와 행위를 함께 캡슐화할 수 있다. 이는 타입 안전한 상수를 정의하고, 상수와 관련된 로직을 응집도 높게 관리하는 데 탁월하다.

---

## 13. 자바 컬렉션 프레임워크 (Collection Framework)

컬렉션 프레임워크는 다수의 데이터를 표준화된 방식으로 처리할 수 있는 자료구조와 알고리즘의 집합이다. 주요 인터페이스로 `List`, `Set`, `Map`, `Queue`가 있으며, 각 인터페이스는 다양한 구현체를 제공하여 용도에 맞게 선택할 수 있다.

### 13.1 주요 인터페이스 및 구현체 분석

### 13.2 실무 활용 코드 및 주의사항

`ArrayList`는 조회가 빈번한 경우, `LinkedList`는 삽입/삭제가 빈번한 경우 유리하다. `HashMap`은 해시 충돌(Hash Collision)이 발생하면 성능이 저하될 수 있으므로 `hashCode()`와 `equals()`의 올바른 구현이 필수적이다.

---

## 14. 예외 처리 (Exception Handling)

예외 처리는 프로그램 실행 중 발생하는 예기치 않은 오류에 대처하여 시스템의 비정상 종료를 방지하고, 로그를 남겨 문제를 추적할 수 있게 하는 필수적인 기법이다.

### 14.1 예외 계층 구조 (Hierarchy)

모든 예외의 최상위 클래스는 `java.lang.Throwable`이다.

- **Error:** 시스템 레벨의 심각한 오류(StackOverflowError, OutOfMemoryError). 애플리케이션에서 복구할 수 없다.
    
- **Exception:** 애플리케이션 레벨의 오류.
    
    - **Checked Exception:** 컴파일러가 처리를 강제함 (`IOException`, `SQLException`). 반드시 `try-catch`로 잡거나 `throws`로 전파해야 한다.
        
    - **Unchecked Exception (Runtime Exception):** 개발자의 실수로 주로 발생 (`NullPointerException`, `IndexOutOfBoundsException`). 명시적 처리를 강제하지 않는다.
        

### 14.2 안전한 자원 해제 (Try-with-resources)

Java 7부터 도입된 `try-with-resources` 구문은 `AutoCloseable` 인터페이스를 구현한 자원(파일, 소켓, DB 연결 등)을 `try` 블록이 끝날 때 자동으로 해제해준다. 이는 `finally` 블록에서의 실수로 인한 자원 누수를 원천적으로 차단한다.