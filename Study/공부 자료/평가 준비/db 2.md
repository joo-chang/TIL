# 현대 데이터베이스 시스템: 이론, 아키텍처 및 고급 관리 전략에 대한 포괄적 분석

## 1. 서론: 데이터 관리 시스템의 진화와 중요성

현대 정보 사회에서 데이터는 조직의 가장 중요한 자산 중 하나로 간주된다. 기업의 의사결정 프로세스부터 국가 기반 시설의 운영에 이르기까지, 데이터의 효율적인 저장, 검색, 그리고 관리는 현대 문명을 지탱하는 핵심 기술이다. 과거의 파일 처리 시스템(File Processing System)이 가지던 데이터 중복성, 비일관성, 보안 취약점 등의 한계를 극복하기 위해 등장한 데이터베이스 관리 시스템(DBMS, Database Management System)은 이제 단순한 데이터 저장소를 넘어 비즈니스 인텔리전스와 인공지능의 기반이 되는 복합적인 플랫폼으로 진화하였다.

본 보고서는 데이터베이스 시스템의 근간이 되는 이론적 개념부터 실제 구현 및 운영에 필수적인 고급 기술까지 포괄적으로 다룬다. 특히 데이터베이스의 정의와 특징, 시스템 아키텍처, 데이터 모델링 이론, 관계형 데이터 모델의 수학적 기초, 그리고 트랜잭션 관리와 동시성 제어, 회복 및 보안과 같은 운영 핵심 요소를 심도 있게 분석한다. 이를 통해 데이터 엔지니어, 시스템 아키텍트, 그리고 데이터베이스 관리자(DBA)가 갖추어야 할 전문적인 지식 체계를 정립하고자 한다.

---

## 2. 데이터베이스의 개념 및 기초 이론

### 2.1 데이터베이스(Database)의 정의와 본질

데이터베이스는 특정 조직의 다수 사용자가 공유하여 사용할 수 있도록 통합(Integrated)되고 저장(Stored)된 운영(Operational) 데이터의 집합으로 정의된다. 이는 단순한 데이터의 모음이 아니라, 논리적으로 연관된 데이터들이 체계적으로 구조화되어 있음을 의미한다.1

#### 2.1.1 데이터베이스의 4대 특성

데이터베이스가 파일 시스템과 구별되는 핵심적인 특징은 다음과 같이 네 가지로 요약될 수 있다 1:

1. **실시간 접근성 (Real-time Accessibility):** 데이터베이스는 사용자의 질의(Query)에 대해 즉각적인 응답을 제공해야 한다. 이는 비정형적인 조회 요청에 대해서도 시스템 성능 제한 내에서 실시간 처리를 보장함을 의미한다.
    
2. **계속적인 변화 (Continuous Evolution):** 데이터베이스는 정적인 상태로 머물러 있지 않는다. 현실 세계의 상태 변화를 반영하기 위해 삽입(Insertion), 삭제(Deletion), 갱신(Update) 연산을 통해 데이터는 동적으로 변화하며 항상 최신의 정확한 데이터를 유지해야 한다.
    
3. **동시 공유 (Concurrent Sharing):** 여러 사용자나 응용 프로그램이 동일한 데이터를 동시에 접근하고 이용할 수 있어야 한다. 이는 단순히 여러 사람이 데이터를 보유하는 것을 넘어, 동시에 같은 데이터에 접근할 때 발생할 수 있는 충돌을 제어하는 메커니즘을 포함한다.
    
4. **내용에 의한 참조 (Content-Based Reference):** 데이터는 저장된 메모리 주소나 위치가 아닌, 사용자가 요구하는 데이터의 내용(값)에 따라 참조된다. 이는 사용자가 데이터의 물리적 위치를 알 필요 없이 논리적인 조건만으로 데이터를 검색할 수 있게 하는 핵심 원리이다.
    

### 2.2 데이터베이스 관리 시스템 (DBMS)

DBMS는 사용자와 데이터베이스 사이에서 중재자 역할을 하는 소프트웨어 패키지이다. 모든 데이터 접근 요청은 DBMS를 통하여 이루어지며, 이를 통해 데이터의 일관성과 무결성이 보장된다.

#### 2.2.1 DBMS의 필수 기능

DBMS는 다음과 같은 세 가지 주요 기능을 수행한다 3:

- **정의 기능 (Definition):** 데이터의 형(Type), 구조, 제약 조건 등을 명시하여 데이터베이스의 논리적, 물리적 구조를 정의한다. 데이터 정의 언어(DDL)를 통해 구현된다.
    
- **조작 기능 (Manipulation):** 사용자가 데이터를 검색, 삽입, 삭제, 갱신할 수 있도록 체계적인 인터페이스를 제공한다. 데이터 조작 언어(DML)를 통해 구현된다.
    
- **제어 기능 (Control):** 데이터의 정확성과 안전성을 유지하기 위해 무결성 유지, 보안 및 권한 검사, 병행 제어, 회복 등을 수행한다. 데이터 제어 언어(DCL)를 통해 구현된다.
    

#### 2.2.2 DBMS 도입의 이점

파일 처리 시스템 대비 DBMS를 도입함으로써 얻을 수 있는 이점은 명확하다 2:

- **데이터 중복의 제어:** 중앙 집중식 관리를 통해 불필요한 중복을 최소화하여 저장 공간을 절약하고 데이터 일관성을 유지한다.
    
- **데이터 독립성 확보:** 데이터의 논리적 구조와 물리적 저장 방식이 분리되어, 한 쪽의 변경이 다른 쪽에 영향을 주지 않는다.
    
- **보안 및 무결성 향상:** 권한이 없는 사용자의 접근을 차단하고, 제약 조건을 통해 유효하지 않은 데이터의 저장을 방지한다.
    
- **표준화 시행:** 데이터의 표현 방식, 문서화 양식 등을 표준화하여 조직 내 데이터 관리의 효율성을 높인다.
    

#### 2.2.3 DBMS의 분류

DBMS는 지원하는 데이터 모델에 따라 크게 계층형, 네트워크형, 관계형, 객체지향형 등으로 분류된다. 현재 산업계의 표준은 관계형 데이터 모델(Relational Data Model)이며, 최근 비정형 데이터 처리를 위한 NoSQL 시스템도 확산되고 있다.2

---

## 3. 시스템 구성 요소와 아키텍처

데이터베이스 시스템의 아키텍처는 데이터 독립성을 보장하고 시스템의 복잡성을 관리하기 위해 설계되었다.

### 3.1 3단계 스키마 구조 (3-Level Schema Architecture)

ANSI/SPARC 아키텍처로도 알려진 이 구조는 데이터베이스를 관점에 따라 세 단계로 추상화한다.4

|**단계**|**설명**|**주요 특징**|
|---|---|---|
|**외부 스키마 (External Schema)**|사용자나 응용 프로그래머가 바라보는 개인적 관점의 데이터 구조|서브 스키마(Sub-schema)라고도 하며, 하나의 데이터베이스에 여러 개의 외부 스키마가 존재할 수 있다. 사용자가 필요한 부분만을 정의한다.|
|**개념 스키마 (Conceptual Schema)**|조직 전체의 관점에서 바라보는 통합된 데이터 구조|모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 데이터베이스 논리적 구조이다. 개체 간의 관계와 제약 조건을 포함하며, **일반적으로 '스키마'라고 하면 개념 스키마를 지칭한다.**|
|**내부 스키마 (Internal Schema)**|물리적 저장 장치의 관점에서 바라보는 데이터 구조|데이터의 실제 저장 방법, 레코드의 물리적 구조, 인덱스, 해싱 등 물리적 저장 경로를 정의한다.|

### 3.2 데이터 독립성 (Data Independence)

3단계 스키마 구조의 궁극적인 목적은 데이터 독립성을 실현하는 것이다. 이는 하위 단계의 스키마 변경이 상위 단계의 스키마나 응용 프로그램에 영향을 미치지 않도록 하는 성질이다.4

- **논리적 데이터 독립성 (Logical Data Independence):** 개념 스키마가 변경되어도(예: 새로운 속성 추가), 외부 스키마나 응용 프로그램은 변경될 필요가 없음을 의미한다. 외부 스키마와 개념 스키마 간의 사상(Mapping)을 통해 보장된다.8
    
- **물리적 데이터 독립성 (Physical Data Independence):** 내부 스키마(물리적 저장 구조)가 변경되어도(예: 인덱스 추가, 디스크 변경), 개념 스키마에는 영향을 주지 않음을 의미한다. 이를 통해 성능 최적화를 위한 물리적 구조 변경이 응용 프로그램의 수정 없이 가능하다.9
    

### 3.3 데이터 사전 (Data Dictionary) 및 시스템 카탈로그

데이터 사전, 또는 시스템 카탈로그는 '데이터에 대한 데이터(Metadata)'를 저장하는 시스템 데이터베이스이다.10

- **역할:** 데이터베이스에 포함된 모든 데이터 개체(테이블, 뷰, 인덱스, 사용자, 제약 조건 등)에 대한 정의나 명세를 유지 관리한다.
    
- **능동적(Active) vs. 수동적(Passive):** 현대의 대부분의 DBMS는 능동적 데이터 사전을 사용한다. 즉, 시스템이 질의를 처리하거나 데이터를 조작할 때마다 데이터 사전을 실시간으로 참조하여 개체의 존재 여부나 권한을 검증한다. 반면 수동적 사전은 단순한 문서화 목적이다.10
    
- **접근성:** 일반 사용자는 SQL을 이용하여 내용을 검색(SELECT)할 수 있지만, 직접 갱신(INSERT, DELETE, UPDATE)하는 것은 불허된다. 카탈로그의 갱신은 DDL문 수행 시 DBMS에 의해 자동으로 이루어진다.13
    

---

## 4. 데이터 모델링: 현실 세계의 추상화

데이터 모델링은 현실 세계의 복잡한 정보 구조를 컴퓨터가 이해할 수 있는 논리적 구조로 변환하는 과정이다.

### 4.1 개체-관계 모델 (E-R Model)

피터 첸(Peter Chen)에 의해 제안된 E-R 모델은 개념적 설계 단계에서 가장 널리 사용되는 도구이다. 현실 세계를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현한다.14

- **개체 (Entity):** 현실 세계에서 독립적으로 존재하는 식별 가능한 객체(예: 학생, 교수, 과목). 사각형으로 표현한다.
    
- **속성 (Attribute):** 개체의 특성이나 상태를 기술하는 정보(예: 학번, 이름, 전공). 타원으로 표현한다.
    
- **관계 (Relationship):** 개체 간의 연관성(예: 수강하다, 지도하다). 마름모로 표현하며, 일대일(1:1), 일대다(1:N), 다대다(M:N)의 대응수(Cardinality)를 가진다.14
    

E-R 다이어그램(ERD)은 이해관계자 간의 의사소통 도구로 활용되며, 이후 논리적 설계 단계에서 구체적인 데이터 모델(주로 관계형 모델)로 변환된다.

### 4.2 레거시 데이터 모델: 계층형 및 네트워크형

관계형 모델이 표준이 되기 전 사용되었던 초기 데이터 모델들이다.

- **계층형 데이터 모델 (Hierarchical Data Model):** 데이터를 트리(Tree) 구조로 표현한다. 부모와 자식 개체는 1:N 관계만 가질 수 있으며, 자식은 반드시 하나의 부모만 가져야 한다. 데이터 접근 경로가 미리 정의되어 있어 속도는 빠르지만, 구조 변경이 어렵고 M:N 관계 표현 시 데이터 중복이 발생한다.16
    
- **네트워크형 데이터 모델 (Network Data Model):** 그래프(Graph) 구조를 기반으로 한다. 자식 레코드가 여러 부모 레코드를 가질 수 있어(M:N 지원), 계층형 모델보다 유연하다. 그러나 구조가 복잡하고, 데이터 종속성이 높아 프로그램 구현 및 유지보수가 어렵다는 단점이 있다.17
    

---

## 5. 관계형 데이터 모델 (Relational Data Model)

1970년 E.F. Codd가 제안한 관계형 모델은 데이터를 2차원 표(Table) 형태의 릴레이션(Relation)으로 표현하는 모델이다. 수학적 집합론에 기초하여 탄탄한 이론적 배경을 가지며, 현재 가장 널리 사용된다.1

### 5.1 릴레이션의 구조 및 용어

- **릴레이션 (Relation):** 데이터들을 표로 표현한 것. 물리적으로는 테이블(Table)에 해당한다.
    
- **튜플 (Tuple):** 릴레이션을 구성하는 각 행(Row). 개체의 한 인스턴스를 나타낸다. 튜플의 수는 카디널리티(Cardinality)라고 한다.1
    
- **속성 (Attribute):** 릴레이션의 열(Column). 데이터의 가장 작은 논리적 단위이다. 속성의 수는 차수(Degree)라고 한다.
    
- **도메인 (Domain):** 하나의 속성이 가질 수 있는 원자값(Atomic Value)들의 집합이다. 예를 들어 '성별' 속성의 도메인은 '남', '여'가 될 수 있다.1
    

릴레이션의 특징 1:

1. **튜플의 유일성:** 한 릴레이션에 포함된 튜플들은 모두 상이해야 한다.
    
2. **튜플의 무순서:** 튜플 사이에는 순서가 없다.
    
3. **속성의 무순서:** 속성들 간의 순서는 중요하지 않다.
    
4. **속성의 원자성:** 모든 속성 값은 논리적으로 더 이상 분해할 수 없는 원자값이어야 한다.
    

### 5.2 키(Key)의 개념과 종류

키는 튜플을 유일하게 식별하거나 릴레이션 간의 관계를 맺는 데 사용되는 속성의 집합이다.1

|**종류**|**정의 및 특징**|
|---|---|
|**슈퍼키 (Super Key)**|유일성(Uniqueness)은 만족하지만 최소성(Minimality)은 만족하지 않을 수 있는 속성 집합. (예: 학번 + 이름)|
|**후보키 (Candidate Key)**|유일성과 최소성을 모두 만족하는 속성 집합. 튜플을 식별할 수 있는 최소한의 속성들.|
|**기본키 (Primary Key)**|후보키 중에서 설계자에 의해 선택된 주 키. NULL 값을 가질 수 없으며 중복될 수 없다.|
|**대체키 (Alternate Key)**|후보키 중 기본키로 선택되지 않은 나머지 키.|
|**외래키 (Foreign Key)**|다른 릴레이션의 기본키를 참조하는 속성. 릴레이션 간의 관계를 표현한다.19|

### 5.3 무결성 제약조건 (Integrity Constraints)

데이터의 정확성과 일관성을 보장하기 위해 지켜야 할 규칙이다.1

1. **개체 무결성 (Entity Integrity):** 기본키를 구성하는 어떤 속성도 NULL 값이나 중복 값을 가질 수 없다. 이는 각 튜플이 유일하게 식별가능해야 함을 보장한다.
    
2. **참조 무결성 (Referential Integrity):** 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다. 존재하지 않는 개체를 참조할 수 없다는 규칙이다.19
    
3. **도메인 무결성 (Domain Integrity):** 특정 속성의 값은 그 속성에 정의된 도메인에 속한 값이어야 한다.
    

---

## 6. 관계형 연산: 대수와 해석

관계형 데이터베이스에서 데이터를 추출하고 조작하기 위한 이론적 기반은 관계 대수와 관계 해석이다. SQL은 이 두 가지 이론을 기반으로 만들어진 언어이다.

### 6.1 관계 대수 (Relational Algebra)

관계 대수는 원하는 정보를 얻기 위해 **어떻게(How)** 유도하는가를 기술하는 절차적 언어이다. 연산의 결과 역시 릴레이션이 된다.1

#### 6.1.1 순수 관계 연산자

- **Select ($\sigma$):** 조건에 맞는 튜플을 선택하는 수평적 연산.
    
    - $\sigma_{조건}(R)$
        
- **Project ($\pi$):** 조건에 맞는 속성만을 추출하는 수직적 연산. 중복된 튜플은 제거된다.
    
    - $\pi_{속성리스트}(R)$
        
- **Join ($\bowtie$):** 두 릴레이션을 공통 속성을 기준으로 결합하여 새로운 릴레이션을 생성한다.
    
    - **자연 조인(Natural Join):** 동일한 속성명을 가진 속성에 대해 등가 조인을 수행하고 중복 속성을 제거한다.
        
- **Division ($\div$):** 릴레이션 R이 릴레이션 S의 모든 속성 값을 포함하는 튜플을 구한다. "모든 과목을 수강한 학생"과 같은 질의에 사용된다.1
    

#### 6.1.2 일반 집합 연산자

합집합($\cup$), 교집합($\cap$), 차집합($-$), 교차곱($\times$) 등이 있으며, 이들을 수행하기 위해서는 두 릴레이션이 합병 가능(Union Compatible)해야 한다(차수와 도메인이 일치해야 함).

### 6.2 관계 해석 (Relational Calculus)

관계 해석은 원하는 정보가 **무엇(What)**인지만 정의하는 비절차적 언어이다. 프레디켓 논리(Predicate Logic)에 기반을 둔다.22

- **튜플 관계 해석 (Tuple Relational Calculus):** 튜플 변수(Tuple Variable)를 사용하여 튜플 단위로 원하는 조건을 명시한다.
    
    - 형식: $\{ t | P(t) \}$ (여기서 $t$는 튜플 변수, $P(t)$는 조건식).24
        
- **도메인 관계 해석 (Domain Relational Calculus):** 도메인 변수(Domain Variable)를 사용하여 속성 단위로 조건을 명시한다.
    
    - 형식: $\{ <x_1, x_2,..., x_n> | P(x_1, x_2,..., x_n) \}$.24
        

관계 대수와 관계 해석은 표현 능력 면에서 동등하다. 즉, 관계 대수로 표현 가능한 모든 질의는 관계 해석으로도 표현 가능하며, 그 역도 성립한다.25 SQL은 관계 해석의 선언적 특징을 많이 차용하고 있다.

---

## 7. 데이터베이스 설계 프로세스

데이터베이스 설계는 사용자의 요구사항을 분석하여 구현 가능한 데이터베이스 스키마로 변환하는 과정이다. 일반적으로 다음의 단계를 거친다.26

### 7.1 요구조건 분석 (Requirement Analysis)

데이터베이스가 처리해야 할 업무 내용과 데이터의 종류, 제약 조건 등을 수집하고 분석한다. 이 단계의 결과물로 요구사항 명세서가 작성된다.

### 7.2 개념적 설계 (Conceptual Design)

DBMS에 독립적인 고수준의 데이터 모델을 설계한다.

- **주요 활동:** 개체와 속성 식별, 개체 간의 관계 정의.
    
- **결과물:** 개체-관계 다이어그램 (ERD). 이 단계에서는 구체적인 테이블 구조보다는 데이터의 의미와 관계에 집중한다.28
    

### 7.3 논리적 설계 (Logical Design)

선택한 DBMS(예: 관계형 DBMS)가 지원하는 논리적 데이터 모델로 개념적 구조를 변환한다.

- **주요 활동:** ERD를 릴레이션 스키마로 매핑(Mapping), 정규화(Normalization) 과정을 통한 스키마 정제, 트랜잭션 인터페이스 설계.
    
- **결과물:** 릴레이션 스키마(테이블 명세서). 이 단계에서 성능과 무결성을 고려하여 데이터 구조를 최적화한다.27
    

### 7.4 물리적 설계 (Physical Design)

논리적 스키마를 실제 저장 장치에 어떻게 저장할지 결정한다.

- **주요 활동:** 저장 레코드 양식 설계, 파일 조직 방법(순차, 해시, 인덱스 등) 선택, 접근 경로 설계.
    
- **고려 사항:** 응답 시간, 저장 공간 효율성, 트랜잭션 처리율(Throughput) 등 성능 요소를 최우선으로 고려한다.27
    

### 7.5 구현 (Implementation)

DDL을 사용하여 실제 스키마를 생성하고 데이터를 적재한다.

---

## 8. 정규화 (Normalization)

정규화는 관계형 데이터베이스 설계에서 중복을 최소화하고 데이터의 일관성을 보장하기 위해 릴레이션을 분해하는 과정이다. 잘못된 설계로 인해 발생하는 이상 현상(Anomaly)을 제거하는 것이 주 목적이다.31

### 8.1 이상 현상 (Anomaly)

정규화되지 않은 릴레이션에서 데이터 조작 시 발생하는 부작용이다.

- **삽입 이상 (Insertion Anomaly):** 데이터를 삽입할 때 불필요한 데이터까지 함께 삽입해야 하거나, 기본키가 없어 삽입하지 못하는 현상.
    
- **삭제 이상 (Deletion Anomaly):** 튜플 삭제 시 유지되어야 할 정보까지 연쇄적으로 삭제되는 현상.
    
- **갱신 이상 (Update Anomaly):** 중복된 데이터 중 일부만 갱신되어 데이터의 불일치가 발생하는 현상.31
    

### 8.2 함수적 종속성 (Functional Dependency)

정규화의 이론적 배경이 되는 개념이다. 릴레이션 내의 속성 $X$의 값 하나가 속성 $Y$의 값 하나에만 매핑될 때, "$Y$는 $X$에 함수적으로 종속된다"라고 하며 $X \rightarrow Y$로 표기한다. 이때 $X$를 결정자(Determinant), $Y$를 종속자(Dependent)라고 한다.31

### 8.3 정규형 (Normal Forms) 단계

정규화는 단계별로 진행되며, 상위 단계는 하위 단계의 모든 제약 조건을 만족한다.31

#### 제1정규형 (1NF)

- **조건:** 릴레이션의 모든 속성 값이 원자값(Atomic Value)이어야 한다.
    
- **해결:** 반복되는 그룹이나 다중 값을 가진 속성을 분리하여 새로운 튜플이나 릴레이션으로 만든다.
    

#### 제2정규형 (2NF)

- **조건:** 1NF를 만족하고, 기본키가 아닌 모든 속성이 기본키에 **완전 함수 종속**되어야 한다.
    
- **해결:** 기본키의 일부분에만 종속되는 부분 함수 종속(Partial Functional Dependency)을 제거한다. 즉, 복합키인 경우 키의 일부에만 의존하는 속성을 별도 테이블로 분리한다.
    

#### 제3정규형 (3NF)

- **조건:** 2NF를 만족하고, 기본키가 아닌 모든 속성이 기본키에 **이행적 함수 종속(Transitive Functional Dependency)**되지 않아야 한다.
    
- **해결:** $A \rightarrow B$, $B \rightarrow C$인 관계가 있을 때, $A \rightarrow C$가 성립하는 이행 종속을 제거하기 위해 릴레이션을 분해한다.31
    

#### BCNF (Boyce-Codd Normal Form)

- **조건:** 3NF를 만족하고, 모든 결정자가 후보키(Candidate Key)여야 한다.
    
- **해결:** 후보키가 아닌 속성이 다른 속성을 결정하는 경우를 제거한다. 이는 3NF보다 강력한 제약 조건이다.33
    

#### 제4정규형 (4NF)

- **조건:** BCNF를 만족하고, **다치 종속(Multi-Valued Dependency: A ->> B)**이 제거되어야 한다.
    
- **설명:** 하나의 개체에 대해 두 개 이상의 독립적인 다중 값 속성이 존재할 때 발생한다. 예를 들어, 한 과목에 여러 교재와 여러 교수가 있을 때, 교재와 교수가 서로 관계가 없음에도 하나의 테이블에 있으면 불필요한 중복(Cartesian Product)이 발생한다. 이를 분해한다.34
    

#### 제5정규형 (5NF)

- **조건:** 4NF를 만족하고, **조인 종속성(Join Dependency)**이 없어야 한다.
    
- **설명:** 릴레이션을 분해했다가 다시 조인했을 때, 원래의 릴레이션에는 없던 가짜 튜플(Spurious Tuple)이 생성되지 않도록 분해해야 한다. 즉, 모든 조인 종속이 후보키를 통해서만 성립해야 한다.36
    

---

## 9. 트랜잭션 (Transaction) 관리

트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위이다.

### 9.1 ACID 특성

트랜잭션의 무결성을 보장하기 위해 반드시 지켜야 할 4가지 성질이다.38

- **원자성 (Atomicity):** 트랜잭션의 연산은 모두 반영되거나 아니면 전혀 반영되지 않아야 한다(All or Nothing). 오류 발생 시 트랜잭션 이전 상태로 복구되어야 한다.
    
- **일관성 (Consistency):** 트랜잭션이 성공적으로 완료되면 데이터베이스는 언제나 일관성 있는 상태를 유지해야 한다. 시스템의 고정 요소(제약 조건 등)는 트랜잭션 전후에 변함이 없어야 한다.
    
- **격리성/고립성 (Isolation):** 둘 이상의 트랜잭션이 동시에 실행될 때, 한 트랜잭션의 연산이 다른 트랜잭션에 의해 간섭받지 않아야 한다.
    
- **영속성 (Durability):** 성공적으로 완료(Commit)된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 보존되어야 한다.
    

### 9.2 트랜잭션의 상태 및 연산

트랜잭션은 실행부터 종료까지 다음의 상태를 거친다.39

1. **활동 (Active):** 트랜잭션이 시작되어 실행 중인 상태.
    
2. **부분 완료 (Partially Committed):** 트랜잭션의 마지막 연산까지 실행되었으나, 커밋 연산이 실행되기 직전의 상태.
    
3. **완료 (Committed):** 트랜잭션이 성공적으로 완료되어 **Commit** 연산을 수행한 상태. 변경 내용이 데이터베이스에 영구 반영된다.
    
4. **실패 (Failed):** 하드웨어 고장이나 논리적 오류로 인해 정상적인 수행이 불가능한 상태.
    
5. **철회 (Aborted):** 트랜잭션이 실패하여 **Rollback** 연산을 수행한 상태. 데이터베이스는 트랜잭션 시작 전 상태로 환원된다.
    

### 9.3 트랜잭션 스케줄

여러 트랜잭션이 동시에 실행될 때 연산들의 실행 순서를 스케줄이라 한다.43

- **직렬 스케줄 (Serial Schedule):** 트랜잭션을 하나씩 순차적으로 실행하는 것. 데이터 일관성은 보장되나 시스템 성능이 저하된다.
    
- **비직렬 스케줄 (Non-serial Schedule):** 트랜잭션의 연산들을 인터리빙(Interleaving)하여 실행하는 것. 동시성은 높으나 일관성이 깨질 수 있다.
    
- **직렬 가능 스케줄 (Serializable Schedule):** 비직렬적으로 실행되지만 그 결과가 어떤 직렬 스케줄의 결과와 동일한 스케줄. 동시성 제어의 목표이다.
    

---

## 10. 동시성 제어 (Concurrency Control)

다중 사용자 환경에서 여러 트랜잭션이 동시에 데이터베이스에 접근할 때 발생할 수 있는 문제를 해결하고 데이터 일관성을 유지하는 기법이다.

### 10.1 동시성 문제점

적절한 제어가 없을 경우 다음과 같은 문제가 발생한다.38

- **갱신 분실 (Lost Update):** 두 트랜잭션이 같은 데이터를 동시에 갱신할 때, 한 트랜잭션의 갱신 결과가 다른 트랜잭션에 의해 덮어쓰여지는 현상.
    
- **모순성 (Inconsistency):** 한 트랜잭션이 갱신 중인 데이터를 다른 트랜잭션이 읽어, 일관성 없는 데이터를 얻는 현상.
    
- **연쇄 복귀 (Cascading Rollback):** 한 트랜잭션이 실패하여 롤백될 때, 그 트랜잭션이 갱신한 데이터를 읽은 다른 트랜잭션들도 함께 롤백되어야 하는 현상.45
    

### 10.2 로킹 (Locking) 기법

가장 대표적인 동시성 제어 기법으로, 트랜잭션이 데이터에 접근하기 전에 잠금(Lock)을 요청하여 독점권을 획득하는 방식이다.38

- **로킹 단위 (Locking Granularity):** 잠금의 대상이 되는 데이터 크기(속성, 튜플, 테이블, DB 전체). 단위가 클수록 관리는 쉽지만 병행성(Concurrency)은 낮아진다.
    
- **잠금의 종류:**
    
    - **공유 잠금 (Shared Lock, S-lock):** 데이터를 읽을 수만 있다. 다른 트랜잭션도 공유 잠금을 걸 수 있다.
        
    - **배타 잠금 (Exclusive Lock, X-lock):** 데이터를 읽고 쓸 수 있다. 다른 트랜잭션은 어떠한 잠금도 걸 수 없다.
        
- **2단계 로킹 규약 (2PL, Two-Phase Locking):** 확장 단계(Lock만 수행)와 수축 단계(Unlock만 수행)를 구분하여 직렬 가능성을 보장하는 규약이다. 단, 교착 상태(Deadlock)가 발생할 수 있다.38
    

---

## 11. 데이터베이스 회복 (Recovery)

장애 발생 시 데이터베이스를 장애 발생 이전의 일관된 상태로 복구하는 기법이다.

### 11.1 장애의 유형

- **트랜잭션 장애:** 논리적 오류나 내부 조건에 의한 장애.
    
- **시스템 장애:** 하드웨어 오동작, 정전 등으로 인한 휘발성 메모리 손실.
    
- **미디어 장애:** 디스크 헤드 손상 등으로 인한 비휘발성 저장 장치 손상.46
    

### 11.2 회복 기법

회복의 핵심 원리는 **데이터 중복(Redundancy)**이다. 로그(Log)나 덤프(Dump)를 이용한다.46

#### 로그 기반 회복 (Log-Based Recovery)

모든 변경 연산을 로그 파일에 기록하고 장애 발생 시 이를 참조하여 복구한다.

- **지연 갱신 (Deferred Update):** 트랜잭션이 부분 완료될 때까지 데이터베이스에 갱신을 미루고 로그에만 기록한다. 장애 발생 시 커밋되지 않은 트랜잭션은 무시하면 되므로 **Redo**만 수행하고 Undo는 필요 없다.
    
- **즉시 갱신 (Immediate Update):** 트랜잭션 수행 중에도 데이터를 즉시 데이터베이스에 기록한다. 장애 발생 시 완료된 트랜잭션은 **Redo**, 미완료된 트랜잭션은 **Undo**를 수행한다.46
    

#### 검사 시점 회복 (Checkpoint Recovery)

로그 전체를 검사하는 시간을 줄이기 위해 일정 시간마다 검사 시점(Checkpoint)을 생성한다. 장애 발생 시 가장 최근의 체크포인트 이후의 트랜잭션에 대해서만 회복 작업을 수행하여 효율성을 높인다.46

---

## 12. 데이터베이스 보안 (Database Security)

데이터베이스 보안은 불법적인 데이터 노출, 변경, 파괴로부터 데이터를 보호하는 것이다.48

### 12.1 보안의 3대 유형

1. **물리적 보안 (Physical Security):** 자연 재해나 물리적 침입으로부터 서버와 저장 장치를 보호한다.49
    
2. **권한 보안 (Authorization):** 사용자별로 접근 권한을 부여하고 통제한다.
    
    - **계정 관리:** 사용자 식별 및 인증.
        
    - **권한 부여/취소:** SQL의 `GRANT`와 `REVOKE` 명령어를 사용하여 테이블이나 뷰에 대한 접근 권한(SELECT, INSERT 등)을 제어한다.
        
3. **운영 보안 (Operational Security):** 무결성 제약 조건 등을 통해 사용자의 실수로 인한 데이터 손상을 방지한다.49
    

### 12.2 접근 제어 모델

- **임의 접근 제어 (DAC, Discretionary Access Control):** 객체의 소유자가 접근 권한을 임의로 지정하는 방식. 유연하지만 트로이 목마 공격 등에 취약할 수 있다.
    
- **강제 접근 제어 (MAC, Mandatory Access Control):** 사용자의 보안 등급과 객체의 보안 등급을 비교하여 시스템이 접근 권한을 강제로 제어하는 방식. 군사 및 정보 기관 등 높은 보안이 요구되는 곳에서 사용된다.48
    

---

## 13. 결론

본 보고서에서는 데이터베이스 시스템의 기초 개념부터 아키텍처, 모델링, 정규화, 그리고 트랜잭션 제어와 보안에 이르는 광범위한 주제를 다루었다. 데이터베이스는 단순한 정보 저장소가 아니라, 데이터의 무결성을 보장하고 다수의 사용자가 효율적으로 데이터를 공유할 수 있게 하는 정교한 소프트웨어 시스템이다.

특히 관계형 데이터 모델의 수학적 엄밀성과 정규화 이론은 데이터 중복과 이상 현상을 제거하여 시스템의 안정성을 확보하는 데 필수적이다. 또한, 트랜잭션 관리와 동시성 제어 기법은 복잡한 비즈니스 로직을 처리하는 현대의 애플리케이션 환경에서 데이터의 일관성을 유지하는 핵심 기술이다. 마지막으로, 회복과 보안 기술은 예기치 못한 재해나 악의적인 공격으로부터 조직의 자산을 지키는 최후의 보루 역할을 한다.

데이터 기술이 클라우드 네이티브, 분산 처리, 빅데이터 분석 등으로 확장되는 현 시점에서도, 본 보고서에서 다룬 RDBMS의 핵심 원리들은 여전히 데이터 엔지니어링의 근간을 이루고 있다. 이러한 원리에 대한 깊은 이해는 향후 등장할 새로운 데이터 기술을 습득하고 응용하는 데 있어서도 견고한 토대가 될 것이다.