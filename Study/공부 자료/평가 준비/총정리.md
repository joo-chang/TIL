### 1. 요구사항 관리 (Requirements Management)

프로젝트 진행 과정에서 요구사항이 바르게 이행되고 있는지 확인하고, 변경 사항을 통제 및 관리하는 활동입니다.

- **목표:** 요구사항의 일관성 유지, 변경 비용 최소화, 프로젝트 실패 위험 감소.
    
- **주요 활동:**
    
    1. **협상 및 베이스라인(Baseline) 수립:** 확정된 요구사항에 대해 공식적으로 승인된 기준선(Baseline)을 만듭니다.
        
    2. **추적성(Traceability) 관리:** 요구사항이 설계, 구현, 테스트 단계로 잘 연결되었는지 추적합니다.
        
    3. **변경 관리:** 새로운 요구사항이나 변경 요청을 체계적으로 처리합니다.
        

### 2. 변화하는 요구사항에 대한 이해

소프트웨어 개발에서 요구사항 변경은 **'필연적'**이라는 점을 이해해야 합니다.

- **변경의 원인:**
    
    - 비즈니스 환경 및 법규의 변화
        
    - 사용자의 요구사항 구체화 과정에서의 생각 변화
        
    - 기술적 제약 사항 발견
        
    - 초기 요구사항 정의의 불완전성
        
- **관리 원칙:** 변경을 무조건 막는 것이 아니라, **통제 가능한 절차(Process)**를 통해 반영하여 리스크를 줄여야 합니다.
    

### 3. 실무 요구사항 변경 및 관리 프로세스 (중요)

시험에서 가장 중요한 **변경 관리 절차**입니다. 이 순서와 용어를 기억하세요.

1. **변경 요청 (Change Request):** 사용자나 개발자가 변경 사항을 제기합니다.
    
2. **변경 심사 및 영향 분석 (Impact Analysis):**
    
    - 해당 변경이 일정, 비용, 다른 모듈에 어떤 영향을 미치는지 분석합니다.
        
3. **변경 승인/기각 (Decision Making):**
    
    - **CCB (Change Control Board, 형상 통제 위원회):** 변경 사항을 심의하고 의결하는 조직입니다. 여기서 승인해야만 변경이 진행됩니다.
        
4. **변경 이행 (Implementation):** 소스 코드 및 산출물을 수정합니다.
    
5. **변경 확인 (Verification):** 변경이 제대로 되었는지 테스트하고 베이스라인을 업데이트합니다.
    

### 4. 요구사항 변경 분석 및 반영 도구

요구사항 변경을 체계적으로 관리하기 위해 사용하는 대표적인 도구입니다.

#### ① 요구사항 추적표 (RTM, Requirements Traceability Matrix)

- **개념:** 요구사항 정의서, 설계서, 코드, 테스트 케이스 등을 연결(매핑)하여 표로 만든 문서입니다.
    
- **목적:**
    
    - **추적성 확보:** 특정 요구사항이 어디서 구현되었는지 찾기 쉬움 (순방향 추적).
        
    - **영향도 분석:** 코드가 변경되었을 때 어떤 요구사항에 영향을 주는지 파악 (역방향 추적).
        

#### ② 형상 관리 (SCM, Software Configuration Management)

- **개념:** 소프트웨어 생명주기 동안 발생하는 모든 변경 사항(버전)을 관리하는 활동입니다.
    
- **요구사항과의 관계:** 요구사항 정의서도 형상 관리의 대상(Configuration Item)이 되어 버전 관리를 받아야 합니다.
    
- **주요 기능:** 식별, 통제, 감사, 기록(보고).
    

---

### 📝 시험 대비 핵심 요약 (암기 포인트)

| **용어**                      | **설명**                                   | **핵심 키워드**     |
| --------------------------- | ---------------------------------------- | -------------- |
| **베이스라인 (Baseline)**        | 검토와 승인이 완료되어 변경 시 공식적인 통제 절차가 필요한 시점의 기준 | 기준선, 승인된 버전    |
| **요구사항 추적표 (RTM)**          | 요구사항과 구현 산출물 간의 연결 관계를 표현한 테이블           | 추적성, 연결 관계     |
| **CCB (형상 통제 위원회)**         | 변경 요청을 심사하고 승인/기각을 결정하는 조직               | 의사결정 기구, 승인 권한 |
| **영향 분석 (Impact Analysis)** | 변경이 다른 부분에 미치는 부작용이나 비용을 파악하는 활동         | 비용 산정, 리스크 분석  |

---
---
---

### 1. 객체지향 설계 원칙 (SOLID)

좋은 소프트웨어 설계를 위해 지켜야 할 5가지 원칙입니다. 앞 글자를 따서 SOLID라고 부릅니다. 시험에서는 원칙의 이름과 설명을 연결하는 문제가 자주 나옵니다.

|**이니셜**|**원칙 이름 (한글/영문)**|**핵심 내용 및 암기 키워드**|
|---|---|---|
|**S**|**단일 책임 원칙**<br><br>  <br><br>(Single Responsibility Principle)|• 클래스는 **단 하나의 책임(기능)**만 가져야 한다.<br><br>  <br><br>• 변경의 이유는 오직 하나여야 한다.|
|**O**|**개방-폐쇄 원칙**<br><br>  <br><br>(Open-Closed Principle)|• **확장에는 열려** 있고, **수정에는 닫혀** 있어야 한다.<br><br>  <br><br>• 기존 코드를 건드리지 않고 기능을 추가할 수 있어야 함.|
|**L**|**리스코프 치환 원칙**<br><br>  <br><br>(Liskov Substitution Principle)|• **자식 클래스**는 언제나 **부모 클래스**를 대체할 수 있어야 한다.<br><br>  <br><br>• 상속의 일관성 유지.|
|**I**|**인터페이스 분리 원칙**<br><br>  <br><br>(Interface Segregation Principle)|• 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.<br><br>  <br><br>• 하나의 거대한 인터페이스보다 **여러 개의 구체적인 인터페이스**가 낫다.|
|**D**|**의존 역전 원칙**<br><br>  <br><br>(Dependency Inversion Principle)|• 구체적인 클래스보다 **추상화(인터페이스, 추상클래스)**에 의존해야 한다.<br><br>  <br><br>• "변하기 쉬운 것에 의존하지 마라."|

---

### 2. 디자인 패턴 (Design Pattern)

소프트웨어 설계에서 자주 발생하는 문제에 대해 미리 만들어진 해결책(모범 답안)입니다. **GoF(Gang of Four) 디자인 패턴** 23가지의 **분류(생성, 구조, 행위)**를 묻는 문제가 가장 많이 나옵니다.

#### ① 생성 패턴 (Creational Patterns) - 5개

_객체의 **생성 방식**을 결정하는 패턴_

- **싱글톤 (Singleton):** 클래스의 인스턴스가 딱 **하나**만 생성되도록 보장 (메모리 낭비 방지).
    
- **팩토리 메서드 (Factory Method):** 객체 생성을 서브 클래스에서 처리하도록 캡슐화.
    
- **추상 팩토리 (Abstract Factory):** 서로 연관된 객체들의 묶음(그룹)을 생성하는 인터페이스 제공.
    
- **빌더 (Builder):** 복잡한 인스턴스를 조립하여 생성 (생성 과정 분리).
    
- **프로토타입 (Prototype):** 원본 객체를 복제(Clone)하여 객체 생성.
    

#### ② 구조 패턴 (Structural Patterns) - 7개

_클래스나 객체를 **조합**하여 더 큰 구조를 만드는 패턴_

- **어댑터 (Adapter):** 호환되지 않는 인터페이스를 변환하여 함께 동작하게 함 (변환기 역할).
    
- **데코레이터 (Decorator):** 객체에 기능을 동적으로 추가 (기본 기능 + 장식).
    
- **파사드 (Facade):** 복잡한 시스템에 대해 단순한 인터페이스 제공 (건물의 정면).
    
- **프록시 (Proxy):** 실제 객체 대신 대리자가 처리 (접근 제어, 로깅 등).
    
- **브리지 (Bridge), 컴포지트 (Composite), 플라이웨이트 (Flyweight)**
    

#### ③ 행위 패턴 (Behavioral Patterns) - 11개

_객체 간의 **책임 분배**와 **알고리즘** 관련 패턴_

- **옵저버 (Observer):** 한 객체의 상태가 바뀌면, 의존하는 다른 객체들에 알림을 보냄 (일대다 의존).
    
- **전략 (Strategy):** 알고리즘을 클래스로 캡슐화하여 교체 가능하게 함 (행위 교체).
    
- **템플릿 메서드 (Template Method):** 상위 클래스에서 골격을 정의하고, 하위 클래스에서 구체적 내용을 구현.
    
- **커맨드 (Command), 이터레이터 (Iterator), 스테이트 (State), 비지터 (Visitor), 미디에이터 (Mediator), 메멘토 (Memento), 인터프리터 (Interpreter), 책임 연쇄 (Chain of Responsibility)**
    

---

### 3. 리팩토링 (Refactoring)

소프트웨어의 기능을 변경하지 않으면서 내부 구조를 개선하는 활동입니다.

- **정의:** 소프트웨어의 **외부 동작(기능)은 그대로 유지**한 채, **내부 구조(코드)를 개선**하여 가독성을 높이고 유지보수를 쉽게 만드는 행위.
    
- **목적:**
    
    - 코드의 가독성 향상 (이해하기 쉽게).
        
    - 유지보수성 향상 (버그 수정 및 기능 추가 용이).
        
    - 소프트웨어 품질 향상.
        
- **주의사항:** 리팩토링 중에는 새로운 기능을 추가하지 않는다.
    
- **코드 스멜 (Code Smell):** 리팩토링이 필요한, 코드가 지저분하거나 잠재적인 문제가 있는 상태 (예: 너무 긴 메서드, 중복 코드).
    

---

### 📝 시험 대비 핵심 요약 (암기 팁)

1. **SOLID:** 각 알파벳이 무엇의 약자인지, 그리고 설명에 "확장에는 열려 있고(Open)..." 같은 키워드가 나오면 바로 **OCP**를 찍을 수 있어야 합니다.
    
2. **디자인 패턴 분류:**
    
    - **생성:** 추상팩토리, 빌더, 팩토리메서드, 프로토타입, 싱글톤 (앞글자만 따서 암기: **추빌팩프싱**)
        
    - **구조:** 어댑터, 브리지, 컴포지트, 데코레이터, 파사드, 플라이웨이트, 프록시 (**어브컴데파플프**)
        
    - 나머지는 다 **행위** 패턴입니다. (전략, 옵저버, 템플릿 메서드 등이 중요)

---
---
---
### 1. 코드 리뷰 및 품질 메트릭 (Code Review & Quality Metrics)

#### ① 코드 리뷰 (Code Review)

소스 코드를 개발자가 아닌 다른 사람이 점검하여 버그를 찾고 품질을 높이는 활동입니다. **정적 분석(Static Analysis)**의 일종입니다.

- **목적:** 결함 조기 발견, 지식 공유, 코딩 표준 준수 확인.
    
- **주요 기법 (시험 빈출):**
    
    - **동료 검토 (Peer Review):** 2~3명이 진행하는 리뷰.
        
    - **워크스루 (Walkthrough):** 회의록 없이 진행하는 비공식적 검토. **작성자(개발자)**가 주도하여 진행.
        
    - **인스펙션 (Inspection):** 가장 공식적이고 엄격한 검토. **중재자(Moderator)**가 주도하며, 체크리스트 등을 활용. (Fagan Inspection이라고도 함)
        

#### ② 품질 메트릭 (소프트웨어 복잡도 지표)

코드의 복잡도를 정량적인 숫자로 측정하는 것입니다. **맥케이브(McCabe)의 회전 복잡도**가 계산 문제로 가장 자주 나옵니다.

- **맥케이브 회전(순환) 복잡도 (Cyclomatic Complexity):**
    
    - 제어 흐름의 복잡한 정도를 나타냄.
        
    - **공식:** $V(G) = E - N + 2$
        
        - $E$ (Edge, 선의 수): 화살표
            
        - $N$ (Node, 노드의 수): 동그라미
            
- **할스테드(Halstead) 복잡도:** 연산자(Operator)와 피연산자(Operand)의 개수를 세어 측정.
    
- **ISO/IEC 9126 품질 특성 (암기 필수):**
    
    - **기능성, 신뢰성, 사용성, 효율성, 유지보수성, 이식성** (앞글자 따서: **기신사효유이**)
        

---

### 2. 페어 프로그래밍 (Pair Programming)

애자일(Agile) 방법론 중 **XP(eXtreme Programming)**의 주요 실천 항목(Practice)입니다.

- **정의:** 하나의 컴퓨터에서 **두 명의 개발자**가 함께 작업하는 방식입니다.
    
- **역할:**
    
    - **드라이버 (Driver):** 키보드를 잡고 코드를 작성하는 사람.
        
    - **내비게이터 (Navigator):** 전체적인 구조를 생각하고, 코드를 검토하며 전략을 제시하는 사람.
        
- **장점:** 코드 품질 향상, 업무 지식 공유, 개발 시간 단축(결함 감소로 인해).
    

---

### 3. CI/CD (지속적 통합 / 지속적 배포)

DevOps(개발+운영) 환경의 핵심 프로세스입니다.

![CI CD pipeline diagram 이미지](https://encrypted-tbn3.gstatic.com/licensed-image?q=tbn:ANd9GcTG5O9a5FHfvqUZapUAHVnS9u3vi3jMJFVLv2hrew9nchdns_a73wGX619BqT7-kNp2CKVbnS7WP9NEXEbG1T7Oq_ssq5985QpsoBVQqhJJ1WpVnWU)

Shutterstock

#### ① CI (Continuous Integration, 지속적 통합)

- **개념:** 개발자들이 작성한 코드를 **하루에 여러 번** 중앙 저장소(Git 등)에 병합하고, **자동화된 빌드 및 테스트**를 수행하는 것입니다.
    
- **핵심:** "통합 지옥(Integration Hell)"을 방지하고 버그를 조기에 발견.
    
- **도구:** Jenkins, Travis CI, GitHub Actions, Bamboo 등.
    

#### ② CD (Continuous Delivery/Deployment, 지속적 제공/배포)

- **개념:** CI를 통과한 코드를 실제 사용자 환경(Production)까지 자동으로 릴리즈하는 것입니다.
    
- **단계:**
    
    - **지속적 제공 (Delivery):** 배포 준비 완료 단계까지 자동화 (배포 버튼은 사람이 누름).
        
    - **지속적 배포 (Deployment):** 프로덕션 배포까지 사람의 개입 없이 완전 자동화.
        

---

### 📝 시험 대비 핵심 요약 (이것만은 꼭!)

| **구분**       | **개념**           | **핵심 키워드/암기팁**                        |
| ------------ | ---------------- | ------------------------------------- |
| **인스펙션**     | 가장 엄격한 코드 리뷰     | **중재자(Moderator)**, 공식적, 체크리스트        |
| **워크스루**     | 비공식적 코드 리뷰       | **작성자(Author)** 주도, 비공식               |
| **회전 복잡도**   | 복잡도 계산 공식        | **$E - N + 2$** (선 - 점 + 2)           |
| **ISO 9126** | 품질 특성 6가지        | **기신사효유이** (기능, 신뢰, 사용, 효율, 유지보수, 이식) |
| **Jenkins**  | 대표적인 CI 도구       | JAVA 기반, 오픈소스, 자동화                    |
| **XP**       | 페어 프로그래밍이 속한 방법론 | 애자일, **Driver & Navigator**           |

---
---
---
### 1. 소프트웨어 프로세스 개요 및 기본 단계

소프트웨어 생명주기(SDLC, Software Development Life Cycle)라고도 하며, 소프트웨어를 개발하기 위해 정의된 절차입니다.

#### 기본 4단계 (순서 중요)

시험에서는 각 단계의 산출물과 활동을 묻습니다.

1. **요구사항 분석 (Requirements):**
    
    - "무엇(What)"을 만들지 결정.
        
    - 기능적 요구사항(기능)과 비기능적 요구사항(성능, 보안 등) 정의.
        
    - 산출물: 요구사항 명세서.
        
2. **설계 (Design):**
    
    - "어떻게(How)" 만들지 결정.
        
    - **기본(아키텍처) 설계:** 시스템 구조, 인터페이스, DB 설계.
        
    - **상세 설계:** 모듈 내부 로직, 자료 구조 설계.
        
3. **구현 (Implementation):**
    
    - 실제 프로그래밍(코딩) 단계. 표준과 스타일 가이드를 준수.
        
4. **테스트 (Testing):**
    
    - 단위 테스트(모듈) → 통합 테스트(인터페이스) → 시스템 테스트(전체) → 인수 테스트(사용자 확인) 순서로 진행.
        
    - **V-모델:** 개발 단계와 테스트 단계가 1:1로 매핑되는 모델.
        

---

### 2. 전통적 프로세스 모델 (고전적 생명주기)

각 모델의 **가장 큰 특징(키워드)**을 암기해야 합니다.

|**모델**|**특징 및 핵심 키워드**|**장단점**|
|---|---|---|
|**폭포수 모델**<br><br>  <br><br>(Waterfall)|• **순차적** 접근<br><br>  <br><br>• 이전 단계가 끝나야 다음 단계로 넘어감<br><br>  <br><br>• **문서 중심**|• 이해가 쉽고 관리가 편함<br><br>  <br><br>• **변경이 어려움**, 개발 후반에야 결과 확인 가능|
|**프로토타입 모델**<br><br>  <br><br>(Prototyping)|• **시제품(Prototype)**을 만들어 보여줌<br><br>  <br><br>• 사용자의 요구사항을 명확히 파악하기 위함|• 요구사항 도출 용이<br><br>  <br><br>• 시제품 폐기 비용 발생|
|**나선형 모델**<br><br>  <br><br>(Spiral)|• **위험 분석 (Risk Analysis)**<br><br>  <br><br>• 반복적인 점진적 개발<br><br>  <br><br>• 보헴(Boehm)이 제안|• 대규모 시스템에 적합<br><br>  <br><br>• **위험 관리**에 중점|
|**RAD 모델**<br><br>  <br><br>(Rapid Application Development)|• **CASE 도구** 활용<br><br>  <br><br>• 짧은 기간 내 개발 목표|• 빠른 개발<br><br>  <br><br>• 기술적 위험이 적은 경우 사용|

---

### 3. 애자일 (Agile) 방법론

전통적인 폭포수 모델의 단점(문서 위주, 변화 대응 어려움)을 극복하기 위해 등장했습니다.

- **핵심 가치 (애자일 선언문):**
    
    - 절차와 도구보다는 **개인과 상호작용**
        
    - 포괄적인 문서보다는 **작동하는 소프트웨어**
        
    - 계약 협상보다는 **고객과의 협력**
        
    - 계획을 따르기보다는 **변화에 대응**
        

#### ① 스크럼 (Scrum)

애자일 방법론 중 가장 널리 쓰이며 시험 출제 빈도가 매우 높습니다. 팀 중심의 개발 방식입니다.

- **주요 역할 (Role):**
    
    - **제품 책임자 (PO, Product Owner):** 백로그(할 일 목록)를 작성 및 관리, 우선순위 지정. (비즈니스 관점)
        
    - **스크럼 마스터 (Scrum Master):** 팀이 스크럼을 잘 수행하도록 돕는 가이드(조력자). 장애물 제거.
        
    - **스크럼 팀:** 실제 개발을 수행하는 팀원.
        
- **주요 활동 (Event):**
    
    - **스프린트 (Sprint):** 2~4주 기간의 반복적인 개발 주기.
        
    - **일일 스크럼 (Daily Scrum):** 매일 15분, 서서 진행하는 짧은 회의 (어제 한 일, 오늘 할 일, 문제점 공유).
        
- **주요 산출물 (Artifact):**
    
    - **백로그 (Backlog):** 요구사항(User Story) 목록.
        
    - **번다운 차트 (Burn-down Chart):** 남은 작업량을 그래프로 보여주어 진행 상황을 시각화.
        

#### ② XP (eXtreme Programming)

개발자 중심의 실천 항목을 강조하는 애자일 기법입니다.

- **5가지 핵심 가치:** **용기, 단순성, 의사소통, 피드백, 존중** (암기: **용단의피존**)
    
- **주요 실천 사항:** 짝 프로그래밍(Pair Programming), TDD(테스트 주도 개발), 리팩토링(Refactoring).
    

---

### 📝 시험 대비 핵심 요약 (암기 팁)

1. **나선형 모델 = 위험 분석:** 문제 지문에 "위험을 관리한다", "보헴", "반복" 나오면 무조건 **나선형**.
    
2. **폭포수 모델 = 문서, 순차적:** "되돌아갈 수 없다", "고전적", "문서화" 나오면 **폭포수**.
    
3. **스크럼 마스터 vs 제품 책임자:**
    
    - 우선순위 정하고 "무엇"을 만들지 결정 = **PO (Product Owner)**
        
    - 팀을 돕고 규칙을 지키게 함 = **스크럼 마스터**
        
4. **번다운 차트:** "우상향"이 아니라 작업이 줄어드는 **"우하향"** 그래프입니다.

---
---
---
### 1. 요구사항 개발 프로세스 (순서 중요)

요구사항 관리는 아래의 순환적인 절차를 따릅니다.

> **도출(Elicitation) → 분석(Analysis) → 명세(Specification) → 확인/검증(Verification)**

### 2. 단계별 핵심 내용

#### ① 요구사항 도출 (Elicitation)

소프트웨어가 해결해야 할 문제를 이해하고, 고객(이해관계자)으로부터 **요구사항을 수집**하는 단계입니다.

- **주요 기법:**
    
    - **인터뷰 (Interview):** 1:1 대화.
        
    - **브레인스토밍 (Brainstorming):** 비판 없이 자유롭게 아이디어를 냄.
        
    - **델파이 기법 (Delphi Method):** **전문가**들의 의견을 익명으로 수렴하여 합의를 도출.
        
    - **롤 플레잉, 워크숍, 설문조사**
        

#### ② 요구사항 분석 (Analysis) ★ (가장 중요)

도출된 요구사항의 타당성을 조사하고, 불명확한 부분을 걸러내어 체계화하는 단계입니다.

- **기능 vs 비기능 요구사항 구분 (시험 출제 1순위):**
    

|**구분**|**설명**|**예시**|
|---|---|---|
|**기능적 요구사항**<br><br>  <br><br>(Functional)|• 시스템이 **"무엇(What)"**을 하는가?<br><br>  <br><br>• 입력, 출력, 처리 과정, 데이터 저장 등 실제 동작|• 사용자는 아이디로 로그인할 수 있다.<br><br>  <br><br>• 결제 버튼을 누르면 승인 처리가 된다.<br><br>  <br><br>• 성적을 조회할 수 있다.|
|**비기능적 요구사항**<br><br>  <br><br>(Non-Functional)|• 시스템의 **"품질"**이나 **"제약사항"**<br><br>  <br><br>• 성능, 보안, 신뢰성, 유지보수성, 사용성 등|• 응답 시간은 **3초 이내**여야 한다. (성능)<br><br>  <br><br>• 24시간 가동되어야 한다. (신뢰성)<br><br>  <br><br>• 자바 언어를 사용해야 한다. (제약사항)|

- **분석 도구:** DFD(자료 흐름도), DD(자료 사전), UML(유스케이스 등).
    

#### ③ 요구사항 명세 (Specification)

분석된 요구사항을 바탕으로 **승인될 수 있는 문서(SRS)**로 정리하는 단계입니다.

- **특징:** 명확성, 완전성, 검증 가능성, 수정 용이성 등을 갖춰야 합니다.
    
- **산출물:** **요구사항 명세서 (SRS, Software Requirements Specification)**. 이는 개발자와 사용자 간의 **계약서** 역할을 합니다.
    

#### ④ 요구사항 검증/확인 (Verification)

명세서가 정확하게 작성되었는지 검토하는 단계입니다. 개발 후에 문제가 발견되면 수정 비용이 막대하므로, 설계 전에 검증해야 합니다.

- **주요 기법:**
    
    - **동료 검토 (Peer Review)**
        
    - **워크스루, 인스펙션** (앞서 정리한 내용 참조)
        
    - **프로토타이핑:** 견본을 만들어 직접 확인.
        
    - **CASE 도구 활용:** 일관성 및 완전성 자동 분석.
        

---

### 3. 요구사항의 중요성 (비용 곡선)

- **요구사항 단계의 오류 수정 비용:** 개발 초기(요구사항)에 발견하면 수정 비용이 적지만, 유지보수 단계에서 발견하면 비용이 기하급수적으로 증가합니다. (브룩스의 법칙 등과 연관)
    
- 따라서 **명확한 요구사항 정의**가 프로젝트 성공의 핵심입니다.
    

---

### 📝 시험 대비 핵심 요약 (암기 포인트)

1. **순서 암기:** **도 → 분 → 명 → 확** (도출, 분석, 명세, 확인)
    
2. **기능 vs 비기능 구별:**
    
    - "로그인 기능", "검색 기능" → **기능적**
        
    - "속도", "보안(암호화)", "서버 OS 종류(제약)", "신뢰성" → **비기능적**
        
3. **전문가 의견 수렴:** **델파이(Delphi)** 기법.
    
4. **베이스라인:** 요구사항 명세서가 승인되면 **베이스라인(기준선)**이 설정되어, 이후 변경은 통제 절차(CCB)를 따라야 합니다


---
---
---
### 1. UML의 개요

소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용하는 **표준화된 범용 모델링 언어**입니다. (방법론이나 프로세스가 아님)

- **구성 요소:** 사물(Things), 관계(Relationships), 다이어그램(Diagrams)
    

---

### 2. UML 다이어그램의 분류 (★시험 최다 빈출)

시험에서는 **"다음 중 정적(구조) 다이어그램이 아닌 것은?"** 형태로 자주 나옵니다. 반드시 구분해서 암기해야 합니다.

#### ① 구조적 다이어그램 (Structural / Static) - 6개

_시스템의 **정적인 구조**(클래스, 객체, 컴포넌트 등)를 표현_

|**다이어그램**|**설명**|
|---|---|
|**클래스 (Class)**|시스템의 구조를 가장 잘 보여주는 대표적인 다이어그램. 클래스 간의 관계 표현.|
|**객체 (Object)**|특정 시점의 객체(인스턴스) 간의 관계 표현. (럼바우 객체 모델링과 연관)|
|**컴포넌트 (Component)**|실제 구현 모듈(컴포넌트) 간의 의존 관계 표현.|
|**배치 (Deployment)**|물리적인 하드웨어(서버, 노드)와 소프트웨어의 배치 관계 표현.|
|**패키지 (Package)**|요소들을 그룹화한 패키지 간의 의존 관계 표현.|
|**복합체 구조 (Composite Structure)**|클래스나 컴포넌트의 내부 구조를 표현.|

#### ② 행위 다이어그램 (Behavioral / Dynamic) - 7개

_시스템의 **동적인 동작**(시간의 흐름, 상태 변화)을 표현_

|**다이어그램**|**설명**|
|---|---|
|**유스케이스 (Use Case)**|**사용자(Actor)의 관점**에서 시스템의 기능을 표현. (요구사항 분석 시 사용)|
|**시퀀스 (Sequence)**|객체 간 주고받는 **메시지**를 **시간의 흐름**에 따라 표현.|
|**커뮤니케이션 (Communication)**|시퀀스와 비슷하나, 객체 간의 **연관 관계(네트워크 구조)**를 강조.|
|**상태 (State)**|객체의 상태가 이벤트에 의해 어떻게 **변화**하는지 표현.|
|**활동 (Activity)**|로직의 처리 흐름(순서)을 순서도(Flowchart)처럼 표현.|
|**타이밍 (Timing)**|시간 제약을 중점적으로 표현.|
|**상호작용 개요 (Interaction Overview)**|활동 다이어그램과 시퀀스 다이어그램을 혼합.|

---

### 3. 클래스 간의 관계 (Relationships) (★모양 암기 필수)

실기 시험에서 그림을 보고 무슨 관계인지 맞추거나, 화살표를 그리는 문제가 나옵니다.

![UML class diagram relationships symbols 이미지](https://encrypted-tbn2.gstatic.com/licensed-image?q=tbn:ANd9GcRDha9MGYr44sM7iVWXn-fS8eHxuEXjU0M9aZh7gO0504ViteCHVUEyKzBJuRGjxGfTDSgsgVXCiTc15FNjNAm2ELVv8hnO3slr--KHOdJKLh6pRJk)

Getty Images

|**관계 (Terms)**|**기호/선 모양**|**설명**|
|---|---|---|
|**일반화**<br><br>  <br><br>(Generalization)|**실선 + 빈 세모**<br><br>  <br><br>(―▷)|**상속(Inheritance)** 관계. "is-a" 관계.<br><br>  <br><br>(예: 사원 ← 정규직)|
|**실체화**<br><br>  <br><br>(Realization)|**점선 + 빈 세모**<br><br>  <br><br>(---▷)|**인터페이스**를 실제 클래스로 구현. 추상 메서드 오버라이딩.|
|**의존**<br><br>  <br><br>(Dependency)|**점선 + 화살표**<br><br>  <br><br>(--->)|한 클래스가 다른 클래스를 **잠깐 사용**하는 관계.<br><br>  <br><br>(메서드 파라미터로 이용 등)|
|**연관**<br><br>  <br><br>(Association)|**실선**<br><br>  <br><br>(―)|클래스 간에 **서로 알고 있는** 관계.<br><br>  <br><br>(멤버 변수로 참조 등)|
|**집합**<br><br>  <br><br>(Aggregation)|**실선 + 빈 마름모**<br><br>  <br><br>(◇―)|**전체-부분** 관계. **약한 결합**.<br><br>  <br><br>전체가 사라져도 부분은 남음. (컴퓨터 ◇― 모니터)|
|**합성**<br><br>  <br><br>(Composition)|**실선 + 꽉 찬 마름모**<br><br>  <br><br>(◆―)|**전체-부분** 관계. **강한 결합**.<br><br>  <br><br>전체가 사라지면 부분도 사라짐. (생명주기 공유)|

---

### 4. 주요 다이어그램 세부 내용

#### ① 클래스 다이어그램 - 접근 제어자 (Access Modifier)

클래스 내부 속성/메서드 앞에 붙는 기호입니다.

- **`-` (Private):** 클래스 내부에서만 접근 가능.
    
- **`+` (Public):** 외부의 모든 클래스에서 접근 가능.
    
- **`#` (Protected):** 동일 패키지 + 상속 관계에서 접근 가능.
    
- **`~` (Package/Default):** 동일 패키지 내에서만 접근 가능.
    

#### ② 유스케이스 다이어그램 - 관계

- **연관 (Association):** 액터와 유스케이스 간의 상호작용 (실선).
    
- **포함 (Include):** `<<include>>` 점선 화살표. 반드시 실행되어야 하는 공통 기능. (예: 로그인)
    
- **확장 (Extend):** `<<extend>>` 점선 화살표. 특정 조건에서만 실행되는 추가 기능.
    

#### ③ 시퀀스 다이어그램 - 구성 요소

- **액터 (Actor)**
    
- **객체 (Object)**
    
- **생명선 (Lifeline):** 객체 아래로 내려오는 점선.
    
- **활성 상자 (Activation Box):** 객체가 실제 동작 중임을 나타내는 직사각형 막대.
    
- **메시지 (Message):** 객체 간 상호작용 (실선/점선 화살표).
    

---

### 📝 시험 대비 핵심 요약 (암기 팁)

1. **다이어그램 분류 암기:**
    
    - **정적(구조):** **클/객/컴/배/패/복** (클래스, 객체, 컴포넌트, 배치, 패키지, 복합체)
        
    - **동적(행위):** 나머지는 다 동적입니다. (유스케이스, 시퀀스, 상태, 활동 등)
        
2. **화살표 모양:**
    
    - **빈 세모:** 상속(일반화) 아니면 인터페이스(실체화).
        
    - **마름모:** 집합 아니면 합성 (전체-부분 관계).
        
        - **꽉 찬 마름모(◆):** 아주 강력한 관계 (합성, Composition).
            
3. **스테레오 타입:** `<< >>` (길러멧) 기호를 사용하여 UML의 기본 기능을 확장하는 것. (예: `<<interface>>`, `<<include>>`)

---
---
---
### 1. Verification(검증) vs Validation(확인)

비슷해 보이지만 시험에서는 명확히 구분해야 합니다. **주체**와 **관점**이 다릅니다.

|**구분**|**영어/한글**|**관점**|**핵심 질문 (Barry Boehm)**|**특징**|
|---|---|---|---|---|
|**검증**|**Verification**|**개발자** 관점|"Are we building the product **RIGHT**?"<br><br>  <br><br>(제품을 올바르게 만들고 있는가?)|• 명세서대로 만들어졌는지 점검<br><br>  <br><br>• 정적 테스트(리뷰, 인스펙션) 위주|
|**확인**|**Validation**|**사용자** 관점|"Are we building the **RIGHT** product?"<br><br>  <br><br>(올바른 제품을 만들고 있는가?)|• 고객의 실제 요구사항 충족 여부<br><br>  <br><br>• 실행(Dynamic) 테스트 위주|

---

### 2. 애플리케이션 테스트 단계 (V-모델)

개발 단계에 대응하여 테스트가 진행됩니다. **단위 → 통합 → 시스템 → 인수** 순서를 기억하세요.

![V-model software development testing levels 이미지](https://encrypted-tbn2.gstatic.com/licensed-image?q=tbn:ANd9GcSZj0ltnW1Dzvbi0q2SfJi4Dct0kZrWFdf838UpfVCvGPLbbq6ZB2QjhHjWtRG4xNv43W3rBUzNxPZ81jSeD6RES3tjyJuo9qJrINuawt1_rqEHZRs)

Shutterstock

#### ① 단위 테스트 (Unit Test)

- **대상:** 모듈, 컴포넌트 (최소 단위).
    
- **특징:** 주로 개발자가 수행하며, **화이트박스 테스트** 기법을 사용합니다.
    
- **도구:** JUnit, CppUnit, xUnit 등.
    

#### ② 통합 테스트 (Integration Test) ★(빈출)

- **대상:** 모듈 간의 **인터페이스** 연동 확인.
    
- **방식 (시험 출제 포인트):**
    
    - **하향식 (Top-down):** 위에서 아래로 통합. **스텁(Stub)** 필요.
        
        - _암기:_ 하향**스** (하향식은 스텁)
            
    - **상향식 (Bottom-up):** 아래에서 위로 통합. **드라이버(Driver)** 필요.
        
        - _암기:_ 상향**드** (상향식은 드라이버)
            
    - **빅뱅 (Big Bang):** 한꺼번에 결합. (소규모에 적합)
        

#### ③ 시스템 테스트 (System Test)

- **대상:** 전체 시스템.
    
- **특징:** 기능적 요구사항뿐만 아니라 **비기능적 요구사항**(성능, 보안, 회복 등)도 점검합니다.
    

#### ④ 인수 테스트 (Acceptance Test)

- **대상:** 최종 사용자(Client).
    
- **종류:**
    
    - **알파(Alpha) 테스트:** 개발자의 장소에서 사용자가 테스트 (개발자 입회).
        
    - **베타(Beta) 테스트:** 실제 환경에서 사용자 혼자 테스트 (개발자 없이).
        

---

### 3. 화이트박스 vs 블랙박스 테스트 (★종류 구분 필수)

시험에서 "다음 중 블랙박스 테스트 기법이 아닌 것은?" 형태로 자주 나옵니다.

#### ① 화이트박스 테스트 (White Box)

- **개념:** 소스 **코드의 내부 로직**을 보면서 테스트합니다. (투명한 상자)
    
- **목적:** 내부 논리 흐름, 제어 구조 확인.
    
- **주요 기법 (종류):**
    
    - **기초 경로 검사 (Basis Path Testing):** 맥케이브가 제안, 대표적인 화이트박스 기법.
        
    - **제어 구조 검사:** 조건 검사(Condition), 루프 검사(Loop), 데이터 흐름 검사(Data Flow).
        
    - **커버리지 (Coverage):** 구문(Statement), 결정(Decision/Branch), 조건(Condition) 커버리지 등.
        

#### ② 블랙박스 테스트 (Black Box)

- **개념:** 내부 코드는 보지 않고, **입력과 출력(기능)**만 확인합니다. (불투명한 상자)
    
- **목적:** 기능이 제대로 작동하는지 확인.
    
- **주요 기법 (종류 - 암기 필수):**
    
    - **동치 분할 검사 (Equivalence Partitioning):** 입력값을 유효값/무효값 그룹으로 나누어 대표값 하나씩 테스트.
        
    - **경계값 분석 (Boundary Value Analysis):** 오류가 발생하기 쉬운 **경계(최댓값, 최솟값)**를 테스트.
        
    - **원인-효과 그래프 (Cause-Effect Graph):** 입력(원인)과 출력(효과)의 관계를 그래프로 표현.
        
    - **오류 예측 (Error Guessing):** 경험과 감각으로 오류를 추정.
        
    - **비교 검사 (Comparison):** 여러 버전의 프로그램에 동일한 입력을 주어 결과 비교.
        

---

### 📝 시험 대비 핵심 요약 (암기 팁)

1. **스텁(Stub) vs 드라이버(Driver):**
    
    - **스텁:** 하향식(Top-Down) 통합 시, 아직 안 만든 **하위 모듈**을 대신하는 가짜 모듈.
        
    - **드라이버:** 상향식(Bottom-Up) 통합 시, 하위 모듈을 호출해 줄 **상위 모듈** 역할을 하는 가짜 모듈.
        
2. **화이트 vs 블랙 구분:**
    
    - 코드, 논리, 경로, 커버리지 → **화이트박스**
        
    - 경계값, 동치 분할, 기능 위주 → **블랙박스**
        
3. **알파 vs 베타:**
    
    - 개발자 앞에서 하면 **알파**, 개발자 없이 집에서 하면 **베타**.

---
---
---

### 1. 데이터베이스의 개념

단순한 데이터의 집합이 아닌, 특정 조직의 업무를 수행하기 위해 체계적으로 모아놓은 것입니다.

#### ① 데이터베이스의 정의 (암기: 통합/저장/운영/공용)

시험에서는 아래 4가지 키워드 중 하나를 빈칸으로 뚫거나 정의를 묻습니다.

- **통합 데이터 (Integrated Data):** 중복을 최소화한 데이터의 모임.
    
- **저장 데이터 (Stored Data):** 컴퓨터가 접근 가능한 매체에 저장됨.
    
- **운영 데이터 (Operational Data):** 조직의 고유 업무를 수행하는 데 필수적인 데이터.
    
- **공용 데이터 (Shared Data):** 여러 시스템과 사용자가 공동으로 소유하고 사용.
    

#### ② 데이터베이스의 특징 (암기: 실/계/동/내)

- **실시간 접근성 (Real-time Accessibility):** 질의에 대해 즉시 응답.
    
- **계속적인 진화 (Continuous Evolution):** 삽입, 삭제, 갱신을 통해 항상 최신 상태 유지.
    
- **동시 공유 (Concurrent Sharing):** 여러 사용자가 동시에 접근 가능.
    
- **내용에 의한 참조 (Content Reference):** 주소(Address)가 아닌 **값(Data Value)**으로 데이터를 찾음.
    

---

### 2. 데이터베이스 관리 시스템 (DBMS)

#### ① DBMS의 필수 기능 3가지 (암기: 정/조/제)

DBMS가 갖춰야 할 핵심 기능입니다.

1. **정의 (Definition):** 데이터의 타입, 구조, 제약조건을 명시.
    
2. **조작 (Manipulation):** 데이터 검색, 삽입, 삭제, 갱신 처리 (사용자와의 인터페이스).
    
3. **제어 (Control):** 무결성 유지, 보안, 권한 검사, 병행 제어.
    

#### ② DBMS의 장점

- 데이터의 **중복 최소화** 및 **일관성/무결성** 유지.
    
- 데이터의 **보안** 보장 및 **표준화** 가능.
    

---

### 3. 데이터베이스 시스템 구성 요소

#### ① 스키마(Schema)와 3층 구조

데이터베이스의 구조와 제약조건을 정의한 것입니다. **3단계 구조**가 매우 중요합니다.

|**종류**|**설명**|**관점**|
|---|---|---|
|**외부 스키마**<br><br>  <br><br>(External)|사용자나 응용 프로그래머가 보는 개인적 DB 구조|**서브 스키마**, 사용자 관점|
|**개념 스키마**<br><br>  <br><br>(Conceptual)|DB 전체의 논리적 구조, 모든 응용 프로그램이 공유|**전체 뷰**, 범기관적 관점|
|**내부 스키마**<br><br>  <br><br>(Internal)|실제 데이터가 저장되는 물리적 구조|**저장 장치** 관점|

#### ② 데이터 독립성

- **논리적 독립성:** 개념 스키마가 변해도 외부 스키마에 영향을 주지 않음.
    
- **물리적 독립성:** 내부 스키마(저장 장치)가 변해도 개념 스키마에 영향을 주지 않음.
    

#### ③ 데이터 사전 (Data Dictionary)

- 데이터베이스에 저장된 모든 데이터 개체들에 대한 정보(**메타 데이터**)를 유지/관리하는 시스템 데이터베이스.
    
- **시스템 카탈로그**라고도 함.
    
- 시스템이 관리하며, 사용자는 **검색(SELECT)**만 가능하고 직접 수정은 불가능.
    

---

### 4. 데이터 모델링

#### ① ER 모델 (Entity-Relationship Model)

피터 첸(Peter Chen)이 제안한 모델로, 현실 세계를 개체와 관계로 표현합니다.

- **기호 암기:**
    
    - **사각형 (□):** 개체 (Entity)
        
    - **마름모 (◇):** 관계 (Relationship)
        
    - **타원 (○):** 속성 (Attribute)
        
    - **밑줄 타원:** 기본키 (Primary Key)
        

#### ② 데이터 모델의 분류

- **계층형 (Hierarchical):** **트리(Tree)** 구조. 1:N 관계. 상하 종속적.
    
- **망형 (Network):** **그래프(Graph)** 구조. N:M 관계. 복잡함.
    

---

### 5. 관계형 데이터 모델 (Relational Data Model)

현재 가장 널리 쓰이는 표(Table) 형태의 모델입니다.

#### ① 용어 정리 (★빈출)

- **릴레이션 (Relation):** 테이블 그 자체.
    
- **튜플 (Tuple):** 행(Row). **기수(Cardinality)**는 튜플의 개수.
    
- **속성 (Attribute):** 열(Column). **차수(Degree)**는 속성의 개수.
    
- **도메인 (Domain):** 하나의 속성이 가질 수 있는 원자값들의 집합 (예: 성별의 도메인은 '남', '여').
    

#### ② 릴레이션의 특징

- 튜플의 유일성 (중복된 행 없음).
    
- 튜플의 무순서 (행 순서는 상관없음).
    
- 속성의 무순서 (열 순서는 상관없음).
    
- 속성의 **원자성** (모든 값은 더 이상 쪼갤 수 없는 단일 값이어야 함).
    

#### ③ 키(Key)의 종류 및 포함 관계

> **슈퍼키 ⊃ 후보키 ⊃ 기본키**

|**키 종류**|**설명**|**특징**|
|---|---|---|
|**슈퍼키**|유일성은 만족하지만, **최소성은 불만족**.|(학번+이름)으로 식별 가능|
|**후보키**|튜플을 유일하게 식별하는 속성들의 부분집합.|**유일성 + 최소성** 만족|
|**기본키 (PK)**|후보키 중에서 선택받은 키.|**Null 불가, 중복 불가**|
|**대체키**|후보키 중 기본키를 제외한 나머지 키.||
|**외래키 (FK)**|다른 릴레이션의 기본키를 참조하는 속성.|**참조 무결성** 유지|

---

### 6. 관계형 연산 (관계 대수 vs 관계 해석)

#### ① 관계 대수 (Relational Algebra)

- **절차적 언어:** "어떻게(How)" 데이터를 구할 것인가를 명시.
    
- **순수 관계 연산자 (특수 기호 암기):**
    
    - **Select ($\sigma$):** 조건을 만족하는 **수평적** 부분 집합 (행 선택).
        
    - **Project ($\pi$):** 특정 속성만 추출하는 **수직적** 부분 집합 (열 선택).
        
    - **Join ($\bowtie$):** 두 릴레이션을 합쳐 하나로 만듦.
        
    - **Division ($\div$):** 포함 관계에 있는 튜플 추출.
        
- **일반 집합 연산자:** 합집합($\cup$), 교집합($\cap$), 차집합($-$), 교차곱($\times$).
    

#### ② 관계 해석 (Relational Calculus)

- **비절차적 언어:** "무엇(What)"을 원하는가만 명시. (SQL의 이론적 기반)
    
- **튜플 관계 해석**과 **도메인 관계 해석**이 있음.
    
- 프레디킷(Predicate) 해석에 기반을 둠


---
---
---
### 1. 데이터베이스 설계 (Database Design)

데이터베이스 설계 순서는 무조건 암기해야 합니다.

[순서] 요구사항 분석 $\rightarrow$ 개념적 설계 $\rightarrow$ 논리적 설계 $\rightarrow$ 물리적 설계 $\rightarrow$ 구현

(암기 팁: 요-개-논-물-구)Getty Images

|**단계**|**핵심 내용**|**산출물/특징**|
|---|---|---|
|**요구사항 분석**|사용자의 요구조건 수집 및 분석|요구사항 명세서|
|**개념적 설계**|현실 세계를 추상화하여 모델링<br><br>  <br><br>**DBMS에 독립적**|**ER 다이어그램 (ERD)**|
|**논리적 설계**|특정 DBMS(관계형 등) 모델에 맞게 변환<br><br>  <br><br>**정규화(Normalization)** 수행|테이블 스키마, 트랜잭션 인터페이스 설계|
|**물리적 설계**|실제 저장 장치에 맞게 설계<br><br>  <br><br>**성능, 인덱스, 파티셔닝** 고려|저장 레코드 양식, 접근 경로|
|**구현**|실제 데이터베이스 생성|DDL(CREATE 문) 작성|

---

### 2. 정규화 (Normalization) (★최다 빈출)

데이터의 중복을 제거하고 **이상 현상(Anomaly)**을 방지하기 위해 테이블을 쪼개는 과정입니다.

#### ① 이상 현상 (Anomaly)

- **삽입 이상:** 데이터를 넣을 때 불필요한 데이터도 함께 넣어야 하는 문제.
    
- **삭제 이상:** 데이터를 지울 때 원치 않는 정보까지 함께 지워지는 문제.
    
- **갱신 이상:** 중복된 데이터 중 일부만 수정되어 정보 불일치가 생기는 문제.
    

#### ② 함수적 종속 (Functional Dependency)

- **$X \rightarrow Y$:** "X가 Y를 결정한다" (X는 결정자, Y는 종속자).
    

#### ③ 정규화 단계 (암기 필수: 도-부-이-결-다-조)

각 단계에서 **"무엇을 제거"**해야 다음 단계로 가는지 외워야 합니다.

|**정규형**|**조건 (제거 대상)**|**암기 키워드**|
|---|---|---|
|**제1정규형 (1NF)**|모든 속성의 **원자값(Atomic Value)** 만으로 구성|**도**메인 원자성|
|**제2정규형 (2NF)**|기본키에 대한 **부분 함수 종속** 제거 (완전 함수 종속 만족)|**부**분 함수 종속 제거|
|**제3정규형 (3NF)**|기본키가 아닌 속성 간의 **이행적 함수 종속** 제거 ($A \rightarrow B, B \rightarrow C$)|**이**행 함수 종속 제거|
|**BCNF**|모든 **결정자**가 **후보키**여야 함|**결**정자 후보키|
|**제4정규형 (4NF)**|**다치 종속 (Multi-valued Dependency)** 제거|**다**치 종속|
|**제5정규형 (5NF)**|**조인 종속 (Join Dependency)** 제거|**조**인 종속|

> **반정규화(De-normalization):** 성능 향상을 위해 의도적으로 정규화 원칙을 깨고 중복을 허용하거나 테이블을 합치는 것.

---

### 3. 트랜잭션 (Transaction)

데이터베이스의 상태를 변환시키는 논리적인 기능 수행 단위입니다.

#### ① 트랜잭션의 4대 특징 (ACID)

- **원자성 (Atomicity):** 모두 실행되거나, 아예 실행되지 않아야 함 (All or Nothing).
    
- **일관성 (Consistency):** 실행 성공 후 항상 일관된 상태 유지.
    
- **격리성/고립성 (Isolation):** 실행 중 다른 트랜잭션이 끼어들 수 없음.
    
- **영속성 (Durability):** 성공적으로 완료된 결과는 영구적으로 저장됨.
    

#### ② 트랜잭션 상태

- **활동(Active)** $\rightarrow$ **부분 완료** $\rightarrow$ **완료(Committed)**
    
- **실패(Failed)** $\rightarrow$ **철회(Aborted)**
    

#### ③ 연산 (TCL)

- **COMMIT:** 트랜잭션 성공, DB 반영.
    
- **ROLLBACK:** 트랜잭션 실패, 취소 및 원상 복구.
    
- **SAVEPOINT:** 롤백할 지점(저장점) 지정.
    

---

### 4. 동시성 제어 (Concurrency Control)

여러 트랜잭션이 동시에 실행될 때 일관성을 해치지 않도록 제어하는 기법입니다.

#### ① 동시성 제어를 안 할 때 발생하는 문제 (암기: 갱/현/모/연)

- **갱신 분실 (Lost Update):** 두 트랜잭션이 같은 데이터를 갱신하다가 하나가 덮어씌워짐.
    
- **현황 파악 오류 (Dirty Read):** 아직 확정(Commit)되지 않은 데이터를 읽어서 발생.
    
- **모순성 (Inconsistency):** 두 개의 데이터를 읽을 때, 그 사이 값이 변해서 불일치 발생.
    
- **연쇄 복귀 (Cascading Rollback):** 하나의 트랜잭션이 취소될 때, 연관된 다른 트랜잭션도 줄줄이 취소.
    

#### ② 로킹 (Locking) 기법

- 트랜잭션이 사용하는 데이터에 **잠금(Lock)**을 걸어 다른 트랜잭션이 접근하지 못하게 하는 것.
    
- **로킹 단위 (Locking Granularity):**
    
    - **단위가 크면 (DB 전체):** 관리가 쉽지만, 병행성(동시성) 수준이 낮아짐.
        
    - **단위가 작으면 (행 하나):** 병행성 수준은 높지만, 오버헤드(관리 비용)가 커짐.
        

---

### 5. 데이터베이스 복구 (Recovery)

장애 발생 시 이전의 일관된 상태로 되돌리는 것입니다.

- **즉시 갱신 (Immediate Update):** 트랜잭션 수행 중 즉시 DB에 반영. (장애 시 Undo, Redo 모두 필요)
    
- **지연 갱신 (Deferred Update):** Commit 전까지는 로그에만 기록, DB 반영 미룸. (장애 시 Redo만 필요, Undo 불필요)
    
- **검사점 (Checkpoint):** 로그 전체를 뒤지는 시간을 줄이기 위해 특정 시점에 마킹(Checkpoint)을 해두고 거기까지만 복구 수행.
    

---

### 6. 보안 및 접근 관리 (접근 통제)

#### ① 접근 통제 기법 (암기: DAC / MAC / RBAC)

|**기법**|**영문/한글**|**설명**|**결정 주체**|
|---|---|---|---|
|**DAC**|임의 접근 통제<br><br>  <br><br>(Discretionary)|사용자의 **신원(Identity)**에 따라 권한 부여.|**데이터 소유자**|
|**MAC**|강제 접근 통제<br><br>  <br><br>(Mandatory)|데이터의 **보안 등급**과 사용자의 **인가 등급** 비교.|**시스템(관리자)**|
|**RBAC**|역할 기반 접근 통제<br><br>  <br><br>(Role-Based)|사용자의 **역할(Role)**에 따라 권한 부여.<br><br>  <br><br>(기업 환경에서 가장 많이 씀)|**중앙 관리자**|