## 제1부: 데이터베이스 시스템의 이론적 토대와 아키텍처

### 1. 데이터베이스의 개념 및 본질적 특징

#### 1.1 데이터베이스의 정의와 진화

데이터베이스(Database)는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임으로, '통합된 데이터(Integrated Data)', '저장된 데이터(Stored Data)', '운영 데이터(Operational Data)', '공용 데이터(Shared Data)'라는 네 가지 핵심적인 정의를 갖는다.1 이는 단순한 자료의 집합이 아니라, 중복을 배제하여 구조화하고(Integrated), 컴퓨터가 접근 가능한 매체에 저장되며(Stored), 조직의 고유 기능을 수행하기 위해 존재하고(Operational), 여러 응용 시스템이 공동으로 소유하고 유지하는(Shared) 자원임을 의미한다.

#### 1.2 데이터베이스의 4대 핵심 특징

데이터베이스 시스템이 파일 시스템과 차별화되는 본질적인 특징은 다음 네 가지로 요약할 수 있으며, 이는 현대 정보 시스템의 실시간 처리 요구사항을 반영한다.2

1. **실시간 접근성(Real-time Accessibility):** 데이터베이스는 사용자의 질의(Query)에 대해 즉각적으로 응답해야 한다. 이는 비정형적인 조회 요청에 대해서도 수 초 내에 결과를 반환할 수 있는 성능을 의미하며, 현대의 OLTP(Online Transaction Processing) 시스템의 기반이 된다.
    
2. **계속적인 변화(Continuous Evolution):** 데이터베이스는 정적인 저장소가 아니다. 현실 세계의 상태 변화는 삽입(Insertion), 삭제(Deletion), 갱신(Update) 연산을 통해 데이터베이스에 즉각 반영되어야 하며, 이를 통해 데이터는 항상 최신의 정확한 상태를 유지해야 한다.
    
3. **동시 공유(Concurrent Sharing):** 다수의 사용자나 응용 프로그램이 서로 다른 목적으로 동일한 데이터에 동시에 접근할 수 있어야 한다. 이는 단순히 여러 사람이 순차적으로 사용하는 것을 넘어, 병행 제어(Concurrency Control)를 통해 동시에 같은 데이터 항목에 접근하더라도 무결성이 깨지지 않음을 보장해야 한다.
    
4. **내용에 의한 참조(Reference by Content):** 데이터는 물리적인 주소(Address)나 위치(Location)가 아닌, 사용자가 요구하는 데이터의 값(Value)에 따라 참조된다. 예를 들어, 사용자는 "하드디스크 3번 트랙의 데이터를 가져오라"고 명령하지 않고, "부서가 '인사팀'인 사원을 찾으라"고 질의한다. 이는 데이터 관리의 추상화 레벨을 높여 사용 편의성과 유연성을 극대화한다.
    

### 2. 데이터베이스 관리 시스템(DBMS)의 역할과 구성

#### 2.1 DBMS의 정의와 기능

데이터베이스 관리 시스템(DBMS)은 사용자 불응용 프로그램과 데이터베이스 사이에서 중재자 역할을 수행하는 소프트웨어 패키지이다. DBMS는 데이터의 종속성과 중복성 문제를 해결하기 위해 필수적이며, 크게 정의(Definition), 조작(Manipulation), 제어(Control) 기능을 수행한다.1

- **정의 기능:** 데이터베이스의 논리적, 물리적 구조를 정의하고 스키마(Schema)를 생성한다.
    
- **조작 기능:** 사용자가 데이터를 검색, 삽입, 삭제, 수정할 수 있도록 질의어(DML)를 제공한다.
    
- **제어 기능:** 무결성 유지, 보안 및 권한 제어, 병행 제어, 회복(Recovery) 등을 담당한다.
    

#### 2.2 DBMS의 장단점 분석

| **구분** | **주요 내용**       | **비즈니스적 함의**                                        |
| ------ | --------------- | --------------------------------------------------- |
| **장점** | **데이터 중복의 최소화** | 저장 공간 절약 및 데이터 간 불일치 방지, 갱신 비용 절감 4                 |
|        | **데이터 독립성 확보**  | 응용 프로그램과 데이터 구조의 분리로 유지보수 비용 획기적 감소 1               |
|        | **데이터 무결성 유지**  | 제약조건을 통한 유효하지 않은 데이터 진입 차단, 데이터 신뢰성 확보              |
|        | **보안성 향상**      | 사용자별 접근 권한 및 뷰(View) 제공을 통한 민감 정보 보호 4              |
|        | **표준화 용이**      | 데이터 관리 규정 및 명명 규칙의 중앙 집중식 관리 가능 1                   |
| **단점** | **높은 초기 비용**    | 고가의 소프트웨어 라이선스 및 전문 인력 필요                           |
|        | **시스템 복잡성**     | 복잡한 기능으로 인한 관리의 어려움 및 시스템 과부하 가능성                   |
|        | **중앙 집중의 취약성**  | DBMS 장애 발생 시 전체 시스템 마비 위험 (Single Point of Failure) |

#### 2.3 DBMS의 분류 체계

DBMS는 데이터 모델에 따라 발전해 왔다. 초기 1960-70년대의 **계층형(Hierarchical)** 및 **네트워크형(Network)** DBMS는 데이터 간의 관계를 포인터로 연결하여 성능은 우수했으나 구조 변경이 어렵고 복잡했다. 1980년대 이후 등장한 **관계형(Relational) DBMS (RDBMS)**는 수학적 모델을 기반으로 데이터를 테이블 형태로 관리하며 현재까지 가장 널리 사용되고 있다. 최근에는 비정형 데이터 처리를 위한 **NoSQL**과 복잡한 객체 처리를 위한 **객체지향(Object-Oriented) DBMS** 및 **객체-관계형(Object-Relational) DBMS**가 활용되고 있다.2

### 3. 데이터베이스 시스템의 구성 요소와 아키텍처

#### 3.1 스키마(Schema)와 인스턴스(Instance)

데이터베이스의 구조적 이해를 위해서는 스키마와 인스턴스의 구분이 선행되어야 한다. **스키마**는 데이터베이스의 전체적인 구조, 데이터 타입, 제약조건에 대한 명세(Description)로, 시간에 따라 거의 변하지 않는 정적인 특성(Intension)을 가진다. 반면, **인스턴스**는 특정 시점에 데이터베이스에 실제로 저장되어 있는 데이터의 집합을 의미하며, 데이터 조작 연산에 의해 수시로 변하는 동적인 특성(Extension)을 가진다.1

#### 3.2 3단계 스키마 구조와 데이터 독립성

ANSI/SPARC 아키텍처는 데이터베이스의 복잡성을 숨기고 데이터 독립성을 확보하기 위해 스키마를 세 단계로 계층화한다.

1. **외부 스키마(External Schema):** 사용자나 응용 프로그래머가 접근하는 뷰(View) 단계이다. 하나의 데이터베이스에 대해 여러 개의 외부 스키마가 존재할 수 있으며, 사용자별로 필요한 데이터만 정의하여 보여준다.
    
2. **개념 스키마(Conceptual Schema):** 모든 사용자 관점을 통합한 조직 전체의 데이터베이스 논리적 구조이다. 개체, 속성, 관계, 제약조건, 보안 정책 등이 정의되며, 데이터베이스 시스템당 하나만 존재한다. 일반적으로 '스키마'라고 할 때 개념 스키마를 지칭한다.
    
3. **내부 스키마(Internal Schema):** 물리적 저장 장치의 입장에서 본 데이터베이스 구조이다. 데이터의 저장 방법, 레코드 형식, 인덱스 구조, 압축 기법 등을 정의한다.5
    

이러한 계층 구조는 두 가지 **데이터 독립성**을 제공한다.1

- **논리적 데이터 독립성(Logical Data Independence):** 개념 스키마가 변경(예: 새로운 속성 추가)되어도 외부 스키마나 응용 프로그램은 영향을 받지 않는다. 이는 기존 프로그램의 재작성 없이 데이터베이스의 논리적 구조를 확장할 수 있게 한다.
    
- **물리적 데이터 독립성(Physical Data Independence):** 내부 스키마(물리적 저장 구조)가 변경(예: 인덱스 생성, 저장 장치 변경)되어도 개념 스키마와 응용 프로그램은 영향을 받지 않는다. 이는 시스템 성능 최적화 작업을 응용 프로그램과 독립적으로 수행할 수 있게 한다.
    

#### 3.3 데이터 사전(Data Dictionary)의 역할

데이터 사전은 '시스템 카탈로그(System Catalog)'라고도 불리며, 데이터베이스에 저장된 모든 데이터 개체들에 대한 정의나 명세에 관한 정보, 즉 **메타데이터(Metadata)**를 유지·관리하는 시스템 데이터베이스이다. 스키마 정보, 사용자 정보, 권한 정보, 무결성 제약조건 등이 저장된다. 데이터 사전 자체도 시스템에 의해 릴레이션 형태로 관리되므로 사용자는 SQL을 통해 조회할 수 있으나, 내용을 직접 수정하는 것은 허용되지 않는다(DBMS만이 수정 가능).6

#### 3.4 데이터베이스 사용자 유형

데이터베이스 시스템은 다양한 사용자에 의해 운영된다.

- **데이터베이스 관리자(DBA):** 데이터베이스 시스템의 전체적인 관리와 운영을 책임지는 전문가로, 스키마 정의, 보안 및 권한 부여, 백업 및 회복, 성능 모니터링을 수행한다.5
    
- **응용 프로그래머(Application Programmer):** 호스트 언어(C, Java 등)와 DML을 사용하여 일반 사용자가 이용할 수 있는 응용 프로그램을 개발하는 사용자이다.
    
- **일반 사용자(End User):** 질의어(SQL)를 사용하거나 메뉴 구동 방식의 응용 프로그램을 통해 데이터베이스에 접근하여 데이터를 조회하거나 갱신하는 사용자이다.
    

---

## 제2부: 데이터 모델링과 관계형 데이터 모델

### 4. 데이터 모델링: 현실 세계의 추상화

데이터 모델링은 현실 세계의 복잡한 데이터를 컴퓨터 환경에 맞게 단순화, 추상화하여 표현하는 과정이다. 이는 크게 개념적 설계와 논리적 설계 단계로 구분된다.

#### 4.1 개념적 데이터 모델: ER 모델

**개체-관계(Entity-Relationship, ER) 모델**은 1976년 P. Chen에 의해 제안된 개념적 모델링의 대표적인 도구이다. 현실 세계를 개체(Entity), 속성(Attribute), 관계(Relationship)의 세 가지 기본 요소로 모델링한다.7

- **개체(Entity):** 물리적 또는 개념적으로 존재하는 독립적인 대상(예: 학생, 과목). 사각형으로 표현한다.
    
- **속성(Attribute):** 개체가 가지는 특성(예: 학번, 이름). 타원으로 표현하며, 식별자 속성은 밑줄로 표시한다.
    
- **관계(Relationship):** 개체 간의 연관성(예: 수강하다). 마름모로 표현한다. 관계는 일대일(1:1), 일대다(1:N), 다대다(N:M)의 **카디날리티(Cardinality)**를 가진다.
    

ER 모델은 사용자와 설계자 간의 의사소통 도구로 활용되며, 이를 도식화한 것이 **ER 다이어그램(ERD)**이다. 논리적 데이터 모델과는 달리 특정 DBMS에 종속되지 않는다는 특징이 있다.7

#### 4.2 계층형 모델과 네트워크 모델

관계형 모델 이전에 사용된 레거시 모델들에 대한 이해는 데이터베이스 발전사를 파악하는 데 중요하다.

- **계층형 모델(Hierarchical Model):** 데이터가 트리(Tree) 구조로 구성된다. 부모 개체와 자식 개체는 1:N 관계만 허용되며, 부모가 없는 자식은 존재할 수 없다. 데이터 접근 속도가 빠르지만, 구조 변경이 어렵고 N:M 관계를 표현하기 위해 데이터 중복이 발생한다.8
    
- **네트워크 모델(Network Model):** 데이터가 그래프(Graph) 구조로 구성된다. 오너(Owner)와 멤버(Member) 레코드 타입 간에 1:N 관계를 맺지만, 하나의 멤버가 여러 오너를 가질 수 있어(Multi-parent) 계층형 모델의 제약을 극복하고 N:M 관계 표현이 용이하다. 그러나 구조가 매우 복잡하여 프로그래머가 데이터 구조를 완벽히 이해해야 한다는 단점이 있다.9
    

### 5. 관계형 데이터 모델: 현대 데이터베이스의 표준

#### 5.1 관계형 모델의 구조와 용어

관계형 데이터 모델은 데이터를 2차원 테이블 형태의 **릴레이션(Relation)**으로 표현한다. 이는 수학적 집합론에 기초하고 있어 이론적 배경이 탄탄하다.2

- **릴레이션(Relation):** 데이터들을 표(Table) 형태로 표현한 것.
    
- **튜플(Tuple):** 릴레이션의 행(Row)을 구성하는 요소로, 개체(Entity)의 인스턴스를 나타낸다. 튜플의 수는 **카디날리티(Cardinality)**라고 한다.
    
- **속성(Attribute):** 릴레이션의 열(Column)을 구성하는 요소로, 데이터의 가장 작은 논리적 단위이다. 속성의 수는 **차수(Degree)**라고 한다.11
    
- **도메인(Domain):** 하나의 속성이 취할 수 있는 같은 타입의 원자 값(Atomic Value)들의 집합이다. 예를 들어 '성별' 속성의 도메인은 '남', '여'이다.11
    

#### 5.2 릴레이션의 특징

릴레이션은 단순한 엑셀 시트와 달리 다음과 같은 엄격한 특성을 만족해야 한다.12

1. **튜플의 유일성:** 하나의 릴레이션에 중복된 튜플은 존재할 수 없다. 모든 튜플은 서로 구별되어야 한다.
    
2. **튜플의 무순서성:** 튜플 사이에는 순서가 없다. 데이터베이스는 집합(Set)이므로 저장 순서는 의미가 없다.
    
3. **속성의 무순서성:** 속성 사이에는 순서가 없다. 속성은 이름으로 참조된다.
    
4. **속성의 원자성(Atomicity):** 모든 속성 값은 논리적으로 더 이상 분해할 수 없는 원자 값이어야 한다. 다중 값(Multi-value)이나 복합 값(Composite value)은 허용되지 않는다(제1정규형의 조건).
    

#### 5.3 키(Key)의 개념과 종류

튜플을 유일하게 식별하고 릴레이션 간의 관계를 맺기 위해 키(Key)가 사용된다.12

|**키 종류**|**정의 및 특징**|**예시 (학생 릴레이션)**|
|---|---|---|
|**슈퍼키 (Super Key)**|유일성(Uniqueness)을 만족하는 속성들의 집합. 최소성은 만족하지 않아도 됨.|(학번), (학번, 이름), (주민번호, 이름)|
|**후보키 (Candidate Key)**|유일성과 최소성(Minimality)을 동시에 만족하는 속성들의 집합.|(학번), (주민번호)|
|**기본키 (Primary Key)**|후보키 중에서 튜플을 식별하기 위해 설계자가 선택한 키. NULL 불가.|(학번)|
|**대체키 (Alternate Key)**|기본키로 선택되지 않은 나머지 후보키.|(주민번호)|
|**외래키 (Foreign Key)**|다른 릴레이션의 기본키를 참조하는 속성. 릴레이션 간 관계 표현.|(학과코드) - 학과 릴레이션 참조|

#### 5.4 무결성 제약조건 (Integrity Constraints)

데이터의 정확성과 일관성을 보장하기 위해 DBMS는 다음과 같은 무결성 제약조건을 강제한다.6

- **개체 무결성(Entity Integrity):** 기본키를 구성하는 어떤 속성도 NULL 값이나 중복 값을 가질 수 없다. 이는 개체의 식별 가능성을 보장한다.
    
- **참조 무결성(Referential Integrity):** 외래키 값은 참조하는 릴레이션의 기본키 값과 일치하거나 NULL이어야 한다. 존재하지 않는 개체를 참조할 수 없음을 의미한다.
    
- **도메인 무결성(Domain Integrity):** 속성 값은 정의된 도메인에 속한 값이어야 한다(예: 나이는 음수일 수 없다).
    

### 6. 관계형 연산: 데이터를 다루는 수학적 도구

관계형 데이터 모델의 연산은 원하는 데이터를 추출하기 위한 이론적 도구로, 관계 대수(Relational Algebra)와 관계 해석(Relational Calculus)으로 나뉜다.

#### 6.1 관계 대수 (Relational Algebra)

관계 대수는 원하는 데이터를 얻기 위해 '어떻게(How)' 처리해야 하는지 절차를 기술하는 절차적 언어(Procedural Language)이다.15

**순수 관계 연산자:**

- **셀렉션(Selection, $\sigma$):** 조건(Predicates)을 만족하는 튜플들을 수평적으로 추출한다. 결과 릴레이션의 차수는 원본과 같고, 카디날리티는 줄어든다. ($\sigma_{조건}(R)$)
    
- **프로젝션(Projection, $\pi$):** 지정된 속성 리스트만 수직적으로 추출한다. 중복된 튜플은 제거된다. ($\pi_{속성리스트}(R)$)
    
- **조인(Join, $\bowtie$):** 두 릴레이션을 공통 속성을 기준으로 결합하여 새로운 릴레이션을 생성한다. 자연 조인(Natural Join), 세타 조인(Theta Join), 외부 조인(Outer Join) 등이 있다.
    
- **디비전(Division, $\div$):** 릴레이션 $R(X, Y)$와 $S(Y)$에 대해, $S$의 모든 튜플과 연관된 $R$의 $X$값을 추출한다. '모든 ~에 대해 ~하는' 형태의 질의에 사용된다.16
    

**일반 집합 연산자:**

- **합집합($\cup$), 교집합($\cap$), 차집합($-$), 카티션 프로덕트($\times$):** 집합 연산을 수행하기 위해서는 두 릴레이션이 합병 가능(Union Compatible)해야 한다. 즉, 차수가 같고 대응하는 속성의 도메인이 호환되어야 한다.15
    

#### 6.2 관계 해석 (Relational Calculus)

관계 해석은 원하는 데이터가 '무엇(What)'인지만 명시하고 처리 절차는 기술하지 않는 비절차적(Non-procedural) 언어이다. 이는 술어 논리(Predicate Logic)에 기반을 둔다.11

- **튜플 관계 해석(Tuple Relational Calculus):** 튜플 변수 $t$를 사용하여 질의를 표현한다. 기본 형식은 $\{ t | P(t) \}$이며, 조건식 $P(t)$를 참으로 만드는 튜플 $t$의 집합을 의미한다. 전칭 정량자($\forall$, For all)와 존재 정량자($\exists$, There exists)를 사용하여 복잡한 조건을 표현한다.20
    
- **도메인 관계 해석(Domain Relational Calculus):** 속성(도메인) 변수 $x_1, x_2,..., x_n$을 사용하여 질의를 표현한다. 형식은 ${ x_1, x_2,..., x_n | F(x_1,..., x_n) }$과 같으며, $F$는 도메인 변수들을 포함한 정형식(Well-Formed Formula)이다. QBE(Query By Example) 언어의 기초가 되었다.11
    

관계 대수와 관계 해석은 표현력(Expressive Power) 면에서 동등하다. 즉, 관계 대수로 표현 가능한 질의는 관계 해석으로도 표현 가능하며, 그 역도 성립한다. SQL은 이러한 이론적 배경 위에 설계된 언어이다.11

---

## 제3부: 데이터베이스 설계 및 고가용성 운영 전략

### 1. 데이터베이스 설계 방법론

효과적인 데이터베이스 구축을 위해서는 체계적인 설계 과정이 필요하다. 이는 일반적으로 5단계로 진행된다.22

#### 1.1 요구사항 분석 (Requirement Analysis)

데이터베이스 설계의 첫 단추로, 사용자의 요구사항을 수집하고 분석하여 요구사항 명세서(Requirement Specification)를 작성한다. 데이터의 종류, 용도, 처리 형태, 제약조건 등을 명확히 파악해야 한다.

#### 1.2 개념적 설계 (Conceptual Design)

DBMS에 독립적인 추상적 데이터 모델을 구축하는 단계이다. 요구사항 명세서를 바탕으로 핵심 개체와 관계를 식별하고 **ER 다이어그램**을 작성한다. 이 단계의 산출물인 개념 스키마는 사용자와 개발자 간의 의사소통 기준이 된다.

#### 1.3 논리적 설계 (Logical Design)

개념적 모델(ERD)을 특정 목표 DBMS(예: Oracle, MySQL)가 지원하는 논리적 데이터 모델(주로 관계형 모델)로 변환(Mapping)하는 단계이다.

- **사상(Mapping):** 개체는 테이블로, 속성은 컬럼으로, 식별자는 기본키로 변환한다. 관계(1:1, 1:N, N:M)에 따라 외래키를 설정하거나 별도의 관계 테이블을 생성한다.
    
- **정규화(Normalization):** 데이터의 중복과 이상 현상을 제거하기 위해 릴레이션을 분해하여 스키마를 정제한다.
    

#### 1.4 물리적 설계 (Physical Design)

논리적 설계를 바탕으로 데이터가 저장 장치에 실제로 저장되는 방법을 설계한다. 데이터 타입의 크기 결정, 인덱스(Index) 설계, 역정규화(De-normalization), 파티셔닝(Partitioning), 클러스터링(Clustering) 등이 수행된다. 응답 시간, 저장 공간 효율성, 트랜잭션 처리량(Throughput) 등의 성능 요소를 최적화하는 것이 목표이다.

#### 1.5 구현 (Implementation)

SQL의 DDL(Data Definition Language)을 사용하여 실제 데이터베이스 스키마를 생성하고 데이터를 적재하는 단계이다.

### 2. 정규화(Normalization): 데이터 무결성을 위한 핵심 이론

정규화는 함수 종속성(Functional Dependency)을 분석하여 릴레이션을 무손실 분해(Lossless Decomposition)함으로써 데이터 중복을 최소화하고 이상 현상을 방지하는 과정이다.23

#### 2.1 이상 현상(Anomaly)

정규화되지 않은 릴레이션에서는 다음과 같은 이상 현상이 발생한다.

- **삽입 이상(Insertion Anomaly):** 불필요한 데이터를 함께 입력하지 않으면 원하는 데이터를 저장할 수 없는 현상.
    
- **삭제 이상(Deletion Anomaly):** 튜플 삭제 시 유지해야 할 정보까지 연쇄적으로 삭제되는 현상.
    
- **갱신 이상(Update Anomaly):** 중복된 데이터의 일부만 갱신되어 정보의 모순이 발생하는 현상.
    

#### 2.2 정규형(Normal Form)의 단계별 분석

정규화는 제1정규형에서 제5정규형까지 단계적으로 진행된다.25

|**정규형**|**조건 및 제거 대상**|**상세 설명**|
|---|---|---|
|**제1정규형 (1NF)**|**도메인의 원자성**|모든 속성 값은 원자 값이어야 한다. 반복 그룹(Repeating Group)을 제거하고 별도의 튜플이나 릴레이션으로 분리한다.|
|**제2정규형 (2NF)**|**부분 함수 종속 제거**|기본키가 복합키(Composite Key)일 때, 키의 일부에만 종속되는 속성을 분리한다. 즉, 모든 속성은 기본키 전체에 대해 완전 함수 종속(Full Functional Dependency)되어야 한다.|
|**제3정규형 (3NF)**|**이행 함수 종속 제거**|기본키가 아닌 속성들 간의 종속성($X \to Y, Y \to Z$ 이면 $X \to Z$)을 제거한다. 비주요 속성은 오직 기본키에만 종속되어야 한다.|
|**BCNF (Boyce-Codd)**|**결정자가 후보키가 아닌 함수 종속 제거**|모든 결정자(Determinant)는 후보키여야 한다. 키가 아닌 속성이 키의 일부를 결정하는 경우를 분리한다. 강한 제3정규형이라고도 한다.|
|**제4정규형 (4NF)**|**다치 종속(MVD) 제거**|하나의 릴레이션에 두 개 이상의 독립적인 다치 속성이 존재할 때 발생하는 다치 종속($A \twoheadrightarrow B$)을 제거한다.|
|**제5정규형 (5NF)**|**조인 종속(JD) 제거**|릴레이션을 분해했다가 다시 조인했을 때 원래의 릴레이션이 복원되지 않고 불필요한 튜플이 생성되는 조인 종속을 제거한다.|

실무적으로는 데이터 중복 제거와 조인 연산 증가에 따른 성능 저하 간의 트레이드오프를 고려하여 보통 **BCNF** 또는 **3NF** 수준까지 정규화를 수행한다. 성능 향상을 위해 의도적으로 정규화 원칙을 위배하는 **반정규화(De-normalization)**가 필요한 경우도 있다(예: 통계 테이블).

### 3. 트랜잭션 처리: 데이터 일관성의 보루

트랜잭션(Transaction)은 데이터베이스의 논리적 연산 단위로, 데이터베이스의 상태를 일관되게 변화시키는 일련의 연산 집합이다.

#### 3.1 트랜잭션의 ACID 특성

트랜잭션이 성공적으로 처리되기 위해 반드시 만족해야 하는 4가지 성질이다.27

1. **원자성(Atomicity):** 트랜잭션 내의 연산은 모두 수행되거나, 아니면 하나도 수행되지 않아야 한다(All or Nothing). 오류 발생 시 트랜잭션 이전 상태로 복구(Rollback)되어야 한다.
    
2. **일관성(Consistency):** 트랜잭션 수행 전후에 데이터베이스는 일관된 상태를 유지해야 한다. 즉, 무결성 제약조건을 위배하지 않아야 한다.
    
3. **고립성(Isolation):** 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다. 각 트랜잭션은 독립적으로 수행되는 것처럼 보여야 한다.
    
4. **지속성(Durability):** 성공적으로 완료(Commit)된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 반영되어야 한다.
    

#### 3.2 트랜잭션의 상태 및 스케줄

트랜잭션은 활동(Active) $\to$ 부분 완료(Partially Committed) $\to$ 완료(Committed) 또는 실패(Failed) $\to$ 철회(Aborted)의 상태 전이를 가진다. 다수의 트랜잭션이 동시에 실행될 때 연산들의 실행 순서를 **스케줄(Schedule)**이라 하며, 직렬 스케줄과 동일한 결과를 낳는 **직렬 가능 스케줄(Serializable Schedule)**을 보장하는 것이 동시성 제어의 목표이다.

### 4. 데이터베이스 복구(Recovery) 기법

복구는 시스템 장애 등으로 인해 손상된 데이터베이스를 장애 발생 이전의 일관된 상태로 복원하는 기술이다.

#### 4.1 장애 유형 및 복구 연산

장애는 트랜잭션 장애(논리적 오류), 시스템 장애(하드웨어 오동작, 교착상태), 미디어 장애(디스크 손상)로 분류된다. 복구를 위해 **덤프(Dump)**와 **로그(Log)**를 사용하며, **Redo(재실행)**와 **Undo(실행취소)** 연산이 수행된다.

#### 4.2 주요 복구 기법

- **지연 갱신(Deferred Update):** 트랜잭션이 부분 완료될 때까지 데이터베이스에 대한 실제 갱신을 미루고 로그에만 기록한다. 트랜잭션 실패 시 Undo가 필요 없고, 완료 후 장애 발생 시 Redo만 수행하면 된다.28
    
- **즉시 갱신(Immediate Update):** 트랜잭션 수행 중 갱신 내용을 즉시 데이터베이스에 반영한다. 장애 발생 시 완료되지 않은 트랜잭션은 반드시 Undo를 수행해야 한다. 가장 널리 사용되는 방식이다.30
    
- **체크포인트(Checkpoint) 기법:** 로그 전체를 검색하는 비용을 줄이기 위해 주기적으로 메모리의 변경 내용을 디스크에 기록하고 검사점을 표시한다. 복구 시 가장 최근 체크포인트 이후의 로그만 처리한다.
    
- **그림자 페이징(Shadow Paging):** 로그를 사용하지 않고, 데이터베이스 페이지 테이블을 복제(Shadow)하여 트랜잭션 수행 중에는 그림자 페이지를 갱신하고, 완료 시 원본과 교체하는 방식이다. Undo/Redo가 불필요하다는 장점이 있다.29
    

### 5. 동시성 제어(Concurrency Control)

다중 사용자 환경에서 트랜잭션들이 동시에 실행될 때 데이터 무결성을 해치지 않도록 제어하는 기법이다. 동시성 제어가 없으면 **갱신 분실(Lost Update)**, **모순성(Inconsistency)**, **연쇄 복귀(Cascading Rollback)** 등의 심각한 문제가 발생한다.

#### 5.1 로킹(Locking) 기법

데이터에 접근하기 전에 잠금(Lock)을 설정하여 독점권을 획득하는 방식이다.27

- **공유 락(Shared Lock, S-Lock):** 읽기(Read) 전용 락. 다른 트랜잭션도 S-Lock을 걸 수 있다(공유 가능).
    
- **배타 락(Exclusive Lock, X-Lock):** 읽기와 쓰기(Write) 가능. 다른 트랜잭션은 어떠한 락도 걸 수 없다(독점).
    

#### 5.2 2단계 로킹 규약(2PL, Two-Phase Locking)

직렬 가능성을 보장하기 위해 락을 거는 단계와 해제하는 단계를 분리한다.

1. **확장 단계(Growing Phase):** 트랜잭션이 락을 획득만 할 수 있고 해제는 할 수 없는 단계.
    
2. 축소 단계(Shrinking Phase): 트랜잭션이 락을 해제만 할 수 있고 획득은 할 수 없는 단계.
    
    2PL은 직렬 가능성을 보장하지만, 서로 다른 트랜잭션이 상대방의 자원을 기다리는 **교착 상태(Deadlock)**가 발생할 수 있다는 단점이 있다.27
    

### 6. 보안 및 접근 관리

데이터베이스 보안은 불법적인 접근과 데이터 유출, 변조로부터 데이터를 보호하는 기술적, 관리적 조치이다.33

#### 6.1 접근 제어(Access Control) 모델

인가된 사용자만이 데이터에 접근할 수 있도록 통제하는 핵심 메커니즘이다.

|**모델**|**설명**|**적용 사례**|
|---|---|---|
|**임의적 접근 통제 (DAC)**|데이터 소유자가 사용자 신원(ID)에 기반하여 접근 권한(Grant/Revoke)을 부여한다. 유연하지만 트로이 목마 공격 등에 취약하다.|일반적인 상용 OS, DBMS의 기본 모델 35|
|**강제적 접근 통제 (MAC)**|시스템이 주체(사용자)와 객체(데이터)에 보안 등급(Label)을 부여하고, 보안 정책(예: Bell-LaPadula)에 따라 접근을 강제한다.|군사, 정보기관 등 고도의 보안이 필요한 시스템 37|
|**역할 기반 접근 통제 (RBAC)**|사용자의 '역할(Role)'(예: 팀장, 사원)에 권한을 할당하고, 사용자를 역할에 배정한다. 인사 이동이 잦은 기업 환경에서 권한 관리가 매우 효율적이다.|대부분의 현대 기업 정보 시스템 37|

#### 6.2 물리적 및 운영 보안

- **물리적 보안:** 데이터 센터 출입 통제, 서버실 잠금 장치, 재해 방지 시설 등 물리적 위협으로부터 시스템을 보호한다.40
    
- **운영 보안:** 백업 정책 수립, 로그 감사(Auditing), 정기적인 보안 패치, 데이터 암호화(TDE) 등을 통해 운영 단계에서의 보안을 강화한다.