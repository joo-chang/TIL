## 제1부: 관계형 모델의 핵심과 3치 논리(Three-Valued Logic)의 이해

SQL 역량 평가에서 초급자와 숙련자를 가르는 가장 명확한 기준 중 하나는 바로 `NULL`과 논리 연산에 대한 이해도입니다. 일반적인 프로그래밍 언어에서의 `null`은 객체의 부재나 0을 의미할 수 있지만, 관계형 데이터베이스에서의 `NULL`은 **'알 수 없음(Unknown)'** 또는 **'적용할 수 없음(Inapplicable)'**이라는 고유한 상태를 나타냅니다. 이로 인해 SQL은 참(True)과 거짓(False) 외에 '알 수 없음(Unknown)'이라는 제3의 진리값을 가지는 3치 논리 체계를 따릅니다.

### 1.1 NULL의 존재론적 의미와 비교 연산

SQL에서 `NULL`은 값이 아닙니다. 따라서 `NULL`은 그 자신과도 같지 않습니다. 많은 지원자가 범하는 치명적인 실수는 `WHERE column = NULL`과 같은 형태의 쿼리를 작성하는 것입니다. 논리적으로 '알 수 없는 값'이 '알 수 없는 값'과 같은지 묻는 질문에 대한 답은 '알 수 없음'일 수밖에 없습니다.1 데이터베이스 엔진은 `WHERE` 절의 조건이 `TRUE`일 때만 행을 반환하며, `UNKNOWN`인 경우는 반환하지 않습니다.

#### 1.1.1 비교 연산자의 함정

다음은 흔히 발생하는 실수와 올바른 접근법의 비교입니다.

**잘못된 예시 (결과 없음):**

SQL

```
-- 전화번호가 없는 고객을 찾으려 하지만, 결과는 0건입니다.
SELECT Name 
FROM Customers 
WHERE Phone = NULL; 
```

**올바른 예시:**

SQL

```
-- 상태를 확인하는 연산자를 사용해야 합니다.
SELECT Name 
FROM Customers 
WHERE Phone IS NULL;
```

이러한 특성은 부정 연산에서도 동일하게 적용됩니다. `column!= NULL` 또는 `column <> NULL` 역시 `UNKNOWN`을 반환하므로, NULL이 아닌 값을 찾으려 할 때도 반드시 `IS NOT NULL`을 사용해야 합니다.1

### 1.2 3치 논리(3VL)의 진리표와 필터링 파급 효과

`AND`, `OR`, `NOT`과 같은 논리 연산자가 `NULL`과 결합될 때 발생하는 현상을 정확히 이해하는 것은 복잡한 비즈니스 로직을 구현하는 데 필수적입니다. 평가에서는 종종 복합 조건을 제시하고 결과 집합을 예측하도록 요구합니다.

#### 1.2.1 논리 연산 매트릭스

- **AND 연산:**
    
    - `TRUE AND NULL` = `UNKNOWN` (결과를 확정할 수 없음)
        
    - `FALSE AND NULL` = `FALSE` (하나가 거짓이면 전체가 거짓이므로 NULL의 영향 없음)
        
    - `NULL AND NULL` = `UNKNOWN`
        
- **OR 연산:**
    
    - `TRUE OR NULL` = `TRUE` (하나가 참이면 전체가 참이므로 NULL의 영향 없음)
        
    - `FALSE OR NULL` = `UNKNOWN` (결과가 NULL의 실제 값에 의존함)
        
    - `NULL OR NULL` = `UNKNOWN`
        
- **NOT 연산:**
    
    - `NOT NULL` = `UNKNOWN`
        

이러한 논리는 `NOT IN` 연산자를 사용할 때 치명적인 버그를 유발할 수 있습니다. 만약 서브쿼리의 결과 집합 중에 단 하나라도 `NULL`이 포함되어 있다면, `NOT IN` 조건은 전체 결과 집합에 대해 빈 값(Empty Set)을 반환하게 됩니다.

**치명적 오류 시나리오 분석:**

SQL

```
-- 서브쿼리 결과에 NULL이 포함된 경우
SELECT * 
FROM Employees 
WHERE ManagerID NOT IN (SELECT ManagerID FROM Managers);
```

위 쿼리는 논리적으로 `ManagerID <> Value1 AND ManagerID <> Value2 AND ManagerID <> NULL`로 풀이됩니다. 앞서 살펴본 바와 같이 `ManagerID <> NULL`은 `UNKNOWN`이고, `AND` 연산으로 연결된 전체 식은 `UNKNOWN`이 되어, 결국 어떤 행도 반환되지 않는 참사가 발생합니다.3 이를 방지하기 위해서는 `NOT EXISTS`를 사용하거나, 서브쿼리에서 `WHERE ManagerID IS NOT NULL`을 명시해야 합니다.

### 1.3 산술 연산과 집계 함수에서의 NULL 전파

데이터 무결성 측면에서 `NULL`은 산술 연산 시 '전파(Propagate)'되는 특성을 가집니다. `5 + NULL`의 결과는 `5`가 아니라 `NULL`입니다. 이는 "알 수 없는 값에 5를 더해도 여전히 알 수 없다"는 논리에 기인합니다. 급여 계산이나 재고 관리 시스템에서 이러한 특성을 간과하면 심각한 데이터 손실로 이어질 수 있습니다.1

#### 1.3.1 집계 함수의 묵시적 필터링

평가에서 자주 등장하는 함정 중 하나는 집계 함수의 동작 방식입니다.

- `COUNT(*)`: 테이블의 모든 행을 셉니다. NULL이 포함된 행도 계산에 포함됩니다.
    
- `COUNT(Column)`: 해당 컬럼이 NULL이 아닌 행만 셉니다.
    
- `SUM(Column)`, `AVG(Column)`: NULL 값을 무시하고 계산합니다.
    

따라서 `AVG(Column)`과 `SUM(Column) / COUNT(*)`의 결과는 다를 수 있습니다. 전자는 NULL을 제외한 모수로 나누고, 후자는 NULL을 포함한 전체 행 수로 나누기 때문입니다. 이 차이를 인지하고 상황에 맞는 집계 방식을 선택하는 것이 전문가의 역량입니다.1

#### 1.3.2 COALESCE와 NULLIF를 활용한 방어적 코딩

NULL로 인한 연산 오류를 방지하기 위해 SQL은 강력한 치환 함수들을 제공합니다.

- **`COALESCE(val1, val2,...)`:** ANSI 표준 함수로, 인자 목록 중 첫 번째로 NULL이 아닌 값을 반환합니다. 데이터의 우선순위를 정하여 기본값을 설정할 때 매우 유용합니다 (예: 휴대폰 번호가 없으면 집 전화, 그것도 없으면 이메일 반환).4
    
- **`NULLIF(val1, val2)`:** 두 값이 같으면 NULL을, 다르면 val1을 반환합니다. 이는 '0으로 나누기(Division by Zero)' 에러를 방지하는 데 핵심적인 역할을 합니다. `Amount / NULLIF(Rate, 0)`과 같이 작성하면, Rate가 0일 때 분모가 NULL이 되어 전체 결과가 NULL이 되고, 에러가 발생하지 않습니다.1
    

---

## 제2부: 데이터 타입의 물리적 구조와 암시적 형변환의 위험성

데이터 타입은 단순히 데이터를 담는 그릇의 모양을 정의하는 것을 넘어, 스토리지 효율성, 데이터 정합성, 그리고 무엇보다 **쿼리 성능(Performance)**을 결정짓는 가장 기초적인 설계 요소입니다. SQL 평가에서 '데이터 타입' 항목은 단순히 `INT`와 `VARCHAR`를 구분하는 수준을 넘어, 엔진 내부에서의 처리 방식과 인덱스 활용 여부를 묻는 경우가 많습니다.

### 2.1 암시적 형변환(Implicit Conversion): 성능의 침묵하는 살인자

SQL 엔진은 서로 다른 데이터 타입을 가진 컬럼과 값을 비교할 때, 자동으로 형변환을 시도합니다. 이를 암시적 형변환이라고 합니다. 개발 편의성을 위해 제공되는 기능이지만, 대규모 데이터베이스에서는 성능을 치명적으로 저하시키는 주원인이 됩니다.5

#### 2.1.1 인덱스 사용 불가(SARGability 위반)

가장 심각한 문제는 형변환이 **인덱스 컬럼(좌변)**에서 발생할 때입니다. B-Tree 인덱스는 특정 데이터 타입의 정렬된 구조를 가지고 있습니다. 만약 비교 대상 값의 타입이 더 높은 우선순위(Precedence)를 가져서 인덱스 컬럼이 변환되어야 한다면, 엔진은 인덱스의 정렬 순서를 활용할 수 없게 됩니다.

- **시나리오:** `UserCode`가 `VARCHAR` 타입으로 인덱싱되어 있는데, 쿼리에서 `WHERE UserCode = 101` (정수형)로 검색하는 경우.
    
- **결과:** 데이터베이스의 데이터 타입 우선순위에 따라 `VARCHAR`가 `INT`로 변환됩니다. 즉, `CONVERT(INT, UserCode) = 101` 연산이 수행됩니다. 이 과정에서 테이블의 _모든 행_에 대해 변환 함수가 실행되어야 하므로, **인덱스 시크(Index Seek)**가 아닌 **테이블 스캔(Table Scan)** 또는 **인덱스 스캔(Index Scan)**이 발생합니다. 이는 쿼리 비용을 수천 배 증가시킬 수 있습니다.7
    

#### 2.1.2 유니코드와 비유니코드의 불일치

현대 애플리케이션 프레임워크(Java Hibernate,.NET Entity Framework 등)는 기본적으로 문자열을 유니코드(`NVARCHAR`)로 처리하여 데이터베이스에 전송합니다. 그러나 데이터베이스 컬럼이 레거시 시스템 등의 이유로 비유니코드(`VARCHAR`)로 설계되어 있다면, 엔진은 비교를 위해 전체 컬럼을 유니코드로 변환해야 합니다. 이는 매우 빈번하게 발생하는 성능 저하 패턴이며, 평가 시 실행 계획(Execution Plan) 분석 문제로 자주 출제됩니다.8

해결책:

반드시 비교하는 변수나 파라미터의 타입을 컬럼 타입과 일치시켜야 합니다.

SQL

```
-- 잘못된 예: 암시적 형변환 발생 (UserCode가 VARCHAR인 경우)
SELECT * FROM Users WHERE UserCode = N'A001'; -- N 접두사는 NVARCHAR를 의미

-- 올바른 예: 명시적 형변환 또는 타입 일치
SELECT * FROM Users WHERE UserCode = 'A001'; -- VARCHAR 리터럴 사용
-- 또는
SELECT * FROM Users WHERE UserCode = CAST(@Param AS VARCHAR(20));
```

### 2.2 정밀도(Precision)와 데이터 무결성

데이터 타입 선택은 연산의 정확성에도 영향을 미칩니다. FLOAT나 REAL과 같은 부동소수점 타입은 근사값을 저장하므로, 재무 데이터와 같이 정확한 소수점 계산이 필요한 경우 DECIMAL이나 NUMERIC을 사용해야 합니다.

또한, 날짜 데이터 타입 간의 형변환도 주의가 필요합니다. DATETIME과 SMALLDATETIME을 비교할 때, SMALLDATETIME은 초 단위 이하를 반올림하므로, 특정 시점의 데이터가 포함되거나 제외되는 등 일관성 없는 결과를 초래할 수 있습니다.5

---

## 제3부: 논리적 쿼리 처리 순서와 실행의 미학

SQL은 선언적 언어(Declarative Language)입니다. 사용자는 "무엇(What)"을 원하는지 기술할 뿐, "어떻게(How)" 가져올지는 명시하지 않습니다. 그러나 정확한 쿼리를 작성하고 디버깅하기 위해서는 데이터베이스 엔진이 쿼리를 해석하고 실행하는 **논리적 순서(Logical Order of Execution)**를 반드시 숙지해야 합니다. 이 순서는 우리가 쿼리를 작성하는 문법적 순서(Lexical Order)와는 완전히 다릅니다.9

### 3.1 쿼리 파이프라인의 단계별 분석

SQL 쿼리의 실행 순서는 다음과 같은 파이프라인을 따릅니다. 이 순서를 이해하지 못하면, 왜 `SELECT` 절에서 정의한 별칭(Alias)을 `WHERE` 절에서 사용할 수 없는지 설명할 수 없습니다.

1. **FROM / JOIN:** 데이터의 원천을 파악하고, 테이블 간의 결합(Cartesian Product 후 필터링)을 수행하여 가상 테이블(Virtual Table)을 생성합니다. 조인 조건(`ON`)은 이때 처리됩니다.11
    
2. **WHERE:** 생성된 가상 테이블에서 조건에 맞지 않는 행을 걸러냅니다(Row Filtering). 중요한 점은 이 단계에서는 아직 그룹화나 집계가 수행되지 않았다는 것입니다. 따라서 `WHERE COUNT(*) > 5`와 같은 구문은 불가능합니다.12
    
3. **GROUP BY:** `WHERE` 절을 통과한 행들을 기준 컬럼에 따라 그룹으로 묶습니다. 이 시점부터는 개별 행이 아닌 '그룹' 단위로 데이터가 다루어집니다.11
    
4. **HAVING:** 그룹화된 데이터에 대한 필터링을 수행합니다. 집계 함수(Aggregate Function)를 조건으로 사용할 수 있는 유일한 단계입니다.9
    
5. **SELECT:** 최종적으로 반환할 컬럼이나 계산식을 지정합니다. 윈도우 함수나 `DISTINCT` 처리가 준비되는 단계입니다. 컬럼의 별칭(Alias)이 비로소 여기서 할당됩니다.10
    
6. **ORDER BY:** 결과 집합을 정렬합니다. `SELECT` 단계 이후에 실행되므로, `SELECT` 절에서 정의한 별칭을 정렬 조건으로 사용할 수 있습니다.10
    
7. **LIMIT / OFFSET:** 최종 결과에서 반환할 행의 수를 제한하거나 페이징 처리를 수행합니다.10
    

### 3.2 평가에서의 핵심 포인트: WHERE vs HAVING

평가에서 가장 흔히 묻는 질문 중 하나는 "이 조건을 WHERE 절에 넣어야 하는가, HAVING 절에 넣어야 하는가?"입니다.

- **WHERE:** 개별 행(Row)의 속성을 필터링합니다. (예: `Salary > 50000`, `Department = 'IT'`)
    
- **HAVING:** 그룹의 집계 결과(Aggregate)를 필터링합니다. (예: `AVG(Salary) > 50000`, `COUNT(*) >= 10`)
    

심화 예제:

"평균 급여가 5,000 이상인 부서의 정보만 출력하되, 급여가 3,000 이하인 직원은 평균 계산에서 제외하라."

이 요구사항은 두 단계의 필터링을 요구합니다.

1. 급여 3,000 이하 직원 제외 -> **WHERE** 절 (`WHERE Salary > 3000`)
    
2. 평균 급여 5,000 이상 부서 선택 -> **HAVING** 절 (`HAVING AVG(Salary) > 5000`)
    

SQL

```
SELECT DepartmentID, AVG(Salary)
FROM Employees
WHERE Salary > 3000       -- 1. 집계 전 개별 행 필터링
GROUP BY DepartmentID
HAVING AVG(Salary) > 5000 -- 2. 집계 후 그룹 필터링
ORDER BY AVG(Salary) DESC;
```

이 쿼리의 구조를 논리적 실행 순서에 입각하여 설명할 수 있어야 합니다.9

---

## 제4부: 고급 필터링 전략과 존재(Existence)의 확인

단순한 값 비교를 넘어, 다른 테이블과의 관계를 기반으로 데이터를 필터링하는 능력은 중급 이상의 SQL 사용자가 갖추어야 할 필수 역량입니다. `IN`, `EXISTS`, 그리고 조인을 이용한 필터링 전략을 비교 분석합니다.

### 4.1 IN vs EXISTS: 성능과 동작 원리의 차이

두 연산자는 유사한 결과를 낼 수 있지만, 내부적인 처리 방식(Execution Plan)이 다릅니다.

|**특성**|**IN (Set-based)**|**EXISTS (Boolean check)**|
|---|---|---|
|**동작 방식**|서브쿼리의 모든 결과를 리스트로 가져와 비교 대상과 매칭.|메인 쿼리의 각 행에 대해 서브쿼리가 조건을 만족하는지 확인 (Correlated Subquery).|
|**NULL 처리**|서브쿼리 결과에 NULL이 있으면 `NOT IN` 시 전체 결과가 NULL(Empty)이 됨.3|단순히 행의 존재 여부만 체크하므로 NULL 값의 영향(3VL 문제)을 받지 않음.|
|**최적화(Short-circuit)**|일반적으로 전체 리스트를 스캔해야 함.|조건에 맞는 첫 번째 행을 발견하는 순간 `TRUE`를 반환하고 멈춤 (Short-circuit).|
|**성능 경향**|서브쿼리 결과 집합이 매우 작고 고정적일 때 유리할 수 있음.3|서브쿼리 테이블이 크거나 조건 검사가 복잡할 때 유리함.|

실전 권장 사항:

대부분의 현대적인 옵티마이저는 두 쿼리를 유사하게 최적화하지만, EXISTS를 사용하는 것이 논리적으로 더 안전합니다. 특히 NOT IN 사용 시 NULL 데이터로 인한 논리적 오류(Empty Result)를 원천 차단할 수 있기 때문입니다.

SQL

```
-- 안전하고 효율적인 패턴: EXISTS 사용
SELECT * 
FROM Customers c
WHERE EXISTS (
    SELECT 1 
    FROM Orders o 
    WHERE o.CustomerID = c.ID AND o.TotalAmount > 1000
);
```

### 4.2 ANY와 ALL 연산자

자주 사용되지는 않지만, 평가에서는 논리적 비교 능력을 테스트하기 위해 `ANY`와 `ALL`이 등장합니다.

- `> ANY (...)`: 서브쿼리 결과 중 **최소값보다 크면** 참입니다. (`OR` 개념)
    
- > ALL (...): 서브쿼리 결과 중 최대값보다 커야 참입니다. (AND 개념)
    
    이 연산자들 역시 NULL 값이 포함될 경우 예측 불가능한 결과를 초래할 수 있으므로 주의가 필요합니다.14
    

---

## 제5부: 복합 집계(Aggregation)와 윈도우 함수(Window Functions)

기본적인 `GROUP BY`를 넘어, 계층적 리포팅과 분석을 위한 고급 집계 기능은 SQL 평가의 고급 영역을 차지합니다. 특히 윈도우 함수는 데이터 분석가와 백엔드 개발자 모두에게 필수적인 역량입니다.

### 5.1 ROLLUP, CUBE, GROUPING SETS를 이용한 다차원 집계

리포팅 쿼리 작성 시, 소계(Subtotal)와 총계(Grand Total)를 한 번의 쿼리로 추출해야 하는 경우가 많습니다. `UNION ALL`로 여러 `GROUP BY` 쿼리를 합치는 것은 비효율적입니다(테이블을 여러 번 스캔해야 하므로).16

#### 5.1.1 ROLLUP: 계층적 집계

`ROLLUP`은 명시된 컬럼들의 계층적 순서에 따라 소계를 생성합니다.

- 쿼리: `GROUP BY ROLLUP(Year, Quarter, Month)`
    
- 결과:
    
    1. (Year, Quarter, Month) 별 집계
        
    2. (Year, Quarter) 별 소계 (Month는 NULL)
        
    3. (Year) 별 소계 (Quarter, Month는 NULL)
        
    4. 전체 총계 (Year, Quarter, Month 모두 NULL)
        
        이 방식은 왼쪽에서 오른쪽으로 계층 구조가 있다고 가정할 때 유용합니다.18
        

#### 5.1.2 CUBE: 가능한 모든 조합

`CUBE`는 지정된 차원들의 모든 가능한 조합에 대해 집계를 수행합니다. 데이터 큐브(Data Cube) 분석에 사용됩니다.

- 쿼리: `GROUP BY CUBE(Product, Region)`
    
- 결과: (Product, Region), (Product), (Region), 전체 총계.
    
    모든 차원의 교차 분석이 필요할 때 사용합니다.16
    

#### 5.1.3 NULL 식별과 GROUPING 함수

`ROLLUP`이나 `CUBE` 결과에서 생성된 `NULL`이 실제 데이터가 비어있는 것인지, 집계로 인한 소계인지 구분하기 위해 `GROUPING()` 함수를 사용합니다. 이 함수는 집계 행일 경우 1을, 실제 데이터일 경우 0을 반환하여, `CASE` 문이나 `COALESCE`와 결합해 'Total' 레이블을 붙이는 데 활용됩니다.18

### 5.2 윈도우 함수: 분석의 꽃

윈도우 함수는 행을 그룹핑하지 않으면서도 집계 연산을 수행할 수 있게 해줍니다. 즉, 원본 행의 개수를 유지하면서 통계 값을 붙일 수 있습니다.

- **순위 함수:** `RANK()`(동점자 처리 시 건너뜀, 1, 2, 2, 4), `DENSE_RANK()`(건너뛰지 않음, 1, 2, 2, 3), `ROW_NUMBER()`(고유 순번 부여)는 페이징이나 Top-N 분석에 필수적입니다.
    
- **오프셋 함수:** `LEAD()`와 `LAG()`는 이전 행이나 다음 행의 값을 현재 행으로 가져옵니다. 전월 대비 증감율(MoM)이나 로그 데이터 분석 시 자기 조인(Self-Join) 없이 효율적으로 데이터를 비교할 수 있습니다.
    
- **집계 함수와 윈도우:** `SUM(Salary) OVER (PARTITION BY Dept ORDER BY HireDate)`와 같이 사용하면, 부서별로 입사일 순서에 따른 **누적 합계(Running Total)**를 구할 수 있습니다.
    

---

## 제6부: 집합 연산자(Set Operators)와 효율적 데이터 결합

데이터를 수평으로 결합하는 조인과 달리, 집합 연산자는 데이터를 수직으로 결합합니다. `UNION`, `UNION ALL`, `INTERSECT`, `EXCEPT` 등이 여기에 해당합니다.

### 6.1 UNION vs UNION ALL: 성능의 갈림길

가장 빈번한 면접 질문 중 하나입니다. 두 연산자 모두 두 쿼리의 결과를 합치지만, **중복 제거(Deduplication)** 여부에서 결정적인 차이가 있습니다.

- **`UNION`:** 두 결과 집합을 합친 후, 중복된 행을 제거하기 위해 **정렬(Sort)** 또는 **해시(Hash)** 작업을 수행합니다. 이는 CPU와 메모리 자원을 상당히 소모합니다.20
    
- **`UNION ALL`:** 중복 검사 없이 단순히 두 결과 집합을 덧붙입니다(Append). 추가적인 연산 비용이 거의 없습니다.
    

전략적 선택:

논리적으로 중복이 발생할 수 없거나(예: 2022년 데이터 테이블과 2023년 데이터 테이블 결합), 중복이 있어도 상관없는 경우에는 반드시 **UNION ALL**을 사용하여 불필요한 정렬 부하를 제거해야 합니다. UNION은 중복 제거가 비즈니스 로직상 필수적일 때만 사용해야 합니다.22

구문 제약 사항:

모든 집합 연산자는 결합하려는 두 쿼리의 컬럼 개수, 순서, 그리고 데이터 타입이 호환되어야 합니다. 컬럼의 이름은 달라도 되지만, 최종 결과셋의 컬럼명은 첫 번째 쿼리의 것을 따릅니다.21

---

## 제7부: 데이터 조작(DML)과 테이블 제어(DDL) 및 무결성

데이터를 조회하는 것만큼이나 데이터를 정확하게 생성, 수정, 삭제하고 구조를 정의하는 능력도 중요합니다. 이 영역에서는 트랜잭션(Transaction) 개념과 제약조건(Constraints) 관리가 핵심입니다.

### 7.1 DDL과 제약조건(Constraints) 관리

테이블 생성(`CREATE TABLE`)과 수정(`ALTER TABLE`) 시 가장 중요한 것은 데이터의 품질을 보장하는 제약조건을 올바르게 설정하는 것입니다.

- **Primary Key (PK):** 엔터티 무결성을 보장합니다. NULL을 허용하지 않으며 유일해야 합니다. 대부분의 엔진에서 자동으로 클러스터드 인덱스(Clustered Index)를 생성하여 물리적 저장 순서를 결정합니다.
    
- **Foreign Key (FK):** 참조 무결성을 보장합니다. 자식 테이블에 고아(Orphan) 데이터가 생기는 것을 방지합니다.
    
- **Check Constraint:** 도메인 무결성을 보장합니다. 예를 들어, `Price > 0`과 같이 특정 컬럼의 값의 범위를 제한합니다.24
    
- **제약조건의 수정:** 운영 중인 데이터베이스에서 제약조건을 추가하거나 삭제할 때는 `ALTER TABLE` 명령어를 사용합니다. 제약조건 생성 시 이름을 명시하지 않으면 시스템이 난수 형태의 이름을 부여하여 추후 관리가 어려워지므로, `CONSTRAINT pk_users PRIMARY KEY (id)`와 같이 명시적인 네이밍 컨벤션을 따르는 것이 좋습니다.25
    

### 7.2 뷰(View)의 활용과 갱신 가능성(Updatability)

뷰는 복잡한 쿼리를 추상화하거나 보안 목적으로 사용되는 가상 테이블입니다. 평가에서는 뷰를 통해 데이터를 업데이트할 수 있는 조건에 대해 묻기도 합니다.

- **단순 뷰(Simple View):** 하나의 베이스 테이블만을 참조하며, 집계 함수, `DISTINCT`, `GROUP BY` 등을 포함하지 않는 경우, 뷰를 통한 `INSERT`, `UPDATE`, `DELETE`가 가능하며 이는 베이스 테이블에 직접 반영됩니다.27
    
- **복합 뷰(Complex View):** 조인, 집계, `UNION` 등이 포함된 뷰는 일반적으로 갱신이 불가능합니다. 예를 들어 `AVG(Salary)` 컬럼을 가진 뷰에서 해당 값을 수정한다고 해서, 엔진이 개별 사원의 급여를 역산하여 업데이트할 수 없기 때문입니다.29
    

### 7.3 트랜잭션과 동시성 제어(Concurrency Control)

DML 작업은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability) 즉, **ACID** 속성을 만족해야 합니다. `BEGIN TRANSACTION`, `COMMIT`, `ROLLBACK`을 사용하여 데이터의 정합성을 유지하는 패턴을 이해해야 합니다. 특히, `UPDATE` 문이 실행될 때 데이터베이스는 해당 행이나 테이블에 락(Lock)을 걸게 되며, 이는 다른 세션의 조회를 차단(Blocking)하거나 교착 상태(Deadlock)를 유발할 수 있음을 인지해야 합니다.

---

## 제8부: 데이터 변환과 동적 로직(CASE Expression)

마지막으로, 저장된 데이터를 비즈니스 요구사항에 맞게 변환하고 조건부 로직을 적용하는 기술입니다.

### 8.1 CASE 표현식의 활용

`CASE` 문은 SQL 내에서 IF-THEN-ELSE 로직을 구현합니다.

- **단순 CASE:** `CASE grade WHEN 'A' THEN 'Excellent'... END`
    
- **검색된(Searched) CASE:** `CASE WHEN score >= 90 THEN 'A'... END`.30
    

피벗(Pivot) 테크닉:

CASE 문은 집계 함수와 결합하여 행(Row) 데이터를 열(Column) 데이터로 변환하는 피벗팅에 강력하게 활용됩니다.

SQL

```
-- 연도별 매출을 별도의 컬럼으로 분리하여 조회
SELECT 
    ProductID,
    SUM(CASE WHEN Year = 2022 THEN Revenue ELSE 0 END) AS Rev_2022,
    SUM(CASE WHEN Year = 2023 THEN Revenue ELSE 0 END) AS Rev_2023
FROM Sales
GROUP BY ProductID;
```

이 방식은 별도의 피벗 문법을 지원하지 않는 데이터베이스에서도 범용적으로 사용할 수 있는 표준 패턴입니다.31

### 8.2 문자열 및 날짜 변환 함수

데이터 전처리 과정에서 자주 사용되는 함수들입니다.

- **문자열:** `SUBSTRING`, `CONCAT`, `TRIM`, `UPPER`/`LOWER`. 엔진별로 문법 차이가 있을 수 있으므로(예: `LEN` vs `LENGTH`), ANSI 표준 함수를 우선적으로 익히는 것이 좋습니다.
    
- **날짜:** 날짜 연산(`DATEADD`, `DATEDIFF`)과 포맷팅은 리포팅에서 필수적입니다. 날짜 형변환 시에도 문자열 포맷에 의존하기보다 명시적인 날짜 타입을 유지하는 것이 성능과 정합성 면에서 유리합니다.
    

---

## 결론: SQL 마스터리를 향한 제언

SQL 역량은 단순히 문법을 암기하는 것에서 나오지 않습니다. 진정한 전문가는 **데이터가 디스크에 저장되는 방식**부터, **엔진이 쿼리를 해석하고 최적화하는 과정**, 그리고 **결과가 메모리에 집계되어 반환되는 전체 생명주기**를 머릿속으로 그려낼 수 있어야 합니다.

본 보고서에서 다룬 3치 논리의 엄밀함, 인덱스를 무력화시키는 암시적 형변환의 위험성, 집합 기반 사고(Set-based Thinking)의 중요성, 그리고 실행 계획에 기반한 최적화 전략은 SQL 평가를 통과하기 위한 지식을 넘어, 실무에서 견고하고 확장 가능한 데이터 시스템을 구축하는 토대가 될 것입니다. 평가에 임할 때는 항상 "이 쿼리가 대용량 데이터에서도 효율적으로 작동할 것인가?"와 "데이터의 무결성을 해치지 않는가?"를 자문하며 코드를 작성하시기 바랍니다.

## 핵심 역량 요약표 (Cheat Sheet)

|**역량 영역**|**핵심 개념**|**흔한 실수(Pitfalls)**|**전문가의 접근(Best Practices)**|
|---|---|---|---|
|**기초 이론**|3치 논리(3VL) & NULL|`col = NULL`로 비교하거나 `NOT IN` 서브쿼리에 NULL 포함|`IS NULL` 사용, `NOT EXISTS` 또는 `NOT IN` 사용 시 NULL 필터링 필수|
|**데이터 타입**|암시적 형변환(Implicit Conversion)|인덱스 컬럼과 다른 타입의 변수 비교 (예: `VARCHAR` vs `INT`)|컬럼과 변수의 데이터 타입을 정확히 일치시켜 인덱스 탐색(Index Seek) 유도|
|**조회 처리**|논리적 실행 순서|`SELECT` 절의 별칭을 `WHERE` 절에서 사용 시도|FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY 순서 숙지|
|**필터링**|존재 확인|대용량 서브쿼리에 `IN` 사용|`EXISTS`를 사용하여 조건 만족 시 즉시 종료(Short-circuit) 유도|
|**집계**|계층적 리포팅|`UNION ALL`로 여러 집계 쿼리 결합|`ROLLUP`, `CUBE`, `GROUPING SETS`로 한 번의 스캔으로 처리|
|**집합 연산**|중복 제거 비용|무조건 `UNION` 사용|중복이 없거나 허용되는 경우 `UNION ALL`로 정렬 부하 제거|
|**DML**|데이터 무결성|트랜잭션 처리 누락, 락(Lock) 고려 부족|명시적 트랜잭션 관리 및 배치 처리 시 락 점유 최소화 전략 수립|
|**고급 쿼리**|윈도우 함수|복잡한 Self-Join으로 순위/이전값 계산|`RANK`, `LEAD`, `LAG` 등을 활용하여 가독성과 성능 동시 확보|