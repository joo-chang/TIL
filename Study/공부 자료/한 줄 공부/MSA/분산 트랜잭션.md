마이크로서비스 아키텍처(MSA)에서 분산 트랜잭션을 적용하는 대표적인 방법은 전통적인 2PC(2-Phase Commit) 대신 최종 일관성(Eventual Consistency)에 기반한 패턴들을 활용하는 것이다. 

MSA에서는 강한 트랜잭션보다는 최종 일관성을 지향하는 사가 패턴, 이벤트 소싱, CQRS 등 비동기 패턴을 활용하는 것이 일반적이다. 이를 통해 높은 확장성과 장애 복원력을 확보하며, 보상 트랜잭션을 통한 롤백 전략으로 전체 시스템의 데이터 정합성을 관리한다.

## 1. 사가(Saga) 패턴

사가 패턴은 장기 실행(롱런닝) 트랜잭션을 여러 개의 로컬 트랜잭션으로 나누고, 각 로컬 트랜잭션 성공 시 다음 트랜잭션을 실행하며, 실패 시 이전 단계들에 대한 보상 트랜잭션을 수행하는 방식이다.

### 오케스트레이션(Orchestration) 기반 사가*

중앙 오케스트레이터(조정자)가 각 서비스를 호출하며 트랜잭션 흐름을 제어한다. 실패 시 오케스트레이터가 보상 로직 실행을 명령한다.

### 코레오그레피(Choreography) 기반 사가

별도 오케스트레이터 없이 이벤트를 통해 다음 단계를 유발한다. 각 서비스는 특정 이벤트를 받으면 해당 서비스 로컬 트랜잭션을 수행하고, 성공 이벤트를 발행한다. 실패 시 해당 서비스가 보상 이벤트를 발행해 이전 서비스를 원복하도록 한다.

## 2. 이벤트 소싱(Event Sourcing) & CQRS

이벤트 소싱은 상태 변화를 이벤트로 기록하는 방식이며, CQRS(Command Query Responsibility Segregation)는 읽기와 쓰기 모델을 분리한다.

- 비동기 이벤트를 통해 다른 서비스에 상태 변경 사실을 전파하고, 각 서비스는 필요한 시점에 해당 이벤트를 처리해 자체 DB를 업데이트한다.
- 실패 시 보상 이벤트를 통해 이전 상태로 복원하는 로직을 적용해 최종 일관성을 확보한다.

  

## 3. 최종 일관성(Eventual Consistency) 기반 설계

  

마이크로서비스 간에는 즉각적인 강한 일관성 대신 일정 시간이 지난 후 결국 데이터 상태가 맞추어지는 최종 일관성을 추구한다.

- 비동기 메시지 브로커(Kafka, RabbitMQ)를 활용해 이벤트 전파
- 서비스마다 멱등성(Idempotency)을 보장하도록 설계해 재시도에도 안정적으로 일관성 유지
- 보상 트랜잭션을 통해 장애 상황에서 데이터 원복