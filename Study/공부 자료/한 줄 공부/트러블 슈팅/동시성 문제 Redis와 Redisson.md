## 문제 상황

예매 생성 시 동일한 좌석은 선택할 수 없어야 하는데, 동시에 접근 시 동시성 문제가 발생하여 동일한 좌석을 여러 요청에서 선택하게 되는 문제가 발생

**동시성 이슈가 발생하는 이유**

- **`Race Condition`** 때문
    - 두 개 이상의 스레드가 공유하고 있는 공유 자원을 동시에 수정하려고 할 때 발생하는 문제

## 해결 방법


하나의 스레드가 작업이 완료된 이후에, 다른 스레드가 데이터에 접근할 수 있도록 만들면 되겠다고 판단

## 기술 선택지

> Java에서 지원하는 방법

1. **`synchronized`** 쓰기
    - java의 synchronized는 하나의 프로세스 안에서만 보장이 됩니다.
    - 즉, 서버가 1대일 때는 데이터에 접근을 1대의 서버만 해서 괜찮겠지만, 서버가 2대 혹은 그 이상일 경우 데이터에 접근을 여러 대가 할 수 있게 됩니다.
        - ⇒ 이 경우 Race Condition 또 발생 가능

> DB에서 지원하는 방법

1. **`Pessimistic Lock`** 사용
    - 실제로 데이터에 Lock을 걸어서 정합성을 맞추는 방법
    - exclusive lock을 걸게 되면 다른 트랜잭션에서는 lock이 해제되기 전에 데이터를 가져갈 수 없습니다.
2. **`Optimistic Lock`** 사용
    - 실제 Lock을 이용하지 않고, 버전을 이용해 정합성을 맞추는 방법
    - 먼저 데이터를 읽은 후, update 할 때 현재 내가 읽은 버전이 맞는지 확인하면서 update 하는 방식입니다.
    - 충돌이 발생했을 때의 예외 처리 로직을 잘 설계해야 함 (e.g. facade)

위 두 옵션의 장/단점 비교

- **Pessimistic Lock**
    
    - 장점
        - 충돌이 빈번하게 일어난다면 Optimistic Lock보다 성능이 좋을 수 있습니다.
        - Lock을 통해 업데이트를 제어하기 때문에 정합성이 보장됩니다.
    - 단점
        - 별도의 Lock을 잡기 때문에 성능 감소가 있을 수 있습니다.
- **Optimistic Lock**
    
    - 장점
        - 별도의 Lock을 잡지 않으므로 Pessimistic Lock보다 성능이 좋습니다.
    - 단점
        - 업데이트가 실패 시 재시도 로직을 개발자가 직접 작성해줘야 했습니다.
- **결론**
    
    💡
    
    충돌이 빈번하게 일어난다고 예상된다면 **Pessimistic Lock**을, 빈번하게 일어나지 않을 것이라고 예상된다면 **Optimistic Lock** 쓰면 되겠다고 생각했으나, 결론적으론 **분산락**을 사용하기로 결정했습니다.
    

### DB 말고 Redis를 사용하기로 한 이유

- 프로젝트는 멀티 스레드 환경에서 구동이 되고, 이번 프로젝트는 서버가 하나지만 보통은 서버를 다중화해서 사용합니다.
    
- 이런 분산환경 속에서 동시성 이슈를 해결하기 위해서는 분산락이 필요하다고 생각했습니다.
    
- 분산락은 Redis를 통해 구현하는게 적절하다고 생각했습니다.
    
    **→ Redis는 분산형 메모리 내 데이터 저장소로 분산환경에서의 lock을 구현하는데 적합**
    
    **→ 메모리 내에서 데이터를 다루기 때문에 디스크 기반의 데이터베이스보다 빠른 응답시간 제공**
    
    **→ session에 대해 신경 쓸 필요X**
    
    → **Redis는 기본적으로 In-Memory DB이므로 Disk 기반으로 동작하는 MySQL에 비해 성능이 뛰어남**
    

> Redis에서 지원하는 방법

1. **`Lettuce`** 사용
    - setNX 명령어를 사용해 분산락 구현
    - spin lock 방식
    - 비동기 통신 기반일 때 사용
    - **장점**
        - 구현이 간단합니다.
        - spring data redis를 이용하면 lettuce가 기본이기 때문에 별도의 라이브러리를 사용하지 않아도 됩니다.
    - **단점**
        - spin Lock 방식이므로 동시에 많은 스레드가 Lock 획득 대기 상태라면 레디스에 부하를 줄 수 있음
        - ⇒ 그래서 스레드 슬립을 통해 락 획득 재시도 간에 텀을 둬야 함
        - retry 로직을 개발자가 작성해줘야 함 (spin lock 방식)
2. **`Redisson`** 사용
    - pub-sub 기반으로 락 구현 제공
        
    - **장점**
        - 대부분의 경우에는 별도의 retry 로직을 작성해주지 않아도 됨 (락 획득 재시도를 기본으로 제공함)
        - Lettuce는 계속 락 획득을 시도하는 반면, Redisson은 락 해제가 되었을 때 한 번, 혹은 몇 번만 시도를 하기 때문에 레디스의 부하를 줄여줌 (pub-sub 방식으로 구현되었기 때문)
    - **단점**
        - 구현이 조금 복잡함
        - 별도의 라이브러리를 사용해줘야 함
            - lock을 라이브러리 차원에서 제공해주기 때문에 사용법 학습필요
    - **결론**
        
        💡 Redisson을 쓰기 위해 추가해야하는 라이브러리가 무겁다고 해도, 요즘 환경에서는 크게 부담 될 정도는 아니고, Lettuce의 스핀 락 방식이 레디스에 부담을 줄 수 있고 + Redisson으로 구현하는 분산락이 구현이 간단해서 Redisson 라이브러리로 선택하여 진행했습니다.

