## ORM (Object-Relational Mapping)

> 객체 지향 언어의 객체를 테이블/컬럼과 매핑해 CRUD등의 데이터베이스 작업을 객체 중심으로 처리하는 기법이다.

### 장점

- 생산성 & 유지보수성
	- 엔티티 클래스를 정의해두면, 일반적인 CRUD 로직을 간단히 처리할 수 있다.
	- 복잡한 매핑 로직(관계, 조인 등)을 프레임워크가 상당 부분 자동화 해주므로, 코드가 깔끔해지고 유지보수가 쉬워진다.
- 객체 지향적 개발
	- 객체 중심으로 비즈니스 로직을 구현할 수 있어, 도메인 모델 설계나 애플리케이션 구조가 직관적일 수 있다.
- DB 종속성 감소
	- ORM은 DB 마다 다른 SQL 문법을 어느 정도 추상화 해준다.
	- 특정 DB 기능(방언) 사용을 제외하면, 이식성이 상대적으로 좋아진다.
- 캐싱, 지연 로딩 등 고급 기능
	- 1차 캐시, 2차 캐시, 지연 로딩, 더티 체킹같은 ORM 기능을 통해 성능 최적화나 편의 기능을 활용하기 쉽다.

### 단점

- 쿼리 제어 난이도
	- 복잡한 SQL은 ORM 만으로 표현하기 까다롭거나, ORM 문법이 복잡해진다.
	- ORM이 생성하는 SQL이 비효율적이 될 가능성도 있다.(불필요한 조인, N+1 문제 등)
- 성능 추적 난이도
	- 쿼리가 자동으로 생성되므로, 어떤 SQL이 실제 DB에 날아가는지 모니터링하지 않으면 알기 어렵다.
	- 성능 최적화를 위해서는 JPA 쿼리 로깅, 프로파일링 등을 꼼꼼히 해봐야 한다.

---
## 순수 SQL 작성

> 데이터베이스에 직접 SQL 쿼리를 작성해 실행한다.
> 프로그래밍 언어의 객체와 DB 테이블 연결하는 별도의 추상화 없이, SQL 문이 핵심 로직을 이끈다. 세밀한 SQL 제어 가능

### 장점

- 세밀한 쿼리 제어
	- 개발자가 직접 SQL을 작성하므로, 복잡한 조인, DB 특화 기능 등을 자유롭게 활용 가능
	- 쿼리 성능 튜닝을 직접 제어하기 유리하다.
- 직관적인 SQL 로직
	- DB 처리 과정이 명확하게 드러나서 디버깅이나 최적화 시 파악이 용이할 수 있다.
- 오버헤드 적음
	- ORM 프레임워크의 초기화, 엔티티 스캔, 매핑 과정 등 추가적인 레이어가 없어 성능상 이점을 볼 때가 있다.

### 단점

- 코드 중복 & 유지보수 부담
	- 테이블 구조가 바뀔 때마다, 관련된 모든 쿼리를 수정해야 한다.
	- CRUD 로직이 매우 많은 프로젝트에서 SQL 문이 여기저기 흩어지면 유지보수가 힘들다.
- DB 종속성 증가
	- 특정 DB 문법이나 기능을 많이 활용하면, 다른 DB로 이식 시 어려움이 크다.
	- DB 교체나 구조 변경 시, 전체 SQL을 대거 수정해야 할 수 있다.
- 안정성/타입 문제
	- 문자열 기반 쿼리이므로, 컴파일 시점에 SQL 문법, 파라미터 타입 등을 검증하기 어렵다.
	- 런타임 오류가 발생하거나 SQL Injection 등 보안 이슈 위험이 커질 수 있다. (PreparedStatement 등 사용으로 완화 가능)

---
## 어떤 방식이 적합할까?

### ORM

- DB 모델이 복잡하고, 엔티티 간 관계가 많을 때.
- CRUD 중심의 도메인 로직이 많은 전통적인 애플리케이션(ERP, CRM 등).
- 팀 내에서 객체 지향 설계를 선호하며, 유지보수와 생산성을 중요시할 때.
- DB 벤더를 자주 바꾸거나, 배포 시 테이블 구조 변화가 잦은 경우(ORM이 변경에 대한 추상화 제공).

### 순수 SQL

- 고성능, 고도화된 SQL이 필요한 경우(복잡한 조인, 윈도우 함수, DB 특화 기능).
- 데이터 분석 쿼리, 배치 작업, 보고서 생성 등 SQL 레벨 최적화가 중요할 때.
- 애플리케이션이 간단하여 ORM 도입이 오히려 과도한 경우.
- 프로젝트에 SQL 능숙한 인원이 많고, DB에 직접 최적화와 튜닝을 많이 해야 하는 경우.

### 혼합

- 대다수 CRUD는 ORM으로 처리하되, 일부 복잡한 쿼리는 순수 SQL(네이티브 쿼리, MyBatis, SQL Mapper 등)을 작성.
- 이를 통해 자주 변경되는 일반 로직은 ORM의 생산성 이점을 살리고, 특수 성능이 필요한 부분만 직접 제어한다.

---
## 결론

- ORM
	- 장점: 높은 생산성, 객체 지향적 도메인 모델, 유지보수 편의, DB 추상화.
	- 단점: 복잡한 SQL 제어 어려움, ORM 학습 & 설정 부담, 쿼리 최적화 파악 난이도.

- 순수 SQL
	- 장점: SQL 레벨 최적화 & DB 기능 활용 자유로움, 로직이 명확, 오버헤드 적음.
	- 단점: 보일러플레이트 증가, 유지보수 부담(쿼리 중복), DB 종속성 증가.

따라서 ORM vs 순수 SQL 중 하나만 무조건 선택하기보다, 프로젝트 성격(ORM이 유리한 도메인 지향 개발 vs 고도의 SQL 튜닝 필요성)에 맞춰 섞어 쓰거나, ORM의 네이티브 쿼리 기능 등으로 혼합 전략을 구사하는 것이 현실적인 접근이다.