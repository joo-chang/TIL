## Primitive Type (원시 타입)

원시 타입은 정수, 실수, 문자, 논리 리터럴 등 실제 데이터 값을 저장하는 타입이다.

만약 `int a = 10;` 이 선언 되었다면 정수 값이 할당될 수 있는 a라는 이름의 메모리 공간이 JVM 스택 영역에 생성되고, 10이라는 값이 들어가게 된다.

원시 타입은 메모리 공간에 실제 데이터 갑싱 저장되어 있다.

---
## Reference Type (참조 타입)

참조 타입은 기본 타입을 제외한 타입으로, 객체의 주소를 저장하는 타입이다. 종류는 문자열, 배열, 열거형 상수, 클래스, 인터페이스 등이 있다.

Java에서 객체는 JVM 힙 영역에 저장되며, 참조 타입 변수는 실제 객체의 주소를 JVM 스택 영역에 저장한다. 그리고 객체를 사용할 때마다 참조 변수에 저장된 객체의 주소를 불러와 사용하게 된다.

`Person p = new Person();` 이라는 코드를 작성했다면 p라는 이름의 메모리 공간이 스택 영역에 생성되고, 생성된 p의 인스턴스는 힙 영역에 생성된다, 즉, 스택 영역에 생성된 참조 변수 p는 힙 영역에 생성된 p의 인스턴스 주소 값을 가지게 된다.

---
## 원시 타입 VS 참조 타입

### 성능 관점

- 원시 타입은 스택 영역에 존재하지만 참조 타입은 스택 영역에는 참조 값만 있고, 실제 값은 힙 영역에 존재한다.
- 따라서, 참조 타입은 최소 2번 메모리 접근을 해야 하고, 일부 타입의 경우 값을 필요로 할 때 언박싱 과정을 거쳐야 하므로 원시 타입에 비해 접근 속도가 느린 편이다.

### 메모리 관점

- 원시 타입보다 참조 타입이 사용하는 메모리 양이 압도적으로 높다. 
- 참조 타입은 최근 64비트 JVM을 많이 사용하므로 일반적으로 64 비트를 차지한다.

### NULL 관점

- 원시 타입은 null을 담을 수 없지만, 참조 타입은 null을 담을 수 있다.
- 원시 타입의 경우 값이 없으면 디폴트 값(int = 0, boolean = false)을 반환하기 때문이다.

### 제네릭 관점

- 원시 타입은 제네릭 타입에서 사용할 수 없다.

