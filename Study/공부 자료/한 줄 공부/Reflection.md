- 힙 영역에 로드돼 있는 클래스 타입의 객체를 통해 필드, 메소드, 생성자를 접근 제어자와 상관 없이 사용할 수 있도록 지원하는 API 이다.
- 런타임 시점에 동적으로 특정 클래스의 정보를 추출해낼 수 있는 프로그래밍 기법이다.

> 리플렉션은 구체적인 클래스 타입을 몰라도 그 클래스의 메소드와 타입, 변수들에 접근할 수 있도록 해주는 Java API 이다.

-  클래스 로더를 통해 읽어온 클래스 정보를 사용하는 기술

결국 리플렉션은 `구체적인 클래스 타입을 모를 때 사용하는 것`이다.

### 주요 사용 사례

- **동적 클래스 로딩**
	- 클래스 이름이 문자열 형태로 주어졌을 때, 해당 클래스의 인스턴스를 생성하거나 메소드를 호출할 수 있다.
- **런타임 객체 검사**
	- 객체의 클래스 정보를 런타임에 확인하고, 객체가 가지고 있는 필드나 메서드에 접근할 수 있다.
- **동적 메소드 호출**
	- 메소드 이름을 문자열로 받아 해당 메소드를 동적으로 호출할 수 있다.
- **어노테이션 처리**
	- 런타임에 클래스, 메소드, 필드 등에 적용된 어노테이션 정보를 읽어서 처리할 수 있다.

### 리플렉션 예시

```java
import java.lang.reflect.Method;

public class ReflectionExample {
    public static void main(String[] args) {
        try {
            // "java.lang.String" 클래스에 대한 Class 객체를 가져옴
            Class<?> cls = Class.forName("java.lang.String");
            
            // "substring" 메소드에 대한 Method 객체를 가져옴 (매개변수로 int를 받는 메소드)
            Method method = cls.getMethod("substring", int.class);
            
            // String 인스턴스 생성
            String str = "Hello, World!";
            
            // 리플렉션을 사용하여 메소드 호출
            Object result = method.invoke(str, 7);
            
            System.out.println(result); // "World!" 출력
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```

### 단점

- **성능 저하**
	- 리플렉션을 사용한 코드는 동적으로 처리되기 때문에, 직접적인 코드 호출에 비해 성능이 떨어질 수 있다.
- **타입 안정성 문제**
	- 컴파일 시점에 타입 체크가 이루어지지 않기 때문에, 런타임에 예상치 못한 `ClassCastException` 등의 오류가 발생할 수 있다.
- **보안 제한** 
	- 보안 관리자 설정에 따라 리플렉션 사용이 제한될 수 있으며, `setAccessible`을 사용하여 접근 제어를 우회할 때 보안 문제가 발생할 수 있다.

---

리플렉션은 이러한 단점에도 불구하고, 프레임워크 개발, 유틸리티 라이브러리, 동적 프로그래밍 등 다양한 상황에서 매우 유용하게 사용된다. 그러나 성능과 안정성을 고려하여 필요한 경우에만 적절하게 사용해야 한다.
