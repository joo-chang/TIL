## 동시성 문제 해결 방안

### 락(Lock)

- 데이터에 대한 접근을 제어하기 위해 락을 사용한다. 
- 특정 스레드나 프로세스가 자원을 사용하고 있는 동안 다른 스레드가 접근하지 못하도록 막는다.

#### 비관적 락

자원을 접근하기 전에 락을 획득하고, 작업이 끝난 후 해제한다.

#### 낙관적 락

락 없이 작업을 진행하다가 업데이트 시점에 버전 검사를 통해 충돌 여부를 확인한다.


### 트랜잭션 사용

- DB Transaction을 사용하면 일련의 작업을 원자적으로 처리한다.
- 트랜잭션이 완료되거나 실패할 경우 전체 작업을 취소한다.
- 트랜잭션 격리 수준을 조정하여 동시성 문제를 관리한다.
- 종류 : SERIALIZABLE, REPEATABLE READ, READ COMMITTED, READ UNCOMMITTED


---
# 왜 동시성 제어 시 여러 선택지가 있는데, 분산락을 사용했을까요?

## 낙관적 락과 비관적 락의 선택지

분산락을 채택하기 이전에는 비관적 락으로 동시성 제어 하는 것으로 선택했습니다.

비관적 락으로 데이터를 조회하게 되면 해당 트랜잭션이 끝나기 전까지는 비관적 락을 사용한 데이터에 데이터를 Insert 를 할 수 없게 됩니다.

하지만 성능상 이슈가 있었습니다.

>**낙관적 락**과 **비관적 락**의 **성능 문제**
>**공통점** - 기본적으로 다수의 쓰레드에서 DB 에 Select 문을 날려야 하는 구조이기 때문에 DB CPU 의 점유율이 요청 쓰레드에 비례해서 상승하게 됩니다.
>🔐 **비관적 락** - Lock 이 필요하지 않은 상황에서도 Lock 을 사용하기 때문에, 트래픽이 많은 경우에는 O(N^2) 정도까지 성능이 저하된다는 문제점이 있습니다. 그래서 다른 요청들이 Blocking 이 되어 타임아웃이 될 수 있습니다.
>🔐 **낙관적 락** - 충돌 발생 시 개발자가 수동으로 롤백처리를 해줘야 합니다. 낙관적 락은 충돌이 많이 예상되거나, 충돌이 발생했을 때 손실 비용이 많이 들지 않는 곳에 적합합니다.



비관적 락 - TPS 1400, DB CPU 60%

낙관적 락 - TPS 1800, DB CPU 70% / 충돌 발생 시 손실 비용 높음

TPS 가 높아서 좋지만, DB 의 CPU 가 높아진다면 예상치 못한 DB 오류가 발생할 수 있습니다.

그래서 대용량 트래픽 핸들링 시 CPU 까지도 고려해야 합니다.

그래서 Redis 로 분산락을 적용했습니다.

## 분산락 방식

Lettuce 와 Redisson 로 구현하는 방식이 있습니다.

Lettuce 로 구현 시 스핀락을 사용합니다.

락이 풀릴 때 까지 락에다가 계속 요청을 보내는 것입니다.

그러면 Redis 의 CPU 점유율이 높아지게 됩니다.

Redisson 은 Pub - Sub 구조로 이루어져 있어, 락이 종료 될 때 이벤트를 발행 해, 락 요청을 할 수 있게 합니다.

그래서 Redis 의 CPU 점유율을 낮출 수 있습니다.