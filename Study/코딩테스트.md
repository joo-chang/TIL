## 코딩 테스트 문제 유형 정리

> 코테는 효율성이 존재하기 때문에 시간 복잡도가 매우 중요하다.
> 만약 문제에서 주어진 N이 10,000 이면 O(N^3) 풀이 방법으로는 시간 초과가 날 것이다.
> 
> 반대로 이것은 문제의 힌트와 같다. 시간 복잡도를 고려하여 제한 시간내 성공 가능한 알고리즘이 문제의 정답이기 때문이다.
> 따라서 자료구조, 알고리즘의 시간복잡도를 반드시 알아야한다.

---

## 시간 복잡도

알고리즘에서 시간 복잡도는 문제를 해결하기 위한 연산 횟수를 말한다. 일반적으로 수행 시간은 1억 번 연산을 1초로 간주하여 예측한다.

### 시간 복잡도 유형

- 빅-오메가 : 최선일 때 연산 횟수를 나타낸 표기법
- 빅-세타 : 보통일 때 연산 횟수 표기법
- 빅-오 : 최악일 때 연산 횟수 표기법

코딩 테스트에서는 빅-오 표기법을 기준으로 수행 시간을 계산 하는 것이 좋다.

---

### 예제

#### 수 정렬하기

N개의 수가 주어졌을 때, 오름 차순 정렬 프로그램 작성

N 의 범위 (1 <= N <= 1,000,000) , 제한 시간 2초

#### 알고리즘 적합성 평가

제한 시간이 2초 이기에 2억번 연산 안에 해결하는 알고리즘을 짜야한다.

연산 횟수 = 알고리즘 시간 복잡도 X 데이터의 크기

버블 정렬 - N^2
병합 정렬 - NlogN

버블 정렬 = (1,000,000)^2 = 1,000,000,000,000 > 200,000,000 이므로 부적합한 알고리즘
병합 정렬 = 1,000,000(log(1,000,000)) = 약 20,000,000 < 200,000,000 -> 적합한 알고리즘

---

### 시간 복잡도 도출 기준

1. 상수는 시간 복잡도 계산에서 제외한다.
2. 가장 많이 중첩된 반복문의 수행 횟수가 시간 복잡도의 기준이 된다.

`연산 횟수가 N 인 경우 = 연산 횟수가 3N 인 경우`


---
## 배열과 리스트

### 배열

> 배열은 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조이다.

### 배열 특징

1. 인덱스를 사용하여 값에 바로 접근할 수 있다.
2. 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어렵다. 값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을 이동시키는 과정이 필요하다.
3. 배열의 크기는 선언할 때 지정할 수 있으며, 한 번 선언하면 늘리거나 줄일 수 없다.


### 리스트

> 리스트는 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조이다.

### 리스트 특징

1. 인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야 한다. 접근 속도가 배열보다 느리다.
2. 포인터로 연결되어 있으므로 데이터를 삽입하거나 삭제하는 연산 속도가 빠르다. (배열 2의 단점 보완)
3. 선언할 때 크기를 별도로 지정하지 않아도 된다. 크기가 변하기 쉬운 데이터를 다룰 때 적절하다.
4. 포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡하다.


---

## 구간 합

> 구간 합은 합 배열을 이용하여 시간 복잡도를 줄이기 위해 사용하는 특수 목적 알고리즘이다.

구간 합 알고리즘을 활용하려면 합 배열을 구해야 한다.

### 합 배열 정의

`S[i] = A[0] + A[1] + A[2] + ... + A[i-1] + A[i]`

### 합 배열 만드는 공식

`S[i] = S[i-1] + A[i]`

A = | 3 | 6 |  5  | 10 |  4  |
S = | 3 | 9 | 14 | 24 | 28 |


### 구간 합 구하는 공식

`S[j] - S[i-1] // i에서 j까지 구간 합`

> 배열 2~5 까지 합을 구하려면
> 
> 구간 합 S[5] - S[1]
> 
> S[5] = A[0] ~ A[5]
> S[1] = A[0] ~ A[1]
> 
> S[5] - S[1] = A[2] + A[3] + A[4] + A[5]
> 

---

### 해시 테이블

- key-value 쌍으로 저장되는 특성에 따라 자주 사용된다.
- 유형 보다는 자주 사용되는 자료구조이다.
- key를 통해 평균 O(1)에 Value를 검색할 수 있는 자료구조이다.
- key 값을 해시함수를 사용하여 변환한 값을 index로 삼는다.
- 해시 함수를 사용해 key 값을 Index로 변환하는 과정을 해싱이라고 한다.
- 기존 자료구조인 이진탐색트리나 배열에 비해 굉장히 빠른 속도로 탐색, 삽입, 삭제를 할 수 있다.

### 스택 & 큐

- 많이 사용되지만 단독으로 사용되는 경우보다 구현하는데 필요한 자료구조 정도로 사용되는 경우가 많다.
- ex) 스택 : DFS, 큐 : BFS
- 문제에서 선입선출, 후입선출의 단서가 보이면 사용하자.

#### 스택 (Stack)

스택은 쌓아 올리는 것을 의미한다.

![[Pasted image 20230807002501.png]]

##### 스택 특징

스택은 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고, Top으로 정한 곳을 통해서만 접근할 수 있다.

가장 위에 있는 자료는 가장 최근에 들어온 자료를 가리키고 있으며, 삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓기게 된다.

순서에 따라 자료가 쌓여서 가장 마지막에 삽입된 자료가 가장 먼저 삭제되는 후입 선출(LIFO, Last-In-First-Out) 구조이다.

##### 활용 예시

- 웹 브라우저 방문 기록
- 역순 문자열 만들기
- 실행 취소
- 후위 표기법 계산
- 수식의 괄호 검사


#### 큐 (Queue)

![[Pasted image 20230807002812.png]]

큐는 먼저 들어온 사람이 먼저 나가는 선입선출(FIFO, First-In-First-Out) 구조이다.

##### 큐 특징

정해진 한 곳을 통해 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에서 삽입, 다른 쪽 끝에서 삭제 작업이 이루어진다.

삭제 연산만 수행되는 곳을 프론트(front), 삽입 연산만 수행되는 곳을 리어(rear)

##### 활용 예시

- 우선 순위가 같은 작업 예약
- 은행 업무
- 콜센터 고객 대기시간
- 프로세스 관리
- 너비 우선 탐색 (BFS, Breadth-First Search) 구현
- 캐시 구현

---
