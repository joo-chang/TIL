# 운영체제란?

## 운영체제
운영체제란 컴퓨터 시스템의 핵심 소프트웨어로, 컴퓨터 하드웨어와 응용프로그램 간의 상호작용을 관리하고 제어하는 역할을 한다.
<br>

## 운영체제 목적 
사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 응용 프로그램이 동작하도록 지원하고, 시스템 자원을 효율적으로 관리하여 응용 프로그램이 원할하게 동작할 수 있도록 한다.
<br>

## 운영체제 역할

### CPU 스케줄링과 프로세스 관리
CPU 소유권을 어떤 프로세스에 할당할지, 프로세스의 생성과 삭제, 자원 할당 및 반환을 관리한다. 또한, 프로세스 간 통신(IPC), 동기화 및 데드락 감지 및 해결과 같은 기능을 제공하여, 멀티태스킹 환경에서 프로세스가 원활히 실행될 수 있도록 한다.

### 메모리 관리
한정된 메모리를 어떤 프로세스에 얼만큼 할당해야 하는지 관리한다.

### 파일 시스템 관리
파일 생성, 읽기, 쓰기 등 파일 시스템 관련 작업을 관리한다.

### I/O 디바이스 관리
I/O 디바이스와 컴퓨터 간에 데이터를 주고 받는 것을 관리한다.
<br>

## 운영체제 구조

### 커널 (Kernel)
커널은 용어 자체로도 '핵심의' 로 운영체제에서 중요한 역할이다. 
커널은 전반적으로 **프로세스**를 뜻한다.
프로세스 관리, 메모리 관리, 저장공간 관리, 연결된 장치 관리 등 컴퓨터에 속한 모든 자원을 관리하는 역할을 한다.

### 인터페이스 (Interface)
인터페이스는 사용자의 명령을 컴퓨터에 전달하고 결과를 알려주는 소통 역할을 한다.
인터페이스 종류는 GUI (Graphical User Interface), CLI(Command Line Interface) 가 대표적이다.
GUI는 그래픽 요소를 사용하여 소통하게끔 하여 사용자 편의성을 가진 인터페이스이고, CLI는 명령어로 소통하는 인터페이스이다.

### 시스템 콜 (System Call)
시스템 콜은 운영체제가 커널에 접근하기 위한 인터페이스이다.
사용자나 프로그램이 직접적으로 컴퓨터 자원에 접근하는 것을 막고 커널을 보호하기 위해 만든 코드 집합이다. 운영체제는 시스템 콜을 통해서만 커널에 접근 하도록 디자인되었다.

### 드라이버 (Driver)
드라이버는 프린터 키보드 등 하드웨어 장치와 운영체제 간의 통신을 가능하게 하는 소프트웨어이다. 
<br>

> 운영체제는 컴퓨터 하드웨어와 응용프로그램 간의 인터페이스 역할을 하는 컴퓨터 시스템 핵심 소프트웨어입니다. 
> 운영체제는 자원 관리, 프로세스 관리, 메모리 관리, 파일 시스템, 입출력 관리 등의 역할을 합니다.

---
# 프로세스 메모리 구조

- 메모리 공간 종류 4가지 : 코드 영역, 데이터 영역, 힙 영역, 스택 영역

![[Pasted image 20240312160044.png]]

### 코드 영역 (Code / Text)
실행할 프로그램의 코드가 CPU가 해석 가능한 기계어로 저장된다. CPU는 이 영역에서 명령어를 하나씩 가져와 처리한다.

### 데이터 영역 (Data)
전역 변수와 static 변수가 저장된다.

### 스택 영역 (Stack)
지역 변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역이다. 함수가 호출될 때마다 환경 등 특정 정보가 저장되는 독립적인 공간이다.
스택은 함수 호출과 함께 할당되며, 호출 종료 시 소멸된다.
(stack 영역 초과 시 stack overflow 에러 발생)
### 힙 영역 (Heap)
생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간이다. 
사용자가 직접 관리하는 영역으로 메모리 공간이 동적으로 할당되고 해제된다. 

위 그림을 보면 스택, 힙은 화살표로 되어 있는데, 프로세스가 실행되는 동안 크기가 늘었다 줄어들었다하는 동적 공간이기 때문에 화살표로 표현되었다.

> 메모리에는 크게 코드, 데이터, 힙, 스택 영역이 있습니다.
> `코드`는 소스코드가 들어가는 공간이고, `데이터`는 전역 변수, static 변수가 할당되는 부분입니다.
> `힙`은 사용자가 직접 관리하는 영역으로 데이터가 동적으로 할당되는 공간이고,
> `스택`은 함수의 호출 정보, 지역 변수, 매개변수들에 의해 늘어나거나 줄어드는 메모리 영역입니다. 함수 호출 시 할당되며, 종료 시 소멸됩니다.

---
# Process, Thread 비교

## 정의

- 프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위. 실행중인 프로그램
- 스레드 : 프로세스 내에서 동시에 진행되는 실행 단위 (멀티 스레드)

## 메모리 영역

- 프로세스 : 각각의 독립된 메모리 영역(코드, 데이터, 힙, 스택)을 할당 받는다.
- 스레드 : 프로세스 내에서 각각 스택만 따로 할당 받고, 코드, 데이터, 힙은 프로세스 간 공유 된다.

## Context Switching

- 프로세스 컨텍스트 스위칭 : 커널 모드 전환 + CPU 상태 교체 + 메모리 영역 상태 교체 (MMU 수정 + TLB 캐시 비우기)
- 스레드 컨텍스트 스위칭 : 커널 모드 전환 + CPU 상태 교체

  

## 차이점

| 차이점           | 프로세스          | 스레드                   |
| ---------------- | ----------------- | ------------------------ |
| 정의             | 실행중인 프로그램 | 프로세스 실행 단위       |
| 생성 / 종료 시간 | 많은 시간 소요    | 적은 시간 소요           |
| 컨텍스트 스위칭  | 많은 시간 소요    | 적은 시간 소요           |
| 데이터 공유      | IPC 사용          | 공유 메모리 사용         |
| 자원 소모량      | 많음              | 적음                     |
| 메모리 독립성    | 독립적            | 스택만 독립적, 이외 공유 |
|                  |                   |                          |
> `프로세스`는 실행중인 프로그램이고, 
> `스레드`는 프로세스 안에서 실행되는 흐름 단위입니다.
> `프로세스`는 메모리와 CPU를 프로세스마다 할당 받아서 사용하는데, 
> `스레드`는 프로세스 안에서 다른 스레드와 메모리와CPU를 공유해서 사용합니다. 스레드는 스택 메모리만 각각 할당 받습니다.

---
# Thread에서 독립적인 Stack 영역이 필요한 이유


스레드는 프로세스가 할당 받은 자원을 이용하는 실행 단위이다. 
스레드끼리 프로세스의 자원을 공유하면서 프로세스의 실행 흐름의 일부가 되기 때문에,동시 작업이 가능하다.

스레드는 프로세스의 4가지 메모리 영역 중 Stack만 할당받아 복사하고, 나머지 메모리 영역을 프로세스 내의 다른 스레드들과 함께 공유한다. (각각의 스레드는 별도의 Stack 을 가지고 있다.)

스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하는 메모리 공간으로, 독립적인 함수 호출이 가능하다. 이는 독립적인 실행 흐름이 추가 된다는 말이다.

결과적으로 스레드에서 독립적인 Stack 메모리 영역이 필요한 이유는 하나의 프로세스를 다수의 실행 단위인 스레드로 구분하여 자원을 공유하고, 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 올리기 위해서다.

> 스레드에 독립적인 Stack 영역이 필요한 이유는 하나의 프로세스를 다수의 실행 단위인 스레드로 구분하여 자원을 공유하고, **자원의 생성과 관리의 중복성을 최소화**하여 수행 능력을 올리기 위해서입니다.


---
# 멀티 프로세스와 멀티 스레드 비교

## 멀티 프로세스

멀티 프로세스는 운영체제에서 하나의 응용 프로그램에 대해 동시에 여러 개의 프로세스를 실행할 수 있게 하는 기술을 말한다.
보통 하나의 프로그램은 하나의 프로세스가 메모리에 생성되지만 부가 기능을 위해 여러 개의 프로세스를 생성하는 것이다.

### 장점

#### 프로그램 안전성

멀티 프로세스는 각 프로세스가 독립적인 메모리 공간을 가지므로, 한 프로세스가 비정상적으로 종료되어도 다른 프로세스에 영향을 주지 않는다. 따라서 프로그램 전체의 안전성을 확보할 수 있다.

#### 프로그램 병렬성

멀티 프로세스와 여러 개의 CPU 코어를 활용하여, 다중 CPU 시스템에서 각 프로세스를 병렬적으로 실행하여 성능을 향상 시킬 수 있다.

이 장점은 멀티 스레드의 장점이기도 하다.

#### 시스템 확장성

멀티 프로세스는 각 프로세스가 독립적이므로, 새로운 기능이나 모듈을 추가하거나 수정할 때 다른 프로세스에 영향을 주지 않는다. 따라서 시스템 규모를 쉽게 확장할 수 있다.

### 단점

#### Context Switching Overhead

멀티 태스킹 구성의 핵심 기술인 컨텍스트 스위칭 과정에서 성능 저하가 올 수있다. 
특히 프로세스를 컨텍스트 스위칭하면 `CPU는 다음 프로세스의 정보를 불러오기 위해 메모리를 검색하고, CPU 캐시 메모리를 초기화하며, 프로세스 상태를 저장하고, 불러올 데이터를 준비해야하기 때문에` 빈번한 컨텍스트 스위칭 작업으로 인해 오버헤드가 발생할 수 있다.
반면에, 스레드를 컨텍스트 스위칭하면 프로세스 스위칭보다 가벼워 훨씬 빠르고 좋다.

따라서, 멀티 프로세스 환경에서는 Context Switching Overhead를 최소화하는 방법이 중요하다.
프로세스 수를 적정하게 유지하거나, I/O 바운드 작업이 많은 프로세스와 CPU 바운드 작업이 많은 프로세스를 분리하여 관리하고, CPU 캐시를 효율적으로 활용하는 등의 방법을 고려해 봐야 한다.

#### 자원 공유 비효율성

멀티 프로세스는 각 프로세스가 독립적인 메모리 공간을 가지므로, 메모리 사용량이 증가하게 된다.
각 프로세스 간 자원 공유가 필요할 경우 어렵고 복잡한 통신 기법인 IPC(Inter-Process Commnuication) 를 사용해야 한다.
IPC는 실행 중인 프로세스 간에 정보를 주고받는 메커니즘을 말한다. 이를 위해 파이프, 소켓, 메세지 큐 등 다양한 방법이 사용된다. 그런데 IPC 자체로 오버헤드가 발생한다. 예를 들어, 파이프나 소켓과 같은 IPC 기법은 데이터를 복사하거나 버퍼링하는 과정에서 성능 저하가 발생할 수 있기 때문이다. 또한 코드의 복잡도를 증가시킨다.

<br>

## 멀티 스레드

스레드는 하나의 프로세스 내에 있는 실행 단위이다. 멀티 스레드는 하나의 프로세스 안에 여러 개의 스레드가 있어, 두 가지 이상의 동작을 동시에 처리하도록 하는 것이다.

멀티 프로세스와의 차이점은 웹 브라우저로 예시를 들어보면 웹 브라우저에서 여러 탭이나 여러 창이 각각 프로세스로 멀티 프로세스이고, 멀티 스레드는 단일 탭 내에서 브라우저 이벤트 루프, 네트워크 처리, I/O 및 기타 작업을 관리하고 처리하는 데 사용된다.

### 장점

많은 운영체제들이 멀티 프로세싱을 지원하지만 멀티 스레드를 기본으로 하고 있다. 

#### 프로세스보다 가벼움

스레드는 프로세스 내에서 생성되기 때문에 실행 환경 설정 작업이 매우 간단하여 생성 및 종료가 빠르다.
또한, 코드, 데이터, 힙 영역을 서로 공유하기 때문에 데이터 용량이 프로세스보다 작다.

#### 자원의 효율성

멀티 스레드는 하나의 프로세스 내에서 생성되기 때문에, 공유 메모리에 대해 스레드 간 자원 공유가 가능하다. 

#### Context Switching 비용 감소

스레드도 컨텍스트 스위칭 오버헤드가 존재하지만, 프로세스 컨텍스트 스위칭에 비하면 훨씬 낮다.
프로세스 컨텍스트 스위칭 시 CPU 캐시를 모두 초기화하고, 새로운 프로세스 정보를 적재해야 하므로 높은 비용이 든다. 하지만 스레드는 공유 자원을 제외한 스레드 정보(stack, register) 만 교체하면 되므로 상대적으로 낮다.

#### 응답 시간 단축

앞선 장점들로 인해 응답 시간이 빠르다.

### 단점

#### 안정성 문제

멀티 스레드는 하나의 스레드에서 문제가 발생하면 다른 스레드들도 영향을 받아 전체 프로그램이 종료될 수 있다.
하지만 이 문제는 적절한 예외 처리, 에러 발생 시 새로운 스레드를 생성하거나 스레드 풀에서 잔여 스레드를 가져오는 등의 방법으로 해결할 수 있다.

#### 동기화로 인한 성능 저하

멀티 스레드는 여러 개의 스레드가  공유 자원에 동시 접근할 수 있기 때문에 동기화 문제가 발생할 수 있다. 따라서 스레드 간 동기화(syncronized)는 데이터 접근을 제어하기 위한 필수적인 기술이다.

동기화 작업은 여러 스레드 접근을 제한하는 것이기 때문에 병목 현상이 일어나 성능 저하될 가능성이 높다.

이를 해결하기 위해 임계 영역에 대해 뮤텍스, 세마포어 방식을 활용한다.

#### 데드락 (교착 상태)

데드락은 다수의 프로세스나 스레드가 서로의 자원을 점유하고 무한정 자원을 기다리는 상황에서 발생하는 교착상태를 말한다.

데드락 방지를 위해 상호배제, 점유와 대기, 비선점, 순환대기 등의 알고리즘을 사용하면 된다.

#### Context Switching Overhead

컨텍스트 스위칭 오버헤드 비용 자체를 무시할 수는 없다. 스레드 수가 많을 수록 컨텍스트 스위칭이 많이 발생하고, 성능 저하로 이어질 수 있다.

>**멀티 프로세스**는 여러 개의 독립적인 프로세스가 동시에 실행되는 것을 말합니다. 각 프로세스는 독립된 메모리 공간(코드, 데이터, 힙, 스택 등)을 할당받으며, 다른 프로세스의 자원에 접근할 수 없습니다. 프로세스 간 통신을 위해서는 Inter Process Communication(IPC) 기법(예: 파이프, 소켓, 공유 메모리 등)을 사용해야 합니다. 멀티 프로세스는 하나의 프로세스에 문제가 발생해도 다른 프로세스에는 영향을 미치지 않는 격리성을 가지고 있지만, 프로세스 간 컨텍스트 스위칭이나 IPC로 인한 오버헤드가 크다는 단점이 있습니다.
> **멀티 스레드**는 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행되는 것을 말합니다. 모든 스레드는 부모 프로세스의 자원(메모리 공간)을 공유하며, 각각 별도의 스택을 가지고 있어 독립적인 실행 흐름을 가집니다. 멀티 스레드는 스레드 간 데이터 공유가 용이하고, 컨텍스트 스위칭 비용이 상대적으로 낮아서 효율적인 자원 사용과 빠른 실행 속도를 가질 수 있습니다. 하지만, 스레드 간 자원 공유로 인해 데이터 일관성 및 동기화 문제가 발생할 수 있으며, 한 스레드에서 발생한 문제가 전체 프로세스에 영향을 미칠 수 있다는 단점이 있습니다.

---
ㄴ# 문맥 교환 (Context Switch)

문맥 교환은 멀티태스킹 운영체제에서 CPU가 이전 작업(프로세스 or 스레드)에서 다른 작업으로 전환할 때 발생하는 과정을 말한다. 이 과정에서 운영체제는 현재 실행 중인 작업의 상태(문맥)을 저장하고, 다음에 실행할 작업의 상태를 메모리에 불러와 CPU에 적재한다. 

이때 한 프로세스의 문맥은 프로세스 제어 블록(PCB)에 기록되어 있다.

## 문맥 교환 시점

### 멀티 태스킹

멀티 태스킹은 다수의 프로세스가 하나의 CPU 자원을 나눠 사용하는 것이다.
실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아 수행되는데, 프로세스가 **CPU를 할당 받을 때** 문맥 교환이 일어난다.
매우 빠른 속도로 처리되기 때문에 동시에 처리되는 것처럼 느껴진다.

### 인터럽트 처리

인터럽트는 컴퓨터 시스템에서 예외 상황이 발생했을 때 CPU에게 알려 처리할 수 있도록 하는 것이다.
**인터럽트가 발생했을 때** 문맥 교환이 일어난다.

- I/O request : 입출력 요청
- time slice expried : CPU 사용시간 만료
- fork a child : 자식 프로세스 생성
- wait for an interrupt : 인터럽트 처리 대기

### 사용자 및 커널 모드 전환

운영체제에서 사용자 모드와 커널 모드 사이의 전환이 필요할 때 필수는 아니지만 운영체제에 따라 문맥 교환이 발생한다.


## 문맥 교환이 일어나는 과정

1. 요청 발생 : 인터럽트 또는 트랩에 의한 요청이 발생
2. PCB에 저장 : 운영체제는 현재 실행중인 프로세스의 정보를 PCB에 저장
3. CPU 할당 : 운영체제는 다음 프로세스의 정보를 PCB에서 가져와 CPU를 할당

<br>

---
# Process Control Block (PCB)

프로세스 제어 블록은 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조이다. 

운영체제가 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보를 가지고 있는 데이터베이스를 PCB라 한다.

운영체제에서 프로세스는 PCB로 나타내어지며, 프로세스에 대한 중요한 정보를 가지고 있는 자료이다. 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.

프로세스는 CPU가 처리하던 작업의 내용들을 자신의 PCB에 저장하고, 다음에 다시 CPU를 점유하여 작업을 수행할 때 PCB로 부터 해당 정보들을 CPU에 넘겨와서 계속해서 하던 작업을 진행할 수 있게 된다.



---
# 경쟁 상태(Race Condition)와 임계 영역(Critical Section)

## 경쟁 상태 (Race Condition)
경쟁 상태란 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과 값에 영향을 줄 수 있는 상태

### 경쟁 상태가 발생하는 경우

> 유저모드: 사용자가 접근할 수 있는 영역을 제한적으로 두고, 프로그램의 자원에 함부로 접근하지 못하는 모드. 코드를 작성하고, 프로세스를 실행하는 행동을 할 수 있다.

> 커널모드: 모든 자원(CPU, 메모리 등) 접근, 명령 가능한 모드

- 커널 코드 실행 중 인터럽트가 발생하는 경우
	- 커널 모드에서 데이터를 로드하여 작업 도중 인터럽트가 발생하여 같은 데이터를 조작하는 경우에 발생할 수 있다.
	- 커널이 가진 전역 변수는 모든 프로세스의 공유물이므로 경쟁상태의 가능성이 있다.
	- 해결 방법 : 커널 모드에서 작업을 수행하는 동안 인터럽트를 Disable하여 CPU 제어권을 가지지 못하도록 한다.
- 프로세스가 시스템 콜을 하여 커널 모드로 진입해서 작업 도중 문맥 교환이 발생하는 경우
	- 프로세스1이 커널 모드에서 작업 중 시간 초과로 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우를 말한다.
	- 해결 방법 : 커널 모드 작업 시 CPU 제어권이 넘어가지 않도록 한다.
- 멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근할 경우
	- 멀티 프로세스 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우 발생할 수 있다.
	- 해결 방법 : 커널 내부에 있는 공유 데이터에 접근할 때마다, 그 데이터에 대해 Lock / Unlock 함으로써 해결할 수 있다.

## 임계 영역 (Critical Section)

임계 영역은 운영체제에서 여러 프로세스가 데이터를 공유하면서 수행될 때 각 프로세스에서 공유 자원에 접근하는 프로그램 코드 부분을 의미한다.

프로세스 간에 공유 자원을 접근하는 데 있어서 문제가 발생하지 않도록 **공유 자원의 독점을 보장해 주어야 하는 영역**이다.

### 임계 영역 문제를 해결하기 위한 3가지 조건

- 상호배제 (Mutual Exclusion)
	- 한 프로세스가 자신의 임계 영역이면 다른 프로세스들은 임계 영역에 진입할 수 없다.
- 진행 (Progress)
	- 아무도 임계 영역에 없다면 진입하고자 하는 프로세스를 진입하게 해줘야 한다.
	- 다음에 어떤 프로세스가 임계 영역에 진입해야 하는지 유한한 시간에 결정되어야 한다.
- 유한 대기 (Bounded Waiting)
	- 프로세스가 임계 영역에 진입하기 위해 무한정으로 기다리는 현상이 발생해서는 안된다.

임계 영역은 뮤텍스, 세마포어, 모니터 등의 동기화 기법을 사용하여 관리할 수있다. 이러한 동기화 기법들은 동시에 임계 영역에 접근하는 것을 막아서 데이터 일관성과 시스템 안정성을 보장한다.

> 경쟁 상태란 여러 프로세스 또는 여러 스레드가 공유 데이터를 동시에 접근할 때 공유 데이터에 대한 실행 순서에 따라 실행 결과가 달라지는 상황을 말합니다.
> 경쟁 상태는 상호배제를 안했을 때 나타나는 현상입니다.
> 임계 영역은 둘 이상의 프로세스에 의해 동시에 접근하면 안되는 공유 자원에 접근하는 영역(코드 영역) 즉, 프로그램에서 공유 데이터를 이용하는 부분입니다.

---
# 경쟁 상태를 막기 위한 방법

## 뮤텍스 (Mutex)

뮤텍스는 공유된 자원의 데이터를 여러 스레드가 접근하는 것을 막는 방법이다.
즉, 임계 영역(각 프로세스에서 공유 데이터를 엑세스하는 프로그램 코드 부분)을 가진 스레드들의 런타임이 서로 겹치지 않게 단독으로 실행되게 하는 기술이다.

다중 프로세스들이 공유 리소스에 대한 접근을 조율하기 위해 Lock / Unlock을 사용하는데, 상호배제를 함으로써 두 스레드가 동시에 사용할 수 없다는 뜻이다.

## 세마포어 (Semaphore)

공유된 자원의 데이터를 여러 프로세스가 접근하는 것을 막는 것이다. 또한, 리소스의 상태를 나타내는 간단한 카운터라고 할 수 있는데, 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 이용하게 되며, 리소스를 경쟁적으로 사용하는 다중 프로세스에서 행동을 조정하거나 동기화 시키는 기술이다.

하나의 스레드만 들어가게 할 수 있고 여러 개의 스레드가 들어가게 할 수도 있다.

Q1. 세마포어는 경쟁상태를 어떻게 해결하나?
Q2. 스핀락이 무엇?
Q3. busy waiting, sleep lock?
Q4. 뮤텍스 세마포어 차이 / 
A4. 통제 해제 방식에서 차이가 있다 뮤텍스 락방식 

우선순위 역전 - 우선순위가 낮은 애가 먼저 선점하는 경우 / 동기화  해결 방법 - 우선순위 올림 우선순위 상속

## 모니터

모니터는 뮤텍스와 조건 변수를 함께 사용하여 임계 영역에 대한 접근을 관리하는 고수준 동기화 방법이다. 모니터 내의 모든 메소드는 자동적으로 임계 영역이 되며, 동시에 하나의 스레드만이 모니터 내의 메소드를 실행할 수 있다.

> 경쟁 상태를 막기 위한 방법은 대표적으로 뮤텍스와 세마포어 동기화 기법이 있습니다.
> 뮤텍스는 공유 자원에 대해 여러 스레드가 접근하지 못하도록 막는 방법입니다. 임계 영역에 하나의 스레드만 접근하도록 하여 경쟁 상태를 방지할 수 있습니다. 세마포어는 동시에 자원에 접근할 수 있는 스레드나 프로세스의 최대 수를 제한하는 동기화 기법입니다.

---
# 임계 영역, 경쟁 상태, 뮤텍스, 세마포어 정리

> 임계 영역은 둘 이상의 프로세스에 의해 동시에 접근하면 안되는 공유 자원에 접근하는 영역입니다. 이를 어겼을 때 경쟁 상태가 발생하는데, 경쟁 상태가 발생하지 않도록 하는 방법은 뮤텍스와 세마포어가 대표적입니다. 뮤텍스는 공유 자원에 대해 여러 스레드가 접근하지 못하도록 막는 방법입니다. 임계 영역에 하나의 스레드만 접근하도록 하여 경쟁 상태를 방지할 수 있습니다. 세마포어는 동시에 자원에 접근할 수 있는 스레드나 프로세스의 최대 수를 제한하는 동기화 기법입니다.

---
# 교착 상태(DeadLock)와 발생 조건 4가지

## 교착 상태 (DeadLock)

데드락은 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하고 무한정 다음 자원을 기다리는 상태를 말한다.
시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

## 데드락 발생 조건

### 1. 상호 배제 (Mutual exclusion)

자원은 한번에 한 프로세스만 사용할 수 있다.

### 2. 점유 대기 (Hold and Wait)

최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 한다.

### 3. 비선점 (No Preemption)

다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없다.

### 4. 순환 대기 (Circular Wait)

프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.

대기하는 프로세스의 집합 (P0, P1, ... Pn)에서  P0은 P1이 점유한 자원을 기다리고, P1 -> P2 ... Pn -> P0 이런 식으로 순환적 대기 상태가 존재한다.




---
# 교착 상태 해결 방법

데드락을 방지하는 방법은 데드락 발생 조건 4가지 중 하나 이상을 제거하거나 회피하는 데 중점을 둔다.

1. 자원을 할당할 때 애초에 조건이 성립되지 않도록 설계한다 (예방)
2. 교착 상태 가능성이 없을 때만 자원이 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 은행원 알고리즘을 사용한다. (회피)
3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개씩 지운다. (탐지 & 회복)
4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료한다. 현대 운영체제는 이 방법을 채택했다. 예를 들어 프로세스 실행 중 '응답 없음' 발생

## 예방 (Prevention)

교착 상태 발생 조건 중 하나를 제거하면서 해결한다. (자원 낭비 매우 심함)

- 상호 배제 부정
	- 여러 프로세스가 공유 자원을 사용
- 점유 대기 부정
	- 프로세스 실행 전 모든 자원을 할당
- 비선점 부정
	- 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원을 반납
- 순환 대기 부정
	- 자원에 고유 번호를 할당한 후 순서대로 자원을 요구
	- 따라서 프로세스의 속도를 떨어뜨리고 자원의 접근을 불필요하게 거부하여 비효율적이다.

## 회피 (Avoidance)

교착 상태 발생 시 회피하는 방법

- 은행원 알고리즘 (Banker's Algorithm)
	- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래
	- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안전 상태로 남아있게 되는지 사전에 검사하여 교착 상태를 회피
	- 안전 상태면 자원 할당, 아니면 다른 프로세스들이 자원을 해지할 때까지 대기

> [!note] 은행원 알고리즘  정리해야됨
> CS 책 pdf 참고



## 탐지 & 회복 (Detection and Recovery)

교착 상태가 되도록 허용한 후 회복시키는 방법

### 탐지

자원 할당 그래프를 통해 교착 상태를 탐지한다.
데드락 탐지 알고리즘을 사용하여 시스템을 주기적으로 검사하고 데드락 존재 여부를 확인한다.

### 회복

데드락을 해결하기 위해 하나 이상의 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법이다.
프로세스 종료 방법으로는 교착 상태의 프로세스를 모두 중지하거나, 교착 상태가 제거될 때까지 하나씩 프로세스를 중지하는 방법이 있다.
자원 선점 방법으로는 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 해당 프로세스를 정지시키고 다른 프로세스에게 할당하거나 우선순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원을 선점하는 방법이 있다.


## 점유 대기

1. 프로세스가 작업을 시작하기 전에 필요한 모든 자원을 요청하여 할당받도록 하는 것이다.
2. 프로세스가 전혀 자원을 갖지 않은 상태에서만 자원 요청을 허용하고, 프로세스가 자원을 추가 요청하려면 가지고 있는 자원을 모두 해제해야 요청을 승인한다.
- 예를 들어 DVD 드라이버에서 디스크로 파일 하나를 복사해서 정렬 후 프린터로 출력한다고 했을 때, 
- 방법 1은 나중에 필요한 프린터도 프로세스 초기에 점유해서 다른 프로세스가 프린터를 사용하지 못하게 하는 것이다.
- 방법 2는 DVD 드라이버에서 디스크로 파일 하나를 복사한 후 DVD 드라이버와 디스크 파일을 모두 해제하고, 다시 디스크 파일과 프린터를 점유한 후 프린터를 한 후 모두 해제한다.

## 비선점

- 어떤 프로세스가 자원을 가지고 실행 중 다른 자원을 요청 했는데 그 자원을 점유할 수 없다면 지금까지 가지고 있던 자원으 ㄹ모두 해제하도록 한다. 그 후, 프로세스는 원래 자원과 새로 원하는 자원을 함께 요청해야 한다.
- 한 프로세스에서 다른 프로세스가 점유한 자원을 원하면, 운영체제는 다른 프로세스가 점유한 자원을 강제로 반납시키고 그것을 원하는 프로세스에게 할당할 수 있다. 이 방법은 프로세스들이 서로 다른 우선순위를 가지고 있을 때 우선순위를 기준으로 선점하여 교착 상태를 예방할 수 있다. 
- 비선점의 단점은 프로세서 레지스터나 기억장치 레지스터와 같이 쉽게 저장되고 이후 복원이 쉬운 자원에는 사용 가능하지만 프린터와 같은 자원은 활용이 어렵다.






---
# 기아 상태

---
# CPU 스케줄링? 스케줄링 종류

- 준비 큐 있는 프로세스에 대해 CPU를 할당하는 방법

> CPU 스케줄러는 운영체제에서 프로세스들이 CPU를 사용하기 위해 경쟁하는 상황에서 어떤 프로세스에 CPU를 할당할지 결정하는 역할을 하는 부분입니다.
> 종류는 FCFS, SJF, SRT, Priority Scheduling, Round Robin이 있습니다.

---
# 선점과 비선점


---
# 쓰레싱(Thrashing)에 대한 설명


---
# 캐시 메모리를 사용하는 이유


# CPU 적중률을 높이기 위해 어떤 원리를 사용하는지





## 가상 메모리란?

- 사용하는 부분만 메모리에 올리고, 나머지는 디스크에 보관하는 것

> 모든 프로세스에게 메모리를 할당하기에는 메모리의 크기가 한계가 있어서 사용하는 방법이다. 프로세스에서 사용하는 부분만 메모리에 올리고, 나머지는 디스크에 보관하는 기법을 가상 메모리라고 한다.

---
## 데드락이란?

- 프로세스가 자원을 얻지 못해 다음 작업을 못하는 상태

**데드랑 발생 조건**

데드락은 아래 네 가지 조건이 동시에 성립될 때 발생한다.

- 상호 배제 : 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
- 점유 대기 : 최소 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
- 비선점 : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없다.
- 순환 대기 : 프로세스들이 각각 점유한 자원을 대기하고, 요구해야 한다.

> 데드락은 프로세스가 자원을 얻지 못해 다음 작업을 못하는 상태이다.
> 예를 들어, P1, P2가 각각 자원 A와 B를 얻어야 되는데, P1은 A를 P2는 B를 가지고 있어서 서로 무한정 대기하는 상태를 데드락이라고 한다.
> 데드락은 상호 배제, 점유 대기, 비선점, 순환 대기 네가지가 동시에 성립될 때 발생한다.


- 운영체제란?
- 실행파일 생성 과정
- 프로그램 실행과정
    - 명령어사이클
- 캐시란?
- 캐시라인
- 메모리구조
    - 전역변수와 정적변수의 차이
    - Heap, Stack 비교
    - 가시성(visibility)과 원자성(atomocity)
    - 유효주소, 주소지정방식
    - 메모리 할당 알고리즘
- 프로세스, 스레드
    - 멀티 프로세스와 멀티 스레드
    - 스레드와 프로세스 콘텍스트 스위치 차이 이유
    - 프로세스 스케줄러에 대해
    - CPU 스케줄러
- 스레싱이란?
- IPC란?
- Race Condition?
- User, Kernel 스레드 차이
- 가상 메모리
    - 메모리 단편화
- 페이징기법
- 세그먼테이션 기법ㅏ
- 메모리풀
- 페이지 교체 알고리즘
- MMU란?
- TLB란?
- 페이지 부재시 절차
- 인터럽트란?
    - System Call
- 프로세스 제어 명령
- fork(), vfork() 차이
- 시스템콜과 서브루틴 차이
- 블록킹, 논블록킹
- 동기, 비동기
- 동기 IO 처리과정 : 프로세스 A가 디스크에서 어떤 데이터 읽어올때 상황
- 입출력 처리방식
    - DMA
    - Cycle Stealing
- 데드락
    - 발생조건
    - 회피기법
    - 해결경험
- PCB(Process Control Block) 이란?
- Spin Lock 이란?
- 동기화 종류
- Critical Section?
- Mutex란?
- Semaphore란?
- Mutex, Semaphore 차이
- Monitor란?
- Thread-safe 란?
    - Reentrant란?
- 인터럽트, 폴링 개념 및 차이
- Fault Tolerance 란?
    - 작동절차