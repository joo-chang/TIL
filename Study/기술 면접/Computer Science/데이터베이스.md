# 데이터베이스(Database, DB)란?

간단하게 데이터의 저장소(집합)를 의미한다.

여러 사람이 공유하고 사용할 목적으로 관리되는 정보이다. 자료의 중복을 없애고 구조화하여 처리를 효율적으로 하기 위해서 관련성을 가지며 저장시켜 놓은 데이터의 집합이다.

## 데이터베이스의 특징

**데이터 공유** → 많은 사람들이 데이터를 공유할 수 있다.

**중복의 제거** → 데이터를 한 곳에 모으면서 중복되는 데이터를 제거할 수 있다.

**데이터 통합** → 흩어져 있는 데이터를 한 곳에 모을 수 있다.

**보안성** → 권한이 있는 관리자만이 데이터를 관리한다면 데이터의 보안을 지킬 수 있다.

# DBMS란?

DBMS는 Database Management System의 줄임말로, 데이터베이스를 관리하고 운영하는 소프트웨어이다.

다양한 데이터가 저장되어 있는 데이터베이스는 **여러 명의 사용자나 응용 프로그램과 공유**하고 **동시에 접근이 가능**해야 하는데 이를 도와주는 것이 DBMS이다.


## DBMS 사용 이유

### 데이터의 일관성과 무결성

DBMS는 **데이터 중복을 최소화**하고, **정의된 규칙에 따라 데이터가 저장**되도록 관리한다. 이를 통해 데이터의 **정확성과 신뢰성을 보장**한다.

### 보안

DBMS는 다양한 보안 기능을 제공하여 무단 접근으로부터 데이터를 보호한다. 사용자별 권한을 부여하여 데이터 접근을 제한할 수도 있다.

### 동시성 제어

여러 사용자가 동시에 데이터베이스에 접근할 때 발생할 수 있는 문제를 관리한다. 이를 통해 여러 사용자가 데이터를 동시에 사용하고 수정할 수 있으며, 데이터의 일관성을 유지할 수 있다.

### 백업 및 복구

DBMS는 데이터의 정기적인 백업과 비정상적인 상황에 데이터를 복구할 수 있는 기능을 제공하여 데이터 손실의 위험을 줄일 수 있다.


DBMS는 파일 시스템이 가진 데이터 종속성과 데이터 중복성 문제를 해결하기 위해 제안되었다. DBMS는 사용자 또는 응용 프로그램과 데이터베이스 사이에 위치하여 데이터를 공유하고 관리해주는 소프트웨어로 대량의 데이터를 체계적으로 관리하고 원하는 정보를 효과적으로 검색하도록 하는 기능을 제공한다.


# DML, DDL, DCL 설명

DBMS 기능은 정의어, 조작어, 제어어로 나뉜다.

## 정의어 (DDL : Data Definition Language)

- 데이터베이스가 어떤 용도이며 어떤 식으로 사용될 것에 대한 정의하는 기능이다.
- CREATE, ALTER, DROP

## 조작어 (DML : Data Manipulation Language)

- DB에 저장된 데이터의 검색, 갱신, 삽입, 삭제 등을 처리하기 위한 기능이다.
- SELECT, INSERT, DELETE, UPDATE

## 제어어 (DCL : Data Control Language)

- 데이터베이스에 접근하고 사용할 수 있도록 권한을 부여하고 해제하는 기능이다.
- 데이터 삽입, 삭제 등 DB 변경 시 데이터 무결성 및 일관성 유지 기능
- 권한이 부여된 사용자만 허용된 데이터에 접근할 수 있도록 접근 권한 검사 기능
- 여러 사용자가 DB에 동시 접근이 가능하도록 동시성 제어 기능
- GRANT, REVOKE

# DB 스키마

## 스키마 (Schema)

스키마는 DB의 구조적인 틀과 제약 조건에 관해 정의하는 것이다.
DB 내에서 데이터가 어떻게 조직되고 저장될지에 대한 설계도 같은 역할을 한다.

## 구성 요소

개체의 특성을 나타내는 속성(Attribute)
속성들의 집합으로 이루어진 개체(Entity), 
개체 사이에 존재하는 관계(Relation),
이들이 유지해야 할 제약 조건들을 기술한 것이다.


## 특징

1. 스키마는 데이터 사전에 저장된다.
2. 특정 데이터 모델을 이용하여 만들어진다.
3. 시간에 따라 불변인 특성을 가진다.
4. 데이터의 구조적 특성을 의미하며, 인스턴스에 의해 규정된다.

> 데이터 사전 : 데이터 항목들에 대한 정보를 지정한 중앙 저장소 (테이블 및 뷰들의 집합)


## 스키마 3계층

스키마는 사용자의 관점에 따라 외부, 개념, 내부 스키마로 나뉜다.

![[Pasted image 20240406123057.png]]

### 외부 스키마 (External Schema) = 사용자 뷰

개별 사용자나 사용자 그룹이 데이터베이스와 상호작용하는 방식을 정의한다.

목적 : 사용자가 필요로 하는 데이터를 사용자 친화적인 형태로 제공하여, 각 사용자나 응용 프로그램이 DB를 보다 쉽게 사용할 수 있도록 한다.

### 개념 스키마 (Conceptual Schema) = 전체적인 뷰

데이터베이스의 전체적인 구조를 정의한다. 모든 사용자의 데이터 요구사항을 포괄하며, DB의 논리적 구조를 기술한다.

목적 : DB 구조를 전체적으로 이해하고 관리할 수 있는 기반을 제공한다. 데이터의 구조와 제약 조건을 포함하여, 데이터베이스의 무결성, 보안, 접근 권한을 관리한다.

개념 스키마를 스키마 라고 칭하기도 하며 DB 전체를 기술한 것이기 때문에 한 개만 존재한다.

### 내부 스키마 (Internal Schema)

데이터가 실제로 저장되는 방식을 저장한다. 데이터베이스의 물리적 저장 구조와 접근 경로를 기술한다.

목적 : 데이터가 효율적으로 저장되고 접근될 수 있도록 최적화하는 데 중점을 둔다. 데이터의 물리적 위치, 인덱싱 방법, 데이터 압축, 저장 방법 등을 포함한다.

# DB Key

데이터베이스 내의 레코드(행)을 유일하게 식별하거나 정렬, 검색 등의 작업을 효율적으로 수행하기 위해 사용되는 하나 또는 여러 개의 속성(열)의 집합이다.

키는 데이터의 무결성을 유지하고, 중복을 방지하며, 데이터베이스 내에서 데이터를 빠르고 정확하게 접근하는 데 필수적인 역할을 한다.

## 종류

### 기본 키 (Primary Key)

테이블 내의 각 레코드를 **유일**하게 식별하는 역할을 한다.

기본키로 설정된 필드는 고유한 값을 가져야 하며, NULL을 허용하지 않는다.

### 외래 키 (Foreign Key)

다른 테이블의 기본키를 참조하는 필드 또는 필드의 집합이다.

외래 키는 관계형DB에서 테이블 간의 관계를 설정하는 데 사용되며, 참조 무결성을 유지하는 데 중요한 역할을 한다.

### 후보 키 (Candidate Key)

테이블 내의 레코드를 유일하게 식별할 수 있는 속성이다. 기본 키가 될 수 있는 속성으로, 테이블 내에서 고유해야 하며 NULL을 허용하지 않는다.

기본 키가 되지 않은 후보 키를 대체 키로 부른다.

### 대체 키 (Alternate Key)

기본 키를 제외한 후보 키이다.

### 슈퍼 키 (Super Key)

테이블 내의 각 레코드를 유일하게 식별할 수 있는 하나 이상의 속성의 집합이다.

유일성, 최소성 중 유일성만 만족하는 키이다.

### 복합 키 (Conposite Key)

두 개 이상의 컬럼을 결합하여 테이블 내의 레코드를 유일하게 식별하는 키이다.


---
# JOIN

Join 이란 데이터베이스에서 *두 개 이상의 테이블을 연결하여 하나의 결과 테이블로 만드는 것*을 의미하며 이를 통해 데이터를 효율적으로 검색하고 처리하는데 도움을 준다.

조인을 사용하는 이유는 서로 다른 테이블에서 관련된 데이터를 결합하여, 보다 유용하고 의미있는 정보를 추출하기 위함이다.

## 종류

### INNER JOIN

- 두 테이블에서 **공통된 값을 가지고 있는 행들만** 반환한다.

```sql
SELECT <열 목록> 
FROM <테이블 1>     
	INNER JOIN <테이블 2>     
	ON <조인 조건> 
[WHERE 검색 조건] 

# INNER JOIN을 JOIN이라고만 써도 INNER JOIN으로 인식한다.
```

![[Pasted image 20240408182153.png]]

### OUTER JOIN

- 두 테이블에서 **공통된 값을 가지지 않는 행들도** 반환한다.

- **LEFT OUTER JOIN** : 왼쪽 테이블의 모든 값이 출력되는 조인
- **RIGHT OUTER JOIN** : 오른쪽 테이블의 모든 값이 출력되는 조인
- **FULL OUTER JOIN** : 양쪽 테이블의 모든 값이 출력되는 조인

```sql
SELECT <열 목록> 
FROM <테이블 1(LEFT 테이블)>     
	<LEFT | RIGHT | FULL> OUTER JOIN <테이블 2(RIGHT 테이블)>      
	ON <조인 조건> 
[WHERE 검색 조건]
```

![[Pasted image 20240408180740.png]]

### CROSS JOIN

- 한쪽 테이블의 모든 행과 다른쪽 테이블의 모든 행을 조인 시키는 기능이다.
- CROSS JOIN 결과는 두 테이블의 각 행의 개수를 곱한 수만큼 나온다.
- 카티션 곱(Cartesian Product) 이라고도 한다.

```sql
SELECT * 
FROM <테이블 1>     
CROSS JOIN <테이블 2>
```

![[Pasted image 20240408181211.png]]

### SELF JOIN

- SELF JOIN은 자기 자신과 조인하므로 1개의 테이블을 사용한다. 
- 예시) 직원 테이블에 관리자 ID 컬럼이 있다면, 각 직원의 관리자 정보를 조회할 때 사용할 수 있다.
- INNER JOIN, OUTER JOIN 둘다 사용 가능

```sql
SELECT <열 목록> 
FROM <테이블1> 별칭A     
	INNER JOIN <테이블1> 별칭B 
[WHERE 검색 조건]
```

![[Pasted image 20240408182237.png]]

# INNER JOIN 과 OUTER JOIN 차이

**INNER JOIN**은 두 테이블 간의 교집합만을 결과로 반환한다. 즉, 두 테이블에 모두 존재하는 데이터만 결과에 포함한다.

**OUTER JOIN**은 한 테이블의 로우와 다른 테이블의 매칭되는 레코드를 반환하며, 매칭되는 레코드가 없는 경우에도 결과에 포함시킨다. 이때, 매칭되지 않는 필드는 NULL로 값이 채워진다. 

`INNER JOIN`과 `OUTER JOIN`의 선택은 조회하고자 하는 정보의 특성과 필요에 따라 결정된다. `INNER JOIN`은 좀 더 엄격한 매칭 조건을 가지고, `OUTER JOIN`은 더 포괄적인 데이터 세트를 반환 한다.


# GROUP BY

- GROUP BY는 같은 값을 가진 레코드를 그룹짓는 SQL 명령어이다.
- COUNT(), MAX(), SUM(), AVG() 등 집계 함수와 함께 사용된다.
- GROUP BY절은 각 그룹의 하나씩만 리턴한다.

> GROUP BY 실행 순서
> FROM -> WHERE -> GROUP BY -> SELECT -> DISTINCT -> ORDER BY -> LIMIT

- GROUP BY로 그룹화된 결과에 대해 추가적인 조건을 적용하고 싶다면, HAVING 절을 사용해야 한다. HAVING은 GROUP BY로 생성된 그룹에 대한 조건을 지정할 때 사용된다.
- 하지만 가능한 HAVING절 사용은 피해야 한다. HAVING 절은 GROUP BY에 의해 결과들을 집계한 후 조건과 맞지 않는 결과를 버리는 과정을 거친다. 그러므로 성능 저하를 일으킬 수 있다.
- 대부분의 경우 HAVING 절 없이 GROUP BY와 WHERE절로 원하는 결과를 얻을 수 있으므로 피하는게 좋다.

# DELETE, TRUNCATE, DROP 차이

DELETE, TRUNCATE, DROP은 삭제와 관련된 명령어이다. 각각 무엇을 삭제하는지가 다르다.

- DELETE : 행 일부 또는 전체 데이터를 지운다.
- TRUNCATE : 행 전체 데이터 뿐만 아니라 행이 저장되어 있던 공간과 인덱스도 삭제된다.
- DROP : 테이블 전체를 삭제한다.

| **비교항목**         | **DELETE**  | **TRUNCATE** | **DROP** |
| ---------------- | ----------- | ------------ | -------- |
| **명령어 분류**       | DML         | DDL          | DDL      |
| **삭제범위**         | 행 데이터 일부~전체 | 행 전체+인덱스 등   | 테이블 전체   |
| **행 데이터(레코드)**   | 일부~전체 삭제    | 전체 삭제        | 전체 삭제    |
| **데이터 저장공간**     | 남겨져 있음      | 삭제           | 삭제       |
| **인덱스**          | 남겨져 있음      | 삭제           | 삭제       |
| **테이블 컬럼, 제약조건** | 남겨져 있음      | 남겨져 있음       | 삭제       |
| **테이블 자체**       | 남겨져 있음      | 남겨져 있음       | 삭제       |


---
# PL/SQL이란

 - SQL을 확장한 절차적 언어(Procedural Language)이다. 
 - 관계형 데이터베이스에서 사용되는 Oracle의 표준 데이터 엑세스 언어로, 프로시저 생성자를 SQL과 완벽하게 통합한다.
 - PL/SQL 프로그램의 종류는 크게 Procedure, Function, Trigger 로 나뉘어 진다.

**SQL은 절차형 언어가 아니다. PL/SQL(Procedural Language/Structured Query Language)은 SQL을 확장한 프로시저 언어로 절차형 언어이다.**

SQL의 DDL/DML/DCL을 통해 DB를 정의/조작/제어 하는 것이 가능하지만, SQL은 결국 데이터의 처리 집합만을 기술할 뿐 어떠한 절차를 걸쳐서 데이터 집합을 얻어야 하는지에 대한 절차적 과정을 제공하지 않는다. **일반적인 SQL 로직을 작성하면 문장의 실행 순서는 옵티마이저에 의해 이루어진다.** 이는 여러 가지 DB 통계를 기초로 실행 계획을 처리하기 때문에 데이터 처리를 빠르게 해주지만, **개발자 입장에서 융통성 있는 데이터 처리는 불가능하다는 단점이 있다.**

이러한 단점을 극복하기 위해 **대안으로 절차적 작성이 가능한 PL/SQL을 제공하게 되었다**. PL/SQ은 절차적 언어의 특성을 가지고 있기 때문에 원하는 결과, 제약조건, 처리 절차를 개발자가 작성해야 한다.

## stored function이란

PL/SQL의 일종으로 사용자가 함수를 정의할 수 있다. **사용자가 정의한 함수로, DBMS에 저장하여 사용하는 함수이다. SQL의 select, insert, update, delete 등의 DML 언어에서 사용할 수 있다.** 반복문, 조건문, 에러 핸들링 등이 가능하다.

## stored procedure란

PL/SQL의 일종으로 사용자가 정의한 프로시저로, DBMS에 저장하여 사용하는 프로시저이다.
프로시저는 절차형 SQL을 활용하여 구체적인 하나의 태스크를 수행하는 트랜잭션 언어이다.
일련의 SQL 작업을 포함하는 DML들을 수행하며, 프로시저는 호출을 통해 실행된다.

# 프로시저(Procedure)

- 프로시저는 데이터베이스에서 정의된 일련의 SQL 들을 묶어 놓은 저장 프로그램이다.
- 쿼리문을 마치 하나의 메서드 형식으로 만들고 어떠한 동작을 일괄적으로 처리하는 용도로 사용된다.
- 여러 개의 쿼리를 사용하거나 긴 쿼리문을 사용해야 한다면 프로시저에 저장하고 저장된 프로시저를 호출하여 프로그래밍 하는 것이 훨씬 효율적이다.

## 장점

1. Application에 대해 transparent하다 (transparent란 연관성이 없다, 무관하다라는 의미)
2. 네트워크 트래픽을 줄여서 응답 속도를 향상시킬 수 있다  
3. 여러 서비스에서 재사용 가능하다.
4. 민감한 정보에 대해 접근을 제한할 수 있다.

## 단점

1. Stored Procedure를 사용하면, 유지 보수 관리 비용이 커진다.
	1. 문제 위치 파악이 오래 걸리고 불편하다.
	2. 프로시저 작성을 위해 추가적인 지식을 학습해야 한다.
	3. 로직 위치 파악이 어렵다.
	4. 프로시저를 새로 만든다면 로직에 추가해야 하므로 결국 통합 배포 해야한다.
2. DB 서버에 과부하를 일으키며, DB 서버를 증가하는 작업은 쉽지 않다.
	1. DB 서버는 일반 서버 추가 작업보다 비싸고 무거운 작업이다.
	2. 트래픽 증가했을 때 DB 서버 부하가 발생 한다.
3. Stored Procedure가 언제나 transparent한 것은 아니다.
	1. 프로시저 이름 변경 시 로직에 변경해줘야 하므로 결국 서버 재배포가 이루어져야 한다.
4. 디버깅과 테스팅의 어렵다.
	1. 프로시저는 데이터베이스 내부에서 실행되기 때문에 디버깅과 테스팅이 어려울 수 있다.


---
# Trigger 란?

트리거는 데이터베이스에서 특정 이벤트가 발생했을 때 자동으로 실행되도록 구현된 프로그램이다.
트리거는 사용자가 직접 쿼리를 실행하지 않아도 데이터베이스 시스템이 자동으로 특정 작업을 수행하도록 할 수 있다. 주로 데이터 관련 이벤트에 대한 반응으로 설정되며, 데이터베이스 관리와 관련된 다양한 자동화 작업에 중요한 역할을 한다.

## 목적

- 특정 테이블에 대한 데이터 변경을 시작점으로 설정하고, 그와 관련된 작업을 자동적으로 수행하기 위해 트리거를 사용한다.
- 일반적으로 이벤트와 관련된 테이블의 데이터 삽입, 추가, 삭제 작업을 DBMS가 자동적으로 실행 시키는데 활용한다.

## 단점

- 프로시저를 직접 사용하면 로직단에서 직접적으로 호출하기 때문에 사용을 인지할 수 있지만, 트리거는 DB단에서 자동으로 실행되기 때문에 동작을 인지하기 어렵다.
- 트리거의 흐름을 파악하기 어렵다. (잘못 설계 시 트리거가 트리거를 호출하고 이를 반복하는 현상이 생길 수 있다.)
- 디버깅이 어렵다.
- 문서 정리가 매우 중요하다.


## 종류

- 행 트리거 : 데이터가 변화할 때마다 실행
- 문장 트리거 : 트리거에 의해 한 번 실행

![[Pasted image 20240412213941.png]]

- 선언부(DECLARE) : 트리거 명칭을 정의하는 부분
- 이벤트부(EVENT) : 트리거가 실행되는 타이밍, 이벤트를 명시하는 부분
- 시작/종료부(BEGIN/END) : 트리거의 시작과 종료를 표현하며 BEGIN/END가 쌍을 이룸
- 제어부(CONTROL) : 제어 단위 블록 별 실행 흐름을 제어하는 부분
- SQL : DML을 주로 사용. DDL도 필요에 따라 사용
- 예외부(Exception) : BEGIN/END 내에서 SQL문 예외 발생 시 예외 처리 방법 정의

---
# 트랜잭션 (Transaction)

트랜잭션은 단일한 논리적인 작업 단위를 말한다. 논리적인 이유로 **여러 SQL 문들을 단일 작업으로 묶어서 나눠질 수 없게 만든 것**이 트랜잭션이다.

트랜잭션의 SQL 문들 중 **일부만 성공해서 DB에 반영될 수 없다**. (전부 성공 해야 함)

# 특성

트랜잭션은 ACID 4가지 특성을 만족해야한다.

- A : 원자성 (Atomicity)
	- 트랜잭션 작업이 **부분적으로 실행되거나 중단되지 않는 것을 보장한다.**
	- **All or Noting** (모두 성공하거나, 아무 일도 없었던 것처럼 되돌리거나)
	- commit과 rollback은 DBMS가 담당하는데, 언제 commit과 rollback을 수행할지는 개발자가 챙겨야 한다.
- C : 일관성 (Consistency)
	- 트랜잭션이 **성공적으로 완료되면 일관적인 DB 상태를 유지한다.**
	- DB에 **정의된 Rule(제약 조건)을 위반해서는 안된다.**
- I : 격리성 (Isolation)
	- 트랜잭션 **작업 수행 중 다른 트랜잭션의 작업이 끼어들지 못하도록 보장한다.**
	- DB 서버 퍼포먼스가 줄어들기 때문에 DBMS는 여러 종류의 isolation level을 제공한다.
- D : 지속성 (Durability)
	- **성공적으로 수행된 트랜잭션은 영구적으로 반영돼야 한다.**
	- 일반적으로 비휘발성 메모리에 저장함을 의미한다.
	- Commit

> 데이터베이스의 무결성을 위해 트랜잭션은 4가지 특징을 만족해야 합니다.
> 원자성은 한 트랜잭션 내 실행한 작업은 모두 성공하거나 실패해야합니다.
> 일관성은 일관성 있는 데이터베이스를 유지시키는 것입니다.
> 격리성은 동시에 실행되는 트랜잭션은 서로에 영향이 없어야하고,
> 지속성은 트랜잭션 완료 시 결과가 영구적으로 반영되어야 합니다.

> 무결성이란 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말한다. 즉, 데이터에 결점이 없도록 유지하는 성질이다.

# COMMIT 과 ROLLBACK

## COMMIT

- COMMIT 은 지금까지 작업한 내용을 DB에 영구적으로 저장하는 작업이다. (트랜잭션 종료를 의미)

## ROLLBACK

- 지금까지 작업들을 모두 취소하고 트랜잭션 이전 상태로 되돌리는 작업이다. (트랜잭션 종료를 의미)

## AUTOCOMMIT

- 각각의 SQL문을 자동으로 트랜잭션 처리 해주는 개념
- SQL문이 **성공적으로 실행되면** 자동으로 **COMMIT**한다.
- 실행 중 **문제 발생 시** 알아서 **ROLLBACK**한다.

Mysql 에서 트랜잭션 실행 시 AUTOCOMMIT은 off 되고 COMMIT 또는 ROLLBACK이 되어 트랜잭션이 종료되면 원래 AUTOCOMMIT 상태로 돌아간다.

---
# 격리 수준(isolation level)

Isolation Level은 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 수준이다.
즉, **한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도**를 의미한다.

트랜잭션 수행 중간에 다른 트랜잭션이 끼어들 수 없다면 모든 트랜잭션은 순차적으로 처리될 것이고, 데이터의 정확성은 보장될 것이다. 하지만 트랜잭션이 많아질수록 처리를 기다리는 트랜잭션이 많아지고, 대기 시간은 늘어난다. 결국 트랜잭션 처리 속도는 느려지고, 애플리케이션 운용에 심각한 문제가 발생할 수 있다.

결국 처리 속도를 위해 트랜잭션의 완전한 격리가 아닌 완화된 수준의 격리가 필요하다.
이처럼 속도와 데이터 정확성에 대한 트레이드 오프를 고려하여 트랜잭션의 격리 수준을 나눈 것이다.


![[Pasted image 20240418181924.png]]

## 이상 현상

트랜잭션 수행 시 발생할 수 있는 이상 현상이 있다. 이상 현상들을 모두 발생하지 않도록 만들 수 있지만, 제약 사항이 많아져 동시 처리 가능한 트랜잭션 수가 줄어들어, DB 전체 처리량이 하락하고, 성능이 저하 된다.

일부이상 현상을 허용하는 몇가지 Level을 만들어 사용자가 필요에 따라 선택할 수 있도록 하는 것이 **Isolation Level**이다.

### 1. Drity Read

- **아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 것**을 의미한다.
- 커밋되지 않은 **데이터를 읽고 다른 트랜잭션이 이후에 롤백될 경우 유효하지 않은 데이터 값을 읽게 된다.**
 
![[Pasted image 20240418174059.png]]
![[Pasted image 20240418174116.png]]

### 2. Non-repeatable Read

 - 한 트랜잭션에서 **같은 데이터를 2번 이상 조회했을 때, 그 결과가 상이한 상황**을 말한다.

![[Pasted image 20240418173958.png]]

### 3. Phantom Read

- 한 트랜잭션에서 **같은 쿼리를 2번 이상 조회했을 때 없던 결과가 조회되는 상황을** 말한다.

![[Pasted image 20240418220209.png]]

## 격리 수준

### Read Uncommitted (Level 0)

어떤 트랜잭션의 내용이 **커밋이나 롤백 상관없이 다른 트랜잭션에서 조회가 가능**하다. 정합성의 문제가 많은 격리 수준이기 때문에 RDBMS 표준에서는 격리 수준으로 인정하지 않는다.

SELECT문이 실행되는 동안 해당 Data에 Shared Lock이 걸리지 않는다.
이런 이유로 Dirty Read가 발생한다.

![[Pasted image 20240418012301.png]]

### Read Commited (Level 1)

**한 트랜잭션의 변경 내용이 커밋 되어야만** 다른 트랜잭션에서 **조회가 가능**하다.
대부분의 RDBMS에서 기본적으로 사용하는 격리수준이다.

SELECT문이 실행되는 동안 Shared Lock이 걸린다. 조회 시에 실제 테이블 값이 아니라 Undo 영역에 백업된 레코드 값을 가져온다.
하지만 하나의 트랜잭션에서 똑같은 SELECT 문을 실행했을 때 항상 같은 결과를 가져와야 하는 REPEATABLE READ의 정합성에 어긋난다. 즉, Non-repeatable Read가 발생한다.

![[Pasted image 20240418020126.png]]

### Repeatable Read (Level 2)

**트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회가 가능**하다. Mysql에서 기본으로 사용하며, 이 격리수준에서는 Non-repeatable Read 이 발생하지 않는다.
트랜잭션이 완료될 때까지 SELECT문이 사용하는 모든 데이터에 Shared Lock이 걸린다. 따라서 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다.
트랜잭션이 시작 시점 데이터의 일관성을 보장해야 하기 때문에 트랜잭션의 실행시간이 길어질수록 계속 멀티 버전을 관리해야 하는 단점이 발생한다.
하지만 Phantom Read가 발생할 수 있다.

![[Pasted image 20240418021814.png]]

### SERIALIZABALE (Level 3)

가장 단순하면서 엄격한 격리 수준이지만 성능 측면에서는 동시 처리 가능성이 가장 낮다.
SERIALIZABLE 에서는 Phantom Read가 발생하지 않는다.

트랜잭션들이 동시에 일어나지 않고, 순차적으로 실행되는 것처럼 동작한다.
하지만, 거의 사용되지 않는다.

## 요약

각 DBMS에 따라서 Default Level도 다르고 각 수준의 동작 방식도 상이하다.

하지만 Isolation Level이 존재하는 이유는 모두 동일하기 때문에 큰 틀에서 같다고 할 수 있다.
기본 개념을 바탕으로 본인이 사용하는 DBMS에서 제공하는 정보를 확인하며 적용하는 것이 가장 적절한 방법일 것이다.

일반적인 서비스에서는 **READ COMMITED** 나 **REPEATABLE READ** 를 주로 사용한다.

![[Pasted image 20240418181924.png]]


---
# 동시성 제어 (Concurrency Control)

동시성 제어란 동시에 실행되는 여러 개의 트랜잭션이 작업을 성공적으로 마칠 수 있도록 트랜잭션의 실행 순서를 제어하는 기법이다.

## 정의

- 다중 사용자 환경을 지원하는 데이터베이스 시스템에서 여러 트랜잭션들이 성공적으로 동시에 실행될 수 있도록 지원하는 기능
- 다중 사용자 환경을 지원하는 데이터베이스 시스템의 경우 필수적으로 지원해야 하는 기능으로 **병행 제어**라고도 한다.
- 트랜잭션의 직렬화 수행을 보장한다.

![[Pasted image 20240428184520.png]]

## 목적

- 트랜잭션의 직렬성 보장
- 공유도 최대, 응답 시간 최소, 시스템 활동의 최대 보장
- 데이터 무결성 및 일관성 보장

## 종류

- 락킹
	- 트랜잭션이 데이터에 잠금을 설정하면 다른 트랜잭션은 해당 데이터에 대해 잠금이 해제될 때까지 접근/수정/삭제가 불가능하다.
	- 트랜잭션이 사용하는 자원에 대해 상호 배제를 제공하는 기법이다.
- 타임스탬프
	- 시스템에서 생성하는 고유 번호인 타임스탬프를 트랜잭션에 부여함으로써 트랜잭션 간의 접근 순서를 미리 정한다.
- 적합성(Validation) 검증
	- 먼저 트랜잭션을 수행하고 트랜잭션을 종료할 때 적합성을 검증하여 데이터베이스에 최종 반영한다.


## Serializability

동시에 실행되는 트랜잭션 간에 상호 충돌이 없는 상태를 의미한다.
Serializability를 이해하려면 Schedule과 Conflict를 이해해야 한다.

### Schedule



1. DB에서 동시성 제어란 무엇인지 설명하고, 기법의 종류를 설명해 보세요.
2. recoverability에 대해 설명해주세요.
3. DB Lock에 대해 설명해주세요.
4. DB 2PL에 대해 설명해주세요.




# ㅇ
---
## 트랜잭션 특징 ACID



---
## NoSQL와 RDBMS 차이

- Not Only SQL의 약자로 SQL을 보완한다는 의미

**RDBMS**
- 정형화된 데이터 모델이 필요한 경우
- 복잡한 데이터 조작 및 트랜잭션을 지원하는 경우
- ACID 특성을 요구하는 데이터 일관성이 필요한 경우에 적합하다.

**NoSQL**
- 데이터 모델이 자주 변경되는 경우나 유연한 스키마가 필요한 경우
- 대량의 데이터 처리 및 확장성이 필요한 경우
- 비정형 또는 반정형 데이터를 다루는 경우
- 빠른 읽기 및 쓰기 처리량이 필요한 경우

**RDBMS**
1. 데이터 모델 : 정형화된 데이터 모델을 사용하고, 스키마를 사용하여 데이터 구조를 정의합니다.
2. 쿼리 언어 : SQL을 사용하여 데이터를 조작 및 관리합니다.
3. 스키마 유연성 : 엄격한 스키마를 사용하며, 데이터 모델 변경이 어려울 수 있습니다.
**NoSQL**
1. 다양한 데이터 모델을 사용할 수 있으며, 스키마가 덜 제한적이거나 유연한 스키마 모델을 지원합니다.
2. 다양한 NoSQL 데이터베이스는 각각 고유한 쿼리 언어 또는 API를 사용합니다. (일부는 SQL과 유사)
3. 스키마가 유연하거나 동적으로 조정 가능하므로 데이터 모델 변경이 용이합니다.

> NoSQL은 Not Only SQL의 약자로 SQL을 보완한다는 의미를 가지고 있습니다.
> NoSQL은 스키마가 없어서 데이터를 조회하고 삽입하는 속도가 빠릅니다.
> 또한 대량의 분산 데이터를 저장하는 데 특화되어 있습니다.

> 둘의 가장 큰 차이점은 RDBMS는 정형화된 데이터 모델을 사용하고, NoSQL은 다양한 데이터 모델을 허용하며, 비정형 또는 반정형 데이터를 다루는 데 적합합니다.
> 또한, RDBMS는 ACID 트랜잭션을 지원하여 데이터 일관성과 안정성을 보장하고,
> NoSQL은 일부 시스템에서는 느슨한 일관성 모델을 따르며, 높은 가용성과 확장성을 제공합니다.


---
## 파티셔닝

> 파티셔닝은 데이터베이스 및 분산 시스템에서 사용되는 개념으로, 대량의 데이터를 작은 덩어리로 분할하는 작업을 의미합니다. 각각의 작은 덩어리를 파티션 또는 샤드라고 부르며, 이를 통해 데이터를 효율적으로 저장하고 관리할 수 있습니다. 파티셔닝은 데이터의 성능, 확장성, 관리 용이성을 개선하기 위해 사용됩니다.

---


