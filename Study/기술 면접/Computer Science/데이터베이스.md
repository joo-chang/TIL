# 데이터베이스

데이터베이스는 데이터의 집합이라고 할 수 있다.

# DBMS란

데이터베이스 관리 시스템의 약자로 데이터베이스에 접근하여 데이터를 생성, 검색, 관리할 수 있도록 도와주는 소프트웨어 시스템이다.

즉, 사용자가 DB에 직접 접근하여 데이터를 다루는 것이 아니라, DBMS의 도움으로 데이터를 다룰 수 있는 것이다.

DBMS는 데이터를 효율적으로 저장, 조작, 추출할 수 있는 구조화된 방식을 제공하여 데이터의 일관성, 무결성, 보안을 유지한다.

## DBMS 사용 이유

### 데이터의 일관성과 무결성

DBMS는 데이터 중복을 최소화하고, 정의된 규칙에 따라 데이터가 저장되도록 관리한다. 이를 통해 데이터의 정확성과 신뢰성을 보장한다.

### 보안

DBMS는 다양한 보안 기능을 제공하여 무단 접근으로부터 데이터를 보호한다. 사용자별 권한을 부여하여 데이터 접근을 제한할 수도 있다.

### 동시성 제어

여러 사용자가 동시에 데이터베이스에 접근할 때 발생할 수 있는 문제를 관리한다. 이를 통해 여러 사용자가 데이터를 봉시에 사용하고 수정할 수 있으며, 데이터의 일관성을 유지할 수 있다.

### 백업 및 복구

DBMS는 데이터의 정기적인 백업과 비정상적인 상황에 데이터를 복구할 수 있는 기능을 제공하여 데이터 손실의 위험을 줄일 수 있다.


DBMS는 파일 시스템이 가진 데이터 종속성과 데이터 중복성 문제를 해결하기 위해 제안되었다. DBMS는 사용자 또는 응용 프로그램과 데이터베이스 사이에 위치하여 데이터를 공유하고 관리해주는 소프트웨어로 대량의 데이터를 체계적으로 관리하고 원하는 정보를 효과적으로 검색하도록 하는 기능을 제공한다.


# DML, DDL, DCL 설명

DBMS 기능은 정의어, 조작어, 제어어로 나뉜다.

## 정의어 (DDL : Data Definition Language)

- 데이터베이스가 어떤 용도이며 어떤 식으로 사용될 것에 대한 정의하는 기능이다.
- CREATE, ALTER, DROP

## 조작어 (DML : Data Manipulation Language)

- DB에 저장된 데이터의 검색, 갱신, 삽입, 삭제 등을 처리하기 위한 기능이다.
- SELECT, INSERT, DELETE, UPDATE

## 제어어 (DCL : Data Control Language)

- 데이터베이스에 접근하고 사용할 수 있도록 권한을 부여하고 해제하는 기능이다.
- 데이터 삽입, 삭제 등 DB 변경 시 데이터 무결성 및 일관성 유지 기능
- 권한이 부여된 사용자만 허용된 데이터에 접근할 수 있도록 접근 권한 검사 기능
- 여러 사용자가 DB에 동시 접근이 가능하도록 동시성 제어 기능
- GRANT, REVOKE

# DB 스키마

## 스키마 (Schema)

스키마는 DB의 구조적인 틀과 제약 조건에 관해 정의하는 것이다.
DB 내에서 데이터가 어떻게 조직되고 저장될지에 대한 설계도 같은 역할을 한다.

## 구성 요소

개체의 특성을 나타내는 속성(Attribute)
속성들의 집합으로 이루어진 개체(Entity), 
개체 사이에 존재하는 관계(Relation),
이들이 유지해야 할 제약 조건들을 기술한 것이다.


## 특징

1. 스키마는 데이터 사전에 저장된다.
2. 특정 데이터 모델을 이용하여 만들어진다.
3. 시간에 따라 불변인 특성을 가진다.
4. 데이터의 구조적 특성을 의미하며, 인스턴스에 의해 규정된다.

> 데이터 사전 : 데이터 항목들에 대한 정보를 지정한 중앙 저장소 (테이블 및 뷰들의 집합)


## 스키마 3계층

스키마는 사용자의 관점에 따라 외부, 개념, 내부 스키마로 나뉜다.

![[Pasted image 20240406123057.png]]

### 외부 스키마 (External Schema) = 사용자 뷰

개별 사용자나 사용자 그룹이 데이터베이스와 상화작용하는 방식을 정의한다.

목적 : 사용자가 필요로 하는 데이터를 사용자 친화적인 형태로 제공하여, 각 사용자나 응용 프로그램이 DB를 보다 쉽게 사용할 수 있도록 한다.

### 개념 스키마 (Conceptual Schema) = 전체적인 뷰

데이터베이스의 전체적인 구조를 정의한다. 모든 사용자의 데이터 요구사항을 포괄하며, DB의 논리적 구조를 기술한다.

목적 : DB 구조를 전체적으로 이해하고 관리할 수 있는 기반을 제공한다. 데이터의 구조와 제약 조건을 포함하여, 데이터베이스의 무결성, 보안, 접근 권한을 관리한다.

개념 스키마를 스키마 라고 칭하기도 하며 DB 전체를 기술한 것이기 때문에 한 개만 존재한다.

### 내부 스키마 (Internal Schema)

데이터가 실제로 저장되는 방식을 저장한다. 데이터베이스의 물리적 저장 구조와 접근 경로를 기술한다.

목적 : 데이터가 효율적으로 저장되고 접근될 수 있도록 최적화하는 데 중점을 둔다. 데이터의 물리적 위치, 인덱싱 방법, 데이터 압축, 저장 방법 등을 포함한다.

# DB Key

데이터베이스 내의 레코드(행)을 유일하게 식별하거나 정렬, 검색 등의 작업을 효율적으로 수행하기 위해 사용되는 하나 또는 여러 개의 속성(열)의 집합이다.

키는 데이터의 무결성을 유지하고, 중복을 방지하며, 데이터베이스 내에서 데이터를 빠르고 정확하게 접근하는 데 필수적인 역할을 한다.

## 종류

### 기본 키 (Primary Key)

테이블 내의 각 레코드를 **유일**하게 식별하는 역할을 한다.

기본키로 설정된 필드는 고유한 값을 가져야 하며, NULL을 허용하지 않는다.

### 외래 키 (Foreign Key)

다른 테이블의 기본키를 참조하는 필드 또는 필드의 집합이다.

외래 키는 관계형DB에서 테이블 간의 관계를 설정하는 데 사용되며, 참조 무결성을 유지하는 데 중요한 역할을 한다.

### 후보 키 (Candidate Key)

테이블 내의 레코드를 유일하게 식별할 수 있는 속성이다. 기본 키가 될 수 있는 속성으로, 테이블 내에서 고유해야 하며 NULL을 허용하지 않는다.

기본 키가 되지 않은 후보 키를 대체 키로 부른다.

### 대체 키 (Alternate Key)

기본 키를 제외한 후보 키이다.

### 슈퍼 키 (Super Key)

테이블 내의 각 레코드를 유일하게 식별할 수 있는 하나 이상의 속성의 집합이다.

유일성, 최소성 중 유일성만 만족하는 키이다.

### 복합 키 (Conposite Key)

두 개 이상의 컬럼을 결합하여 테이블 내의 레코드를 유일하게 식별하는 키이다.


---
# JOIN

Join 이란 데이터베이스에서 *두 개 이상의 테이블을 연결하여 하나의 결과 테이블로 만드는 것*을 의미하며 이를 통해 데이터를 효율적으로 검색하고 처리하는데 도움을 준다.

조인을 사용하는 이유는 서로 다른 테이블에서 관련된 데이터를 결합하여, 보다 유용하고 의미있는 정보를 추출하기 위함이다.

## 종류

### INNER JOIN

- 두 테이블에서 **공통된 값**을 가지고 있는 행들만 반환한다.

```sql
SELECT <열 목록> 
FROM <테이블 1>     
	INNER JOIN <테이블 2>     
	ON <조인 조건> 
[WHERE 검색 조건] 

# INNER JOIN을 JOIN이라고만 써도 INNER JOIN으로 인식한다.
```

![[Pasted image 20240408182153.png]]

### OUTER JOIN

- 두 테이블에서 **공통된 값을 가지지 않는 행들도** 반환한다.

- **LEFT OUTER JOIN** : 왼쪽 테이블의 모든 값이 출력되는 조인
- **RIGHT OUTER JOIN** : 오른쪽 테이블의 모든 값이 출력되는 조인
- **FULL OUTER JOIN** : 양쪽 테이블의 모든 값이 출력되는 조인

```sql
SELECT <열 목록> 
FROM <테이블 1(LEFT 테이블)>     
	<LEFT | RIGHT | FULL> OUTER JOIN <테이블 2(RIGHT 테이블)>      
	ON <조인 조건> 
[WHERE 검색 조건]
```

![[Pasted image 20240408180740.png]]

### CROSS JOIN

- 한쪽 테이블의 모든 행과 다른쪽 테이블의 모든 행을 조인 시키는 기능이다.
- CROSS JOIN 결과는 두 테이블의 각 행의 개수를 곱한 수만큼 나온다.
- 카티션 곱(Cartesian Product) 이라고도 한다.
```sql
SELECT * 
FROM <테이블 1>     
CROSS JOIN <테이블 2>
```

![[Pasted image 20240408181211.png]]

### SELF JOIN

- SELF JOIN은 자기 자신과 조인하므로 1개의 테이블을 사용한다. 
- INNER JOIN을 사용해서 SELF JOIN을 할 수 있다.

```sql
SELECT <열 목록> 
FROM <테이블1> 별칭A     
	INNER JOIN <테이블1> 별칭B 
[WHERE 검색 조건]
```

![[Pasted image 20240408182237.png]]

# INNER JOIN 과 OUTER JOIN 차이

**INNER JOIN**은 두 테이블 간의 교집합만을 결과로 반환한다. 즉, 두 테이블에 모두 존재하는 데이터만 결과에 포함한다.

**OUTER JOIN**은 한 테이블의 레코드와 다른 테이블의 매칭되는 레코드를 반환하며, 매칭되는 레코드가 없는 경우에도 결과에 포함시킨다. 이때, 매칭되지 않는 필드는 NULL로 값이 채워진다. 

`INNER JOIN`과 `OUTER JOIN`의 선택은 조회하고자 하는 정보의 특성과 필요에 따라 결정된다. `INNER JOIN`은 좀 더 엄격한 매칭 조건을 가지고, `OUTER JOIN`은 더 포괄적인 데이터 세트를 반환 한다.


# GROUP BY

- GROUP BY는 같은 값을 가진 로우를 그룹짓는 SQL 명령어이다.
- COUNT(), MAX(), SUM(), AVG() 등 집계 함수와 함께 사용된다.
- GROUP BY절은 각 그룹의 하나씩만 리턴한다.

> GROUP BY 실행 순서
> FROM -> WHERE -> GROUP BY -> SELECT -> DISTINCT -> ORDER BY -> LIMIT

- GROUP BY로 그룹화된 결과에 대해 추가적인 조건을 적용하고 싶다면, HAVING 절을 사용해야 한다. HAVING은 GROUP BY로 생성된 그룹에 대한 조건을 지정할 때 사용된다.
- 하지만 가능한 HAVING절 사용은 피해야 한다. HAVING 절은 GROUP BY에 의해 결과들을 집계한 후 HAVING절에 명시된 조건으로 맞지 않는 결과를 버리는 과정을 거친다. 그러므로 성능 저하를 일으킬 수 있다.
- 대부분의 경우 HAVING 절 없이 GROUP BY와 WHERE절로 원하는 결과를 얻을 수 있으므로 피하는게 좋다.

# DELETE, TRUNCATE, DROP 차이

DELETE, TRUNCATE, DROP은 삭제와 관련된 명령어이다. 각각 무엇을 삭제하는지가 다르다.

- DELETE : 행 일부 또는 전체 데이터를 지운다.
- TRUNCATE : 행 전체 데이터 뿐만 아니라 행이 저장되어 있던 공간과 인덱스도 삭제된다.
- DROP : 테이블 전체를 삭제한다.

| **비교항목**         | **DELETE**  | **TRUNCATE** | **DROP** |
| ---------------- | ----------- | ------------ | -------- |
| **명령어 분류**       | DML         | DDL          | DDL      |
| **삭제범위**         | 행 데이터 일부~전체 | 행 전체+인덱스 등   | 테이블 전체   |
| **행 데이터(레코드)**   | 일부~전체 삭제    | 전체 삭제        | 전체 삭제    |
| **데이터 저장공간**     | 남겨져 있음      | 삭제           | 삭제       |
| **인덱스**          | 남겨져 있음      | 삭제           | 삭제       |
| **테이블 컬럼, 제약조건** | 남겨져 있음      | 남겨져 있음       | 삭제       |
| **테이블 자체**       | 남겨져 있음      | 남겨져 있음       | 삭제       |

---
## 트랜잭션 특징 ACID

- A : 원자성
	- 트랜잭션 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장
	- All or Noting 
- C : 일관성 
	- 트랜잭션이 성공적으로 완료되면 일관적인 DB 상태를 유지하는 것
- I : 격리성
	- 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것
- D : 지속성
	- 성공적으로 수행된 트랜잭션은 영원히 반영되는 것
	- Commit

> 데이터베이스의 무결성과 일관성을 위해 트랜잭션은 4가지 특징을 만족해야 합니다.
> 원자성은 한 트랜잭션 내 실행한 작업은 모두 성공하거나 실패해야합니다.
> 일관성은 일관성 있는 데이터베이스를 유지시키는 것입니다.
> 격리성은 동시에 실행되는 트랜잭션은 서로에 영향이 없어야하고,
> 지속성은 트랜잭션 완료 시 결과가 영구적으로 반영되어야 합니다.

---
## NoSQL와 RDBMS 차이

- Not Only SQL의 약자로 SQL을 보완한다는 의미

**RDBMS**
- 정형화된 데이터 모델이 필요한 경우
- 복잡한 데이터 조작 및 트랜잭션을 지원하는 경우
- ACID 특성을 요구하는 데이터 일관성이 필요한 경우에 적합하다.

**NoSQL**
- 데이터 모델이 자주 변경되는 경우나 유연한 스키마가 필요한 경우
- 대량의 데이터 처리 및 확장성이 필요한 경우
- 비정형 또는 반정형 데이터를 다루는 경우
- 빠른 읽기 및 쓰기 처리량이 필요한 경우

**RDBMS**
1. 데이터 모델 : 정형화된 데이터 모델을 사용하고, 스키마를 사용하여 데이터 구조를 정의합니다.
2. 쿼리 언어 : SQL을 사용하여 데이터를 조작 및 관리합니다.
3. 스키마 유연성 : 엄격한 스키마를 사용하며, 데이터 모델 변경이 어려울 수 있습니다.
**NoSQL**
1. 다양한 데이터 모델을 사용할 수 있으며, 스키마가 덜 제한적이거나 유연한 스키마 모델을 지원합니다.
2. 다양한 NoSQL 데이터베이스는 각각 고유한 쿼리 언어 또는 API를 사용합니다. (일부는 SQL과 유사)
3. 스키마가 유연하거나 동적으로 조정 가능하므로 데이터 모델 변경이 용이합니다.

> NoSQL은 Not Only SQL의 약자로 SQL을 보완한다는 의미를 가지고 있습니다.
> NoSQL은 스키마가 없어서 데이터를 조회하고 삽입하는 속도가 빠릅니다.
> 또한 대량의 분산 데이터를 저장하는 데 특화되어 있습니다.

> 둘의 가장 큰 차이점은 RDBMS는 정형화된 데이터 모델을 사용하고, NoSQL은 다양한 데이터 모델을 허용하며, 비정형 또는 반정형 데이터를 다루는 데 적합합니다.
> 또한, RDBMS는 ACID 트랜잭션을 지원하여 데이터 일관성과 안정성을 보장하고,
> NoSQL은 일부 시스템에서는 느슨한 일관성 모델을 따르며, 높은 가용성과 확장성을 제공합니다.


---
## 파티셔닝

> 파티셔닝은 데이터베이스 및 분산 시스템에서 사용되는 개념으로, 대량의 데이터를 작은 덩어리로 분할하는 작업을 의미합니다. 각각의 작은 덩어리를 파티션 또는 샤드라고 부르며, 이를 통해 데이터를 효율적으로 저장하고 관리할 수 있습니다. 파티셔닝은 데이터의 성능, 확장성, 관리 용이성을 개선하기 위해 사용됩니다.

---
