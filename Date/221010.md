221010
======

# 시간 복잡도

## 알고리즘이란

* 어떤 목적을 달성하거나 결과물을 만들어내기 위해 거쳐야 하는 일련의 과정들을 의미한다.
* 가는 루트는 다양하며 여러가지 상황에 따른 알고리즘은 모두 다르다. 따라서 시간복잡도가 가장 낮은 알고리즘을 선택하여 사용한다.

여기서 알고리즘의 실행시간은 컴퓨터가 알고리즘 코드를 실행하는 속도에 의존한다. <br>
이 속도는 컴퓨터의 처리속도, 사용된 언어 종류, 컴파일러 속도에 달려있다.

알고리즘의 실행 시간

1. 입력값의 크기에 따라 알고리즘의 실행 시간을 검증해볼 수 있다.
2. 입력값의 크기에 따른 함수의 증가량, 이것을 성장률이라 부른다.

이때 중요하지 않는 상수와 계수들을 제거하면 알고리즘의 실행시간에서 주요한 성장률에 집중할 수 있는데 <br>
점근적 표기법이라 부른다. 
점근적이란 가장 큰 영향을 주는 항만 계산한다는 의미이다.

점근적 표기법은 세가지가 있는데, 시간복잡도를 나타내는데 사용된다.

* 최상의 경우 : 오메가 표기법 (Big-Ω Notation)
* 평균의 경우 : 세타 표기법 (Big-θ Notation)
* 최악의 경우 : 빅오 표기법 (Big-O Notation)

평균인 세타 표기를 하면 가장 정확하고 좋지만 평가하기가 까다롭다.
그래서 최악의 경우인 빅오를 사용하는 데 알고리즘이 최악일 때의 경우를 판단하면
평균과 가까운 성능으로 예측하기 쉽기 때문이다.

<br>

## 빅오 표기법 (Big-O)

빅오 표기법은 불필요한 연산을 제거하여 알고리즘 분석을 쉽게 할 목적으로 사용된다.

Big-O 측정되는 복잡성에는 시간과 공간복잡도가 있는데

* 시간복잡도는 입력된 N의 크기에 따라 실행되는 조작의 수를 나타낸다.
* 공간복잡도는 알고리즘이 실행될 때 사용되는 메모리의 양을 나타낸다. 요즘에는 메모리의 발전으로 중요도가 낮아졌다.

<br>

## 시간 복잡도

시간복잡도의 가장 간단한 정의는 알고리즘의 성능을 설명하는 것이다. <br>
다른 의미로는 알고리즘을 수행하기 위해 프로세스가 수행해야 하는 연산을 수치화한 것이다. <br>
왜 실행시간이 아닌 연산 수치로 판별할까. 명령어의 실행시간은 컴퓨터의 하드웨어 또는 프로그래밍 언어에 따라 편차가 크게 달라지기 때문에 <br>
명령어의 실행 횟수만을 고려하는 것이다.

시간복잡도에서 중요하게 보는 것은 가장 큰 영향을 미치는 n의 단위이다.

> 1             O(1)   --> 상수 <br>
2n + 20       O(n)   --> n이 가장 큰영향을 미친다. <br>
3n^2          O(n^2) --> n^2이 가장 큰영향을 미친다.

시간 복잡도의 문제해결 단계를 나열하면 아래와 같다.

> O(1) – 상수 시간 : 문제를 해결하는데 오직 한 단계만 처리함. <br>
O(log n) – 로그 시간 : 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬. <br>
O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가짐. <br>
O(n log n) : 문제를 해결하기 위한 단계의 수가 N*(log2N) 번만큼의 수행시간을 가진다. (선형로그형) <br>
O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱. <br> 
O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱. <br>

### 참고

https://blog.chulgil.me/algorithm/



